<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>测一测你的代码：关于前端自动化测试</title>
    <url>/2021/09/06/%E6%B5%8B%E4%B8%80%E6%B5%8B%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="开篇：我们需要自动化测试吗"><a href="#开篇：我们需要自动化测试吗" class="headerlink" title="开篇：我们需要自动化测试吗"></a>开篇：我们需要自动化测试吗</h2><p>所谓自动化测试就是<strong>把人对软件的测试行为转化为由机器执行测试行为的一种实践</strong>，对于最常见的 GUI 自动化测试来讲，就是由自动化测试工具模拟之前需要人工在软件界面上的各种操作，并且自动验证其结果是否符合预期。</p>
<p>你是不是有点小激动？这似乎开启了用机器代替重复手工劳动的自动化时代，你可以从简单重复劳动中解放出来了。</p>
<a id="more"></a>
<p>自动化测试的本质是先写一段代码，然后去测试另一段代码，所以实现自动化测试用例本身属于开发工作。因此我们有必要去尝试一把</p>
<img src="https://pic3.zhimg.com/50/89e7fc4ed0bc54deaf2a7df34860bef1_720w.jpg?source=1940ef5c" alt="金坷垃，好处都有啥" style="zoom: 67%;" />



<p>下面例举了几个自动化测试的好处：</p>
<ul>
<li>自动化测试可以替代大量的手工机械重复性操作，测试工程师可以把更多的时间花在更全面的用例设计和新功能的测试上；<ul>
<li>自动化测试可以大幅提升回归测试的效率，非常适合敏捷开发过程；</li>
<li>自动化测试可以高效实现某些手工测试无法完成或者代价巨大的测试类型，比如压力测试等；</li>
<li>自动化测试还可以保证每次测试执行的操作以及验证的一致性和可重复性，避免人为的遗漏或疏忽。</li>
</ul>
</li>
</ul>
<h2 id="代码测试的维度"><a href="#代码测试的维度" class="headerlink" title="代码测试的维度"></a>代码测试的维度</h2><p>代码测试的依据其实主要有两个方面</p>
<ul>
<li>测试合格率： 所有的测试样例(TestCase)在运行过程中得到的结果是否符合断言</li>
<li>代码覆盖率： 在一个或多个case在执行测试的过程中，测试目标的代码是否都执行到了</li>
</ul>
<h3 id="测试合格率"><a href="#测试合格率" class="headerlink" title="测试合格率"></a>测试合格率</h3><p>这个其实比较好理解，测试合格率是最直观的一种测试维度，从某种角度来说，合格率越高能保证我们的产品在大部分情况下可以完成预期的操作，但是这并不保险，因为我们无从得知TestCase的数目或者范围是否合理。</p>
<p>例如这段代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">funtion option(a)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> option(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在黑盒测试情况下，测试人员可能写了大量的TestCase：<code>11,22,...</code>， 但是很不幸，都是 &gt; 10的测试样例，等到使用了这个方法的项目上线之后，这个方法意外输入了&lt;=10的参数，凉凉，运行环境报错（嘿嘿，栈溢出警告）。 这里不难看出，单一看这个合格率这个维度确实很重要，但是很难保证完备性。接下来就来聊聊我们的覆盖率。</p>
<h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>测试覆盖率是衡量测试完整性的一种手段：通过已执行代码的覆盖率，用于评测代码的可靠性和稳定性，可以及时发现没有被测试用例执行到的代码块，提前发现可能的逻辑错误。</p>
<p>代码覆盖率主要有四个指标</p>
<ul>
<li><p>Statements: 语句覆盖率，所有语句的执行率；</p>
</li>
<li><p>Branches: 分支覆盖率，所有代码分支如 if、三目运算的执行率；</p>
</li>
<li><p>Functions: 函数覆盖率，所有函数的被调用率；</p>
</li>
<li><p>Lines: 行覆盖率，所有有效代码行的执行率，和语句类似，但是计算方式略有差别</p>
</li>
</ul>
<p>例如下面这个例子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于上面的代码，可以得到这样一份覆盖率测试结果：</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210828234411355.png" alt="image-20210828234411355" style="zoom:50%;" />

<p>代码中有5个语句（statement），执行了4个；有2个分支（branch），执行了1个；有0个函数，调用了0个；有5行代码，执行4行。</p>
<p>可能有细心的大佬已经发现了，你说两个分支、0个函数我能信，可是这明明有7行代码，为啥这里只统计到了5行？这里其实有一个误区，行覆盖率和语句覆盖率中的行数并不是指代码文件中的行数，而是可执行语句的行数，例如倒数第三行中的<code>} else {</code>和最后一行的<code>}</code>都属于JS提供的语法格式，并不是可执行语句，因此不会被计入。</p>
<p>另外，Statements和Lines为什么是一样的，他们两计算的差异在哪里。这里也解答一下，其实这两种覆盖率确实很相似，Lines的统计维度仅仅在起初的代码文件中， 而Statements则会在JS文件进行一次预编译后的代码进行统计, 当然统计的仍然是有效代码，像函数声明、变量提升这些额外的代码会被忽略。因此大部分情况下 Statements和Lines的统计数据是一致的。</p>
<p><strong>举个例子🌰</strong></p>
<p>对于下面的代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt; <span class="number">10</span>; index += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的覆盖率报告是这样的：Lines总数是2， OK这没有问题，确实是两行有效代码没问题， 而Statements 总数却达到了3。</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829020439021.png" alt="image-20210829020439021" style="zoom:50%;" />

<p>正是由于预编译后，<code>for(let index = 1...)</code>这种写法会在循环体的作用域内又声明并<strong>赋值</strong>一个index，所以上面那个例子中，Statements中的数量变成了3。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">for</span> ( index = <span class="number">1</span>; index &lt; <span class="number">3</span>; index += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而上面这种写法由于预编译后循环体内不会生出新的赋值index的语句，因此statements为2。</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829022622795.png" alt="image-20210829022622795" style="zoom:50%;" />

<p>这里不难看出，代码覆盖率和测试合格率两者相结合能够很好的测试出代码是否健壮。不过代码覆盖率不同与测试合格率那么严格，测试合格率是严格要求所有的case都能100%的通过，诚然拥有100%覆盖率的测试是优秀的，但是我们实际项目是复杂的，并不容易产出测试样例和验证手段，例如UI动画、文件系统的操作等等，这些都是很难进行断言的部分，因此通常是设定一个合格门槛就可以了（完美要求100%覆盖率太过于严苛，甚至会使开发和测试的投入成本本末倒置，不必盲目追求）</p>
<h4 id="番外-前端代码覆盖率的计算是如何实现的"><a href="#番外-前端代码覆盖率的计算是如何实现的" class="headerlink" title="番外 - 前端代码覆盖率的计算是如何实现的"></a>番外 - 前端代码覆盖率的计算是如何实现的</h4><p>这里顺带讲一下前端JS代码覆盖率是如何实现的<strong>「此部分篇幅并非后文必备铺垫，可选择直接跳转到下一节」</strong></p>
<p>目前市面上几乎大部分的Js测试框架中例如Mocha、Ava等使用的覆盖率测试都是基于一款名为Istanbul的开源Js代码覆盖率计算工具。简单说来Istanbul实现的基本方法是注入<strong>（Instrumentation）</strong>， <strong>注入就是在被测代码中自动插入用于覆盖率统计的探针（Probe）代码，并保证插入的探针代码不会给原代码带来任何影响。</strong></p>
<p>详细来说的话，Istanbul会将我们的源码构造成抽象语法数（AST）后，将各个维度标记的代码加入到树节点中，最后输出一个注入了标记的源码，执行后即可得到对应的覆盖率数据。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210830121444196.png" alt="image-20210830121444196"></p>
<p>接下来可以看一下一段代码在经过注入后是什么样的</p>
<p>这是一段源代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (foo &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(foo, <span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>在经过注入探针后的代码大致如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cov_1pwyfn0t92 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处省略较多的代码，这里面返回的是一个计数器对象</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  cov_1pwyfn0t92.f[<span class="number">0</span>]++;</span><br><span class="line">  cov_1pwyfn0t92.s[<span class="number">0</span>]++;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  cov_1pwyfn0t92.f[<span class="number">1</span>]++;</span><br><span class="line">  cov_1pwyfn0t92.s[<span class="number">1</span>]++;</span><br><span class="line">  <span class="keyword">if</span> (foo &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    cov_1pwyfn0t92.b[<span class="number">1</span>][<span class="number">0</span>]++;</span><br><span class="line">    cov_1pwyfn0t92.s[<span class="number">2</span>]++;</span><br><span class="line">    <span class="keyword">return</span> sum(foo, <span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cov_1pwyfn0t92.b[<span class="number">1</span>][<span class="number">1</span>]++;</span><br><span class="line">    cov_1pwyfn0t92.s[<span class="number">3</span>]++;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cov_1pwyfn0t92.s[<span class="number">4</span>]++;</span><br><span class="line">main(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到最开始的源代码几乎被转换成了另一个样子，但原来的代码逻辑是不会改变的，只是注入了一些对原代码执行没有影响的计数语句，很明显这些计数代码就对应了各个维度的计数器：</p>
<table>
<thead>
<tr>
<th>cov_1pwyfn0t92</th>
<th>文件唯一计数对象</th>
</tr>
</thead>
<tbody><tr>
<td>cov_1pwyfn0t92.s</td>
<td>Statement 计数器</td>
</tr>
<tr>
<td>cov_1pwyfn0t92.b</td>
<td>Branch 计数器</td>
</tr>
<tr>
<td>cov_1pwyfn0t92.f</td>
<td>Function 计数器</td>
</tr>
</tbody></table>
<blockquote>
<p> lines可以通过将statements进行计算得出（去除statements中含的预编译时产生的有效代码）</p>
</blockquote>
<p>后面就是执行这个代码并统计和输出覆盖率报告即可</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829030904271.png" alt="image-20210829030904271" style="zoom:50%;" />

<h2 id="前端测试的类型"><a href="#前端测试的类型" class="headerlink" title="前端测试的类型"></a>前端测试的类型</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="单元测试是什么"><a href="#单元测试是什么" class="headerlink" title="单元测试是什么"></a>单元测试是什么</h4><p>单元测试（Unit Test以下简称 - UT）指的是对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类，而在Vue领域还额外包括了组件级别的单元测试。</p>
<blockquote>
<p>就像使用砖头建造房子一样，我们需要保证每块砖头的重量、长宽高参数等数据数据是否符合规范进行测试，用于确保每块砖都是ok的，不会出现空心砖等情况，从而保证用这块砖建造出来的房子都不会因为砖头的质量问题而倒塌。</p>
</blockquote>
<h4 id="我需要使用单元测试吗"><a href="#我需要使用单元测试吗" class="headerlink" title="我需要使用单元测试吗"></a>我需要使用单元测试吗</h4><p><strong>在实际开发中哪些情况下你可能需要写前端UT？ 来做一组判断题</strong></p>
<ol>
<li>你写的是个util类，是会被其他类调用的那种？</li>
<li>你写的是一个公共component，是会被其他工程调用的那种？</li>
<li>你写的是一个开源项目</li>
</ol>
<p>如果以上3个问题有一个肯定回答，你都应该考虑写UT了</p>
<h4 id="单元测试要关注什么"><a href="#单元测试要关注什么" class="headerlink" title="单元测试要关注什么"></a>单元测试要关注什么</h4><p>对于单元测试来说，保证其幂等性非常重要，所谓幂等就是在相同输入的前提下，其输出结果不会随外界因素而改变。</p>
<p>所以，对于函数式编程语言来说，写单元测试则是非常容易的事情，因为在函数式范式中，我们的函数都是纯函数，在范式层面上就已经约束了开发者写出幂等的程序，那么，在javascript领域，我们想要写出质量更高，对测试友好的代码的话，则需要尽可能的写出各种纯函数，从而保证幂等性。</p>
<blockquote>
<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。<em>副作用</em>是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的<em>可观察的交互</em>。</p>
</blockquote>
<p>对于前端而言，其实还包含UI界面的幂等，如何更加高效的保证界面幂等，我们是可以借助jest的快照能力实现html结构级别的幂等验证或者通过gemini的离线截图能力来实现像素级的幂等验证。</p>
<h4 id="单元测试中使用到的自动化技术"><a href="#单元测试中使用到的自动化技术" class="headerlink" title="单元测试中使用到的自动化技术"></a>单元测试中使用到的自动化技术</h4><p><strong>单元测试阶段的“自动化”内涵不仅仅指测试用例执行的自动化，还包含以下几个方面：</strong></p>
<ol>
<li><strong>部分测试输入数据的自动化生成</strong></li>
<li><strong>自动桩代码的生成</strong></li>
<li><strong>测试覆盖率的自动统计与分析</strong></li>
</ol>
<h4 id="在前端项目中使用单元测试"><a href="#在前端项目中使用单元测试" class="headerlink" title="在前端项目中使用单元测试"></a>在前端项目中使用单元测试</h4><p>俗话说的好，“听君一席话，如听一席话”，光说不练假把式，因此我们实际在项目中使用单元测试的姿势究竟是什么样的呢。</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829162309824.png" alt="image-20210829162309824" style="zoom:67%;" />

<p>下文中会使用Jest来进行实践，来体验一番在 Vue + TS 项目中进行不同类型的单元测试。（具体配置流程在此不再赘述，如果有同学感兴趣的话，后期会专门写一篇在Vue项目中配置自动化测试环境的文章，挂到文末）</p>
<h5 id="普通函数的UT"><a href="#普通函数的UT" class="headerlink" title="普通函数的UT"></a>普通函数的UT</h5><p>实际开发中，我们会抽出很多公共方法到utils中，供其他组件或者工具类进行消费，因此函数或者类方法的UT是最常见的。来一个简单的🌰</p>
<p>在<code>util/sqrt.ts</code>文件中编写了一个带有中文报错提示的开平方根函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sqrt</span>(<span class="params">x: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'负值没有平方根'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(<span class="built_in">Math</span>.log(x) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数本身并不秀， 因为我只是加了一个看起来舒适的报错信息，现在在<code>util/__test__/sqrt.spec.ts</code>中编写单元测试的代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sqrt &#125; <span class="keyword">from</span> <span class="string">'../sprt'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'sqrt util test'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 测试用例</span></span><br><span class="line">  it(<span class="string">'4的平方根应该等于2'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    expect(sqrt(<span class="number">4</span>)).toEqual(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'参数为负值时应该报错'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; sqrt(<span class="number">-1</span>); &#125;).toThrow(<span class="string">'负值没有平方根'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>测试代码简单说明</p>
<ul>
<li>describe是作用就是声明一个将几个相关测试组合在一起的块</li>
<li>it是test的别名，可以看作是一个case的测试代码</li>
<li>expect会生成一个预期对象， 提供了很多断言方法，例如toEqual、toThrow等等，开发者还可以像全局expect中添加自定义的断言方法，详细可查看[ <a href="https://www.jestjs.cn/docs/expect" target="_blank" rel="noopener">JestAPI</a> ]</li>
</ul>
<blockquote>
<p>上述方法是Jest运行时会绑定到全局环境的方法，无须单独引入</p>
</blockquote>
<p>在终端中执行<code>jest --coverage</code>, 便能获得测试的运行结果</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829174619107.png" alt="image-20210829174619107"></p>
<p>不难看出，我们所有的测试用例都已经通过了，并且代码覆盖率达到了100%。没错，单元测试就是这么简单！</p>
<h5 id="Vue组件的UT"><a href="#Vue组件的UT" class="headerlink" title="Vue组件的UT"></a>Vue组件的UT</h5><p>组件级的单元测试仅仅使用Jest是不够的，这里还需要引入VueTestUtil——Vue.js 的官方单元测试实用程序库（以下简称vtu），用于在测试代码使用Vue组件。老规矩，上🌰</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829195420033.png" alt="image-20210829195420033"></p>
<p>先来一个简单提示组件。这个组件的HTML结构中含有一个标题和关闭按钮， 并且可以传入类型字段，对应3种不同的配色。除此之外还提供了自动关闭的逻辑，传入自动关闭倒计时后提示组件会自动关闭。模版代码<code>components/alert.vue</code>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;alert__body&quot; :class&#x3D;&quot;type&quot; v-if&#x3D;&quot;isShow&quot;&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;alert__inner&quot; v-text&#x3D;&quot;title&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;button class&#x3D;&quot;alert__button&quot; @click&#x3D;&quot;close&quot;&gt;X&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line no-shadow</span><br><span class="line">const enum AlertType &#123; SUCCESS &#x3D; &#39;success&#39;, INFO &#x3D; &#39;info&#39;, ERROR &#x3D; &#39;error&#39; &#125;</span><br><span class="line"></span><br><span class="line">@Component(&#123;&#125;)</span><br><span class="line">export default class Alert extends Vue &#123;</span><br><span class="line">    @Prop(&#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: AlertType.INFO,</span><br><span class="line">    &#125;) &#x2F;&#x2F; 提示类型，代表了三种不同的色彩风格</span><br><span class="line">    type!: AlertType;</span><br><span class="line"></span><br><span class="line">    @Prop(&#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;我是弹窗&#39;,</span><br><span class="line">    &#125;) &#x2F;&#x2F; 提示框中的文本内容</span><br><span class="line">    title!: string;</span><br><span class="line"></span><br><span class="line">    @Prop(&#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 3,</span><br><span class="line">    &#125;) &#x2F;&#x2F; 自动关闭倒计时 小于等于0时永不关闭</span><br><span class="line">    closeTimeout!: number;</span><br><span class="line"></span><br><span class="line">    isShow &#x3D; true;</span><br><span class="line"></span><br><span class="line">    mounted(): void &#123;</span><br><span class="line">      this.autoClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关闭弹窗逻辑</span><br><span class="line">    close(): void &#123;</span><br><span class="line">      this.isShow &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 自动关闭逻辑</span><br><span class="line">    autoClose(): void &#123;</span><br><span class="line">      if (this.closeTimeout &gt; 0) &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.close();</span><br><span class="line">        &#125;, this.closeTimeout * 1000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.alert__body &#123;</span><br><span class="line">		...</span><br><span class="line">    &amp;.success &#123;</span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.error &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.info &#123;</span><br><span class="line">        background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829194340500.png" alt="image-20210829194340500"></p>
<p>不难看出，我们主要测试的case 有以下几点</p>
<ul>
<li>传入的title是否正常渲染在Dom中</li>
<li>传入自动倒计时是否在指定时间后删除了该组件</li>
<li>点击关闭按钮是否正常从Dom树中删除组件</li>
<li>传入type后，组件是否使用了相应的css class</li>
</ul>
<p>接下来依次编写自动化测试代码, 在<code>components/__test__/alert.spec.ts</code>中编写代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span>;</span><br><span class="line"><span class="keyword">import</span> Alert <span class="keyword">from</span> <span class="string">'../alert.vue'</span>;</span><br><span class="line"><span class="keyword">const</span> TEXT = <span class="string">'我是弹窗'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Alert.vue'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'render test &amp; class'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Alert, &#123;</span><br><span class="line">      propsData: &#123;</span><br><span class="line">        title: TEXT,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> title = wrapper.find(<span class="string">'.alert__inner'</span>).text();</span><br><span class="line">    expect(title).toEqual(TEXT);</span><br><span class="line">    <span class="keyword">const</span> defaultClass = wrapper.find(<span class="string">'.alert__body'</span>).classes();</span><br><span class="line">    expect(defaultClass).toContain(<span class="string">'info'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>为了便于理解测试代码， 这里先说说明一下从<code>vtu</code>中导出的<code>mount</code>方法。</p>
<p>mount方法接受两个参数，第一个是组件，第二个参数是一个配置对象，这里的<code>propsData</code>就是为组件传递了<code>props</code>参数.而mount返回了一个<code>wrapper</code>对象 ， 这个对象包含已安装的组件或 vnode 以及测试组件或 vnode 的方法。</p>
<p>其实目前这段测试代码应该是比较明朗了，主要做了以下事项</p>
<ol>
<li>通过mount方法创建了Alert组件，并且传递了title属性</li>
<li>为了验证title是否正确渲染到了dom上，通过wrapper提供的find方法来查找Dom元素， find入参选择器字符串语法和querySelector是一致的。最后利用wrapper包装了一层text方法来获取innerText属性，并进行验证。</li>
<li>而验证css的class是否成功渲染到dom上， 使用的是classes()方法，这个方法可以获取到实际dom的所有class,并以数组的形式返回。最后通过jest提供的<strong>验证数组内是否包含某个元素</strong>的断言方法.toContain进行验证。</li>
</ol>
<p>最终的运行结果：</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829210942571.png" alt="image-20210829210942571" style="zoom:67%;" />

<p>其实对组件进行测试也并没有那么难对吧， 我们组件还有一个自动关闭的逻辑，这个case应该如何验证，先说一下思路</p>
<ul>
<li>创建一个指定closeTimeout属性的Alert组件</li>
<li>创建后验证该组件中的isShow属性是否为true</li>
<li>若干秒后验证isShow属性是否为false</li>
</ul>
<p>ok, 有了思路之后我们不难发现，验证组件的isShow属性好做，但是如果在指定秒数后验证呢？如果在测试代码中写setTimeout显然太耗费测试时间了。年轻人遇到问题不要慌， 来看验证这个case的代码：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">jest.useFakeTimers();</span><br><span class="line">describe(<span class="string">'Alert.vue'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'it should close after closeTimeout '</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> closeTimeout = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Alert, &#123;</span><br><span class="line">      propsData: &#123;</span><br><span class="line">        closeTimeout,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> vm = wrapper.vm <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    expect(vm.isShow).toBeTruthy();</span><br><span class="line">    jest.runAllTimers();</span><br><span class="line">    expect(vm.isShow).toBeFalsy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>很明显，在代码第一行<code>jest.useFakeTimers();</code>这条语句可以声明当前单元测试中使用的计时器会变为虚拟计时器，通过执行同步代码<code>jest.runAllTimers();</code>，声明当前计时器中的代码已执行完毕。</p>
<p>而验证<code>closeTimeout&lt;=0</code>时不会自动隐藏组件的case和上述代码同理</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'it should not close when closeTimeout is set to &lt;= 0 '</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Alert, &#123;</span><br><span class="line">    propsData: &#123;</span><br><span class="line">      closeTimeout: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> vm = wrapper.vm <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  expect(vm.isShow).toBeTruthy();</span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(vm.isShow).toBeTruthy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上运行结果</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829220812437.png" alt="image-20210829220812437" style="zoom:67%;" />

<p>此时可以看到，我们的组件代码已经100%覆盖了，但是别忘了，我们还有按钮的点击事件没有测试，这个就相当简单了，上代码：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'it should be able to close the alert by clicking close button'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Alert, &#123;</span><br><span class="line">    propsData: &#123;</span><br><span class="line">      closeTimeout: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询关闭按钮dom</span></span><br><span class="line">  <span class="keyword">const</span> closeBtn = wrapper.find(<span class="string">'.alert__button'</span>);</span><br><span class="line">  <span class="comment">// 断言关闭按钮存在</span></span><br><span class="line">  expect(closeBtn.exists()).toBe(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 触发关闭按钮的click事件</span></span><br><span class="line">  <span class="keyword">await</span> closeBtn.trigger(<span class="string">'click'</span>);</span><br><span class="line">  <span class="comment">// isShow变为false</span></span><br><span class="line">  expect((wrapper.vm <span class="keyword">as</span> <span class="built_in">any</span>).isShow).toBeFalsy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210829221917084.png" alt="image-20210829221917084" style="zoom:67%;" />

<p>到这里，Vue组件级的单元测试告一断落，很多断言方法，还有直接在测试代码中改变vue data中的属性值，事实上vtu都提供了，如果感兴趣可以在vtu官方文档里查询。</p>
<p>上述的组件测试主要是通过js-dom在Node环境中模拟浏览器环境的去运行的，运行环境比较单一，并且浏览器是有差异化的，这就造成无法测试到某些边界情况。目前也有在浏览器中运行的前端测试框架，例如cypress.js， 下文中的端对端测试将会进行介绍。</p>
<h3 id="端到端测试（E2E测试）"><a href="#端到端测试（E2E测试）" class="headerlink" title="端到端测试（E2E测试）"></a>端到端测试（E2E测试）</h3><h4 id="端到端测试是什么"><a href="#端到端测试是什么" class="headerlink" title="端到端测试是什么"></a>端到端测试是什么</h4><p>E2E，是“End to End”的缩写，可以翻译成“端到端”测试。它模仿用户，从某个入口开始，逐步执行操作，直到完成某项工作。</p>
<p>通常情况下，单元测试确实能够帮助我们发现大部分的问题，但是在复杂的前端交互或者可视化项目测试中，单纯的单元测试并不能满足真实测试需求，这时候 e2e 测试的优势就显得尤其显著。</p>
<p>优势主要包括：</p>
<ol>
<li>模拟用户行为</li>
<li>模拟真实运行环境</li>
<li>截屏比对</li>
<li>操控运行时环境</li>
</ol>
<p>E2E测试可以被归类为集成测试，在Vue项目中和单元测试的关系大致可以理解为：</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210830170828660.png" alt="image-20210830170828660"></p>
<ul>
<li>组件内部的逻辑由单元测试管控</li>
<li>多个组件之间的联动，并且能够从用户角度形成完整操作链的逻辑，由E2E测试管控</li>
</ul>
<h4 id="在前端项目中使用E2E测试"><a href="#在前端项目中使用E2E测试" class="headerlink" title="在前端项目中使用E2E测试"></a>在前端项目中使用E2E测试</h4><p>在介绍之前先说一下适用E2E测试的一种敏捷开发方式 TDD</p>
<p>TDD 即测试驱动开发（Test-Driven Development），简单来说就是先写好测试case（由于代码还没有开始写，所以测试一定是不通过的），然后迅速开发代码并通过测试（<strong>达到代码“可用”的目标</strong>），由于我们要追求代码的质量，因此需要将代码重构（<strong>追求“简洁”目标</strong>），重构后如果测试不通过则再修复代码是测试样例通过，依此循环。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210830172016984.png" alt="image-20210830172016984"></p>
<p>大概理解后，我们就用TDD的思路来开发一个小案例</p>
<blockquote>
<p> 由于需要使用E2E测试，因此将会使用另外一款测试框架cypress， 它不但提供了E2E测试的能力，还有组件测试的能力。语法结构和Jest也会有一些差异</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/dql0i-nrog1.gif" alt="img"></p>
<p>模拟了一个评论的功能模块构成</p>
<ul>
<li>一个输入框</li>
<li>一个文本展示区域</li>
<li>一个按钮，按钮点击后会清空输入框，并在文本展示区域内显示</li>
</ul>
<p>根据TDD规范，先写测试用例<code>cypress/integration/create_a_message.cy.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'create a message'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'display a message in list'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 访问本地项目运行网址</span></span><br><span class="line">    cy.visit(<span class="string">'http://localhost:8080'</span>);</span><br><span class="line">		<span class="comment">// 查询输入框，并往输入框中填写字符串 new Message</span></span><br><span class="line">    cy.get(<span class="string">"[data-test='messageText']"</span>).type(<span class="string">'new Message'</span>);</span><br><span class="line">		<span class="comment">// 查询send按钮，并执行点击事件</span></span><br><span class="line">    cy.contains(<span class="string">'send'</span>).click();</span><br><span class="line">		<span class="comment">// 查询输入框，并断言value为空</span></span><br><span class="line">    cy.get(<span class="string">'[data-test="messageText"]'</span>).should(<span class="string">'have.value'</span>, <span class="string">''</span>);</span><br><span class="line">		<span class="comment">// 查询当前页面是否存在innerText为new Message的元素</span></span><br><span class="line">    cy.contains(<span class="string">'new Message'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行cypress得到失败的结果</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210830175107760.png" alt="image-20210830175107760"></p>
<p>然后在不考虑其他因素的情况快速完成开发</p>
<p>编写App.vue，完成基本逻辑，并通过e2e测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Code Test Demo&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; data-test&#x3D;&quot;messageText&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;send&quot;&gt;send&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for&#x3D;&quot;(message, index) in messageList&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;&#125;)</span><br><span class="line">export default class App extends Vue &#123;</span><br><span class="line">  message &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">  send(): void &#123;</span><br><span class="line">    this.messageList.push(this.message);</span><br><span class="line">    this.message &#x3D; &#39;&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  messageList:string [] &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210830175237985.png" alt="image-20210830175237985"></p>
<p>由于不能把内容都耦合到页面里，所有要重构</p>
<p>拆分为</p>
<ul>
<li>messageForm.vue 包括输入框和按钮，当点击按钮时清空输入框并提交输入数据</li>
<li>messageList.vue 用于显示从messageForm.vue提交的信息</li>
</ul>
<p>创建好<code>MessageForm.vue</code>后，先写<code>messageForm</code>的测试case, 这里就属于组件级别的单元测试了</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@cypress/vue'</span>;</span><br><span class="line"><span class="keyword">import</span> MessageForm <span class="keyword">from</span> <span class="string">'../messageForm.vue'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'MessageForm.vue'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'should emit "send" event'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    mount(MessageForm);</span><br><span class="line">	  <span class="comment">// 查询输入框dom节点，并输入message</span></span><br><span class="line">    cy.get(<span class="string">'[data-test="messageText"]'</span>).type(<span class="string">'message'</span>);</span><br><span class="line">		<span class="comment">// 查询组件,并执行点击事件</span></span><br><span class="line">    cy.contains(<span class="string">'send'</span>).click().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//断言当前组件是否$emmit('send'), 并传递message字符串</span></span><br><span class="line">      expect(Cypress.vueWrapper.emitted(<span class="string">'send'</span>)?.[<span class="number">0</span>][<span class="number">0</span>]).equal(<span class="string">'message'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>测试不通过</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210830180010910.png" alt="image-20210830180010910"></p>
<p>开始写<code>messageForm.vue</code>里的内容，保证测试通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; data-test&#x3D;&quot;messageText&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;send&quot;&gt;send&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;&#125;)</span><br><span class="line">export default class MessageForm extends Vue &#123;</span><br><span class="line">     message &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">     send(): void &#123;</span><br><span class="line">       const &#123; message &#125; &#x3D; this;</span><br><span class="line">       this.message &#x3D; &#39;&#39;;</span><br><span class="line">       this.$emit(&#39;send&#39;, message);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>测试结果通过</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/3outo-1h1h1.gif" alt="img"></p>
<p>同理完成messageList.vue的重构。这里不在赘述。</p>
<p>最后将重构后的代码重新运行测试，查看是否通过用例。通过至此基于E2E和单元测试的TDD开发流程结束</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/v6vl7-9p1fq.gif" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，自动化测试还是一把“双刃剑”，虽然它可以从一定程度上解放测试工程师的劳动力和开发者在重构时的心智成本，完成一些人工无法实现的测试，但并不适用于所有的测试场景，如果维护自动化测试的代价高过了节省的测试成本，那么在这样的项目中推进自动化测试就会得不偿失。</p>
<p>是否要引入自动化测试，属于决策问题。但是作为我们开发者来说，尝试去了解一些自动化测试领域的工具和知识，对我们的收益还是很大的。</p>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>单元测试</tag>
        <tag>E2E测试</tag>
        <tag>Jest</tag>
        <tag>Cypress</tag>
      </tags>
  </entry>
  <entry>
    <title>写了个支持图片裁切与合并的工具类</title>
    <url>/2021/04/27/%E5%86%99%E4%BA%86%E4%B8%AA%E6%94%AF%E6%8C%81%E5%9B%BE%E7%89%87%E8%A3%81%E5%88%87%E4%B8%8E%E5%90%88%E5%B9%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>由于目前业务需要对图片进行渲染优化相关的工作，现阶段准备从网络请求角度入手，主要的解决思路是将较大的图片在上传前在前端裁剪为多段后上传。最终显示时可以按照裁切的顺序进行逐个加载，或者懒加载，如此一来，首屏等待时间大大减少。</p>
<a id="more"></a>

<h2 id="裁切前"><a href="#裁切前" class="headerlink" title="裁切前"></a>裁切前</h2><p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(15).png" alt="裁切前"></p>
<h2 id="裁切后"><a href="#裁切后" class="headerlink" title="裁切后"></a>裁切后</h2><p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(16).png" alt="裁切后"></p>
<h2 id="借助Canvas实现的支持裁切和合并的CropableImage类"><a href="#借助Canvas实现的支持裁切和合并的CropableImage类" class="headerlink" title="借助Canvas实现的支持裁切和合并的CropableImage类"></a>借助Canvas实现的支持裁切和合并的CropableImage类</h2><p>这里自己写了一个可裁切图片的工具类，目前支持水平裁切与水平合并，基本解决文章开头所提到的需求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> CropableImage &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据图片Src生成ImageElement</span></span><br><span class="line"><span class="comment">     * @param src 图片src</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> loadImage(src: <span class="built_in">string</span> | Blob): <span class="built_in">Promise</span>&lt;HTMLImageElement&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> availableSrc: <span class="built_in">string</span> = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> src !== <span class="string">'string'</span>) &#123;</span><br><span class="line">            availableSrc = URL.createObjectURL(src);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            availableSrc = src;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.src = availableSrc;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            image.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(image);</span><br><span class="line">            &#125;;</span><br><span class="line">            image.onerror = reject;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现图片按照指定高度进行裁剪</span></span><br><span class="line"><span class="comment">     * @param imageSrc 要裁剪图片的Src</span></span><br><span class="line"><span class="comment">     * @param clipHeight 要裁剪的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> clipImage(imageSrc:<span class="built_in">string</span>, clipHeight: <span class="built_in">number</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">string</span> []&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> imageEl = <span class="keyword">await</span> <span class="keyword">this</span>.loadImage(imageSrc);</span><br><span class="line">        <span class="keyword">const</span> &#123; height &#125; = imageEl;</span><br><span class="line">        <span class="keyword">if</span> (height &lt;= clipHeight) &#123; <span class="keyword">return</span> [ imageSrc ]; &#125; <span class="comment">// 返回原来的图片</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> slice = <span class="built_in">Math</span>.ceil(height / clipHeight);</span><br><span class="line">        <span class="keyword">const</span> imageList = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; slice - <span class="number">1</span>; index += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> currentDy = index * clipHeight;</span><br><span class="line">            <span class="keyword">const</span> currentImageBase64 = <span class="keyword">this</span>.generateCanvas(imageEl, currentDy, clipHeight);</span><br><span class="line">            imageList.push(currentImageBase64);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> compute = height % clipHeight;</span><br><span class="line">        <span class="keyword">const</span> lastClipImageHeight = compute &gt; <span class="number">0</span> ? compute : clipHeight;</span><br><span class="line">        <span class="keyword">const</span> lastImageBase64 = <span class="keyword">this</span>.generateCanvas(imageEl, clipHeight * (slice - <span class="number">1</span>), lastClipImageHeight);</span><br><span class="line">        imageList.push(lastImageBase64);</span><br><span class="line">        <span class="keyword">return</span> imageList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从图片中截取一段指定高度的图片</span></span><br><span class="line"><span class="comment">     * @param imageEl ImageElement</span></span><br><span class="line"><span class="comment">     * @param dy 裁切时开始的图片y轴相对位置</span></span><br><span class="line"><span class="comment">     * @param height // 裁切时高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> generateCanvas(imageEl: HTMLImageElement, dy:<span class="built_in">number</span>, clipHeight:<span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.console.log(<span class="string">'dy:'</span> + dy + <span class="string">', height: '</span> + clipHeight);</span><br><span class="line">        <span class="keyword">const</span> &#123; width &#125; = imageEl;</span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        canvas.setAttribute(<span class="string">'width'</span>, width + <span class="string">'px'</span>);</span><br><span class="line">        canvas.setAttribute(<span class="string">'height'</span>, clipHeight + <span class="string">'px'</span>);</span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ctx) &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'CanvasRenderingContext2D was undifined!'</span>); &#125;</span><br><span class="line">        ctx.drawImage(imageEl, <span class="number">0</span>, dy, width, clipHeight, <span class="number">0</span>, <span class="number">0</span>, width, clipHeight);</span><br><span class="line">        <span class="keyword">return</span> canvas.toDataURL(<span class="string">'image/png'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 按照给定的顺序合成为一张图片（宽度要一致）</span></span><br><span class="line"><span class="comment">      * @param imageList 要合并的图片列表，src或者blob数据</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> mergeImage(imageList: (<span class="built_in">string</span> | Blob)[]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imageList.length &lt; <span class="number">1</span>) &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'imageList Not in accordance with the rules'</span>); &#125;</span><br><span class="line">        <span class="keyword">let</span> [ maxWeight, maxHeight ] = [ <span class="number">0</span>, <span class="number">0</span> ];</span><br><span class="line">        <span class="keyword">const</span> imageElList: HTMLImageElement [] = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(imageList.map(<span class="function">(<span class="params">imageSrc, index</span>) =&gt;</span> (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> imageEl = <span class="keyword">await</span> <span class="keyword">this</span>.loadImage(imageSrc);</span><br><span class="line">            <span class="built_in">window</span>.console.log(<span class="string">'sdf'</span>);</span><br><span class="line">            <span class="keyword">const</span> &#123; width, height &#125; = imageEl;</span><br><span class="line">            <span class="keyword">if</span> (width &gt; maxWeight) &#123; maxWeight = width; &#125;</span><br><span class="line">            maxHeight += height;</span><br><span class="line">            imageElList[index] = imageEl;</span><br><span class="line">        &#125;)()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        canvas.setAttribute(<span class="string">'width'</span>, maxWeight + <span class="string">'px'</span>);</span><br><span class="line">        canvas.setAttribute(<span class="string">'height'</span>, maxHeight + <span class="string">'px'</span>);</span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ctx) &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'CanvasRenderingContext2D was undifined!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentHeight = <span class="number">0</span>;</span><br><span class="line">        imageElList.forEach(<span class="function"><span class="params">imageEl</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; width, height &#125; = imageEl;</span><br><span class="line">            ctx.drawImage(imageEl, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, currentHeight, width, height);</span><br><span class="line">            currentHeight += height;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> canvas.toDataURL(<span class="string">'image/png'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>Web音视频串流</title>
    <url>/2021/04/21/Web%E9%9F%B3%E8%A7%86%E9%A2%91%E4%B8%B2%E6%B5%81/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这次分享主要是对在浏览器环境中实现直播的相关技术介绍，其中包括了对音视频的格式以及推送、播放技术的探索。分享过程中还会对目前自己已经实现的一套Web直播方案进行分析。最后还会简单介绍现在比较热门的WebRTC技术。</p>
<h2 id="音视频串流简介"><a href="#音视频串流简介" class="headerlink" title="音视频串流简介"></a>音视频串流简介</h2><p>音视频串流从广义角度来说，就是能够实现设备A将音视频画面同步传输给设备B进行播放，例如电视投屏、会议投屏。而今天所介绍的Web音视频串流主要是实现允许用户在浏览器环境就能完成串流。</p>
<a id="more"></a>

<p>一个完整的Web媒体串流应当具备3种角色，推流客户端（主播侧），媒体服务器（MediaServer）和拉流客户端（观众侧）。其中推流和拉流客户端其实都是在网页中进行处理的，而MediaServer位于服务端，并且要能够完成同时接收来自不同推流客户端的流数据，并对这些流进行区分，向拉流客户端提供获取对应流的渠道。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(8).png" alt="Untitled Diagram (8)"></p>
<h2 id="关于音视频的编码和封装格式概念补充"><a href="#关于音视频的编码和封装格式概念补充" class="headerlink" title="关于音视频的编码和封装格式概念补充"></a>关于音视频的编码和封装格式概念补充</h2><h3 id="音视频编码格式"><a href="#音视频编码格式" class="headerlink" title="音视频编码格式"></a>音视频编码格式</h3><p>在封装格式里的视频可以用不同的编码格式,编码格式简单的理解就是用特定的压缩技术把视频做些处理。不过容器其实也可以做些压缩处理。所以视频是可以在编码格式、容器格式中做两次压缩。</p>
<p>常见的编码格式有:mpeg-2、mpeg-4、h.263、h.264、RV40</p>
<h3 id="音视频封装格式"><a href="#音视频封装格式" class="headerlink" title="音视频封装格式"></a>音视频封装格式</h3><p>封装格式就是把已经编码封装好的视频、音频按照一定的规范放到一起</p>
<p>同一种封装格式中可以放不同编码的视频，不过一种视频容器格式一般是只支持某几类编码格式的视频。我们能够最直观判断封装格式的方法就是文件后缀。</p>
<p>常见的容器格式有: MP4、rmvb、rm、flv、AVI、mov、WMV、mk </p>
<h3 id="浏览器支持的格式"><a href="#浏览器支持的格式" class="headerlink" title="浏览器支持的格式"></a>浏览器支持的格式</h3><p>对于video标签来说，浏览器支持视频播放的封装格式有：MP4、WebM和Ogg。其中我们就MP4来说，必须使用h.264编码的视频和aac编码的音频，才能被浏览器正确解析，否则是没有办法播放的。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(2).png" alt="Untitled Diagram (2)"></p>
<p>下面列出了另外两种封装格式下浏览器能直接解码的音视频编码组合：</p>
<ul>
<li>WebM ：使用 VP8 视频编解码器和 Vorbis 音频编解码器</li>
<li>Ogg：使用 Theora 视频编解码器和 Vorbis音频编解码器</li>
</ul>
<h3 id="适合媒体串流中的封装格式"><a href="#适合媒体串流中的封装格式" class="headerlink" title="适合媒体串流中的封装格式"></a>适合媒体串流中的封装格式</h3><p>由于在媒体串流的过程中，客户端是需要源源不断接受来自外界传输的音视频，并且需要播放已经接受到的部分，后文中把这种特殊的媒体简写为<strong>流媒体</strong>。</p>
<p>而不论是MP4还是WebM还是Ogg都是需要等待完整的数据传递完成后才能够开始播放，并且不能将多个音视频进行无缝连接播放，所以这三种格式统统无法没流媒体利用，凉凉。</p>
<p>因此我们需要其他更加适合串流的媒体封装格式，这里主要介绍下面两种，为后文作铺垫。</p>
<h4 id="FLV（Flash-Video）封装格式"><a href="#FLV（Flash-Video）封装格式" class="headerlink" title="FLV（Flash Video）封装格式"></a>FLV（Flash Video）封装格式</h4><p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(5).png" alt="Untitled Diagram (5)"></p>
<p>FLV格式的流中， 每一个音视频数据都被封装成了包含时间戳信息头的数据包。在传输时，只需要当播放器拿到这些数据包解包的时候能够根据时间戳信息把这些音视频数据和之前到达的音视频数据连续起来播放。</p>
<p>而MP4，MKV等等类似这种封装，必须拿到完整的音视频文件才能播放，因为里面的单个音视频数据块不带有时间戳信息，播放器不能将这些没有时间戳信息数据块连续起来，所以就不能实时的解码播放。</p>
<h4 id="TS（Transport-Stream）封装格式"><a href="#TS（Transport-Stream）封装格式" class="headerlink" title="TS（Transport Stream）封装格式"></a>TS（Transport Stream）封装格式</h4><p>就如TS（传输流）的命名，似乎天生就是为了流媒体而生的一种封装格式，其特点是多个TS片段可以被播放器无缝拼接进行播放，无需等待重新载入。不过TS的实现相对FLV要复杂许多，在此不再说明（太难了🤯）。</p>
<h2 id="音视频串流的协议"><a href="#音视频串流的协议" class="headerlink" title="音视频串流的协议"></a>音视频串流的协议</h2><h3 id="RTMP（Real-Time-Messaging-Protocol-实时信息控制协议）"><a href="#RTMP（Real-Time-Messaging-Protocol-实时信息控制协议）" class="headerlink" title="RTMP（Real Time Messaging Protocol 实时信息控制协议）"></a>RTMP（Real Time Messaging Protocol 实时信息控制协议）</h3><p> RTMP是 Adobe Systems 公司为 Flash 播放器和服务器之间音频、视频和数据传输开发的开放协议， 该协议在国内直播平台中较为普及。</p>
<p>RTMP 是一种基于TCP进行实时流媒体通信的网络协议，主要用来在 Flash 平台和支持 RTMP 协议的流媒体服务器之间进行音视频和数据通信。RTMP协议下可以用来拉流，也可以进行退流。在浏览器中并不支持RTMP协议，只能通过Flash插件进行处理。RTMP传输是所支持的媒体格式为FLV。</p>
<p>主播 ==&gt; MediaServer ==&gt;  观众</p>
<h3 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h3><p>这种协议主要是为了让原本只能在RTMP中进行传输的FLV音视频流也能够在HTTP下进行传输。主要是用于FLV能够在浏览器页面中进行播放，由于HTML的Video不直接支持Flv格式的音视频，所以在早期需要在网页中加入Flash插件才能够播放。目前大量的流媒体服务器 Media Server都支持了将FLV格式流通过HTTP-FLV的形式对外界进行开放。</p>
<h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p>HLS（HTTP Living Stream） 是一个由苹果公司提出的基于 HTTP 的<a href="https://zh.wikipedia.org/wiki/流媒体" target="_blank" rel="noopener">流媒体</a>网络传输协议。</p>
<p>HLS 的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/1382048-20180604152939120-1356963733.png" alt="img" style="zoom:150%;" />

<p>来解释一下这张图，从左到右讲，左下方的inputs的视频源是什么格式都无所谓，他与server之间的通信协议也可以任意（比如RTMP），总之只要把视频数据传输到服务器上即可。这个视频在server服务器上被转换成HLS格式的视频（既TS和m3u8文件）文件。细拆分来看server里面的Media encoder的是一个转码模块负责将视频源中的视频数据转码到目标编码格式（H264）的视频数据。转码成H264视频数据之后，在stream segmenter模块将视频切片，切片的结果就是index file（m3u8）和ts文件了。图中的Distribution其实只是一个普通的HTTP文件服务器，然后客户端只需要访问一级m3u8文件的路径就会自动播放HLS视频流了。</p>
<p>说说m3u8文件</p>
<p>m3u8的命名来源是m3u文件 + utf-8编码而来，两者的文件内容是完全一样的。下文中直接称为m3u</p>
<p>m3u (移动图像专家组音频层3统一资源定位器)</p>
<p>m3u实际上就是一个索引文件，其中可以记录TS文件地址，客户端会按照下载的顺序进行连续播放。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210418115656418.png" alt="image-20210418115656418"></p>
<p>对于一个记录了TS的文件M3U的文件内容如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#EXTM3U &#x2F;&#x2F; 声明文件为M3U，必须写在第一行</span><br><span class="line">#EXT-X-PLAYLIST-TYPE:VOD &#x2F;&#x2F; 当前播放类型为点播</span><br><span class="line">#EXT-X-TARGETDURATION:10 &#x2F;&#x2F;每个视频分段最大的时长（单位秒）</span><br><span class="line">#EXTINF:10, &#x2F;&#x2F;下面ts切片的播放时长</span><br><span class="line">2000kbps-00001.ts &#x2F;&#x2F;ts文件路径</span><br><span class="line">#EXTINF:10,</span><br><span class="line">2000kbps-00002.ts</span><br><span class="line">#ZEN-TOTAL-DURATION:20</span><br><span class="line">#ZEN-AVERAGE-BANDWIDTH:2190954</span><br><span class="line">#ZEN-MAXIMUM-BANDWIDTH:3536205</span><br><span class="line">#EXT-X-ENDLIST &#x2F;&#x2F; m3u结束指令</span><br></pre></td></tr></table></figure>

<p>不光如此，m3u还可以记录二级m3u的文件的地址。</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/1328846-d0df01e6b2dec3bb.png" alt="1328846-d0df01e6b2dec3bb" style="zoom:50%;" />

<p>下面是一个记录了文件地址的m3u8内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID&#x3D;1,BANDWIDTH&#x3D;2128000</span><br><span class="line">drawingSword(1080p).m3u8</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID&#x3D;1,BANDWIDTH&#x3D;1064000</span><br><span class="line">drawingSword(720p).m3u8</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID&#x3D;1,BANDWIDTH&#x3D;564000</span><br><span class="line">drawingSword(480p).m3u8</span><br><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID&#x3D;1,BANDWIDTH&#x3D;282000</span><br><span class="line">drawingSword(360p).m3u8</span><br><span class="line">#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure>

<p>bandwidth指定视频流的比特率，PROGRAM-ID表示资源的ID，每一个#EXT-X-STREAM-INF的下一行是二级index文件的路径，可以用相对路径也可以用绝对路径。例子中用的是相对路径。这个文件中记录了不同比特率视频流的二级index文件路径，客户端可以当前环境的网络带宽，来决定播放哪一个视频流。也可以在网络带宽变化的时候平滑切换到和带宽匹配的视频流。</p>
<h4 id="HLS目前的不足"><a href="#HLS目前的不足" class="headerlink" title="HLS目前的不足"></a>HLS目前的不足</h4><p>由于HLS需要将采集到的音视频进行分片、客户端也需要对接受到的分片后的音视频进行合并处理，因此相对来时会存在比较大的延迟，大概会达到 10s左右。</p>
<h5 id="HLS在浏览器中的兼容情况"><a href="#HLS在浏览器中的兼容情况" class="headerlink" title="HLS在浏览器中的兼容情况"></a>HLS在浏览器中的兼容情况</h5><p>事实上，HLS 在 PC 端仅支持safari浏览器，而其他大部分PC浏览器使用HTML5 video标签由于无法解析TS所以不能直接播放(需要通过hls.js)。移动端不论是安卓还是IOS统统都原生支持HLS。这点主要是由于HLS是由Apple公司推广的，苹果自家的浏览器上都是支持的，而安卓也进行了跟进。所以如果想要在PC浏览器上使用到HLS，仍然需要使用其他技术手段才能实现。</p>
<p>各协议总结：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>http-flv</th>
<th>rtmp</th>
<th>hls</th>
</tr>
</thead>
<tbody><tr>
<td>传输层</td>
<td>http</td>
<td>tcp</td>
<td>http</td>
</tr>
<tr>
<td>视频格式</td>
<td>flv</td>
<td>flv</td>
<td>Ts文件</td>
</tr>
<tr>
<td>延时</td>
<td>低</td>
<td>低</td>
<td>很高</td>
</tr>
<tr>
<td>数据分段</td>
<td>连续流</td>
<td>连续流</td>
<td>切片文件</td>
</tr>
<tr>
<td>Html5播放</td>
<td>暂不支持</td>
<td>不支持</td>
<td>移动端支持</td>
</tr>
</tbody></table>
<h2 id="WebSocket-RTMP在网页中进行音视频串流的方案"><a href="#WebSocket-RTMP在网页中进行音视频串流的方案" class="headerlink" title="WebSocket + RTMP在网页中进行音视频串流的方案"></a>WebSocket + RTMP在网页中进行音视频串流的方案</h2><p>所谓兼容RTMP的方案就是，把RTMP推流的工作放到中间服务层（此次以Node为例）去,而拉流通过流媒体服务器开放的HTTP-FLV，并在播放前使用Flv.js将转换后的流数据喂给Video去解析播放。</p>
<p>这里需要介绍一款处理音视频非常有效的工具 FFmpeg, 这款工具提供以命令行的方式去对视频进行转码、转封装格式、增加水印等等功能其中还包括了RTMP推流的功能。同时FFmpeg也为Node提供了一些控制的Bridge，在后文中，我会在中间层使用Node来控制FFmpeg进行音视频的推流。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/loadimage.png" alt="loadimage"></p>
<h3 id="推流客户端-gt-Node中间处理层"><a href="#推流客户端-gt-Node中间处理层" class="headerlink" title="推流客户端 =&gt; Node中间处理层"></a>推流客户端 =&gt; Node中间处理层</h3><p>这里有包括两种推流的音视频源，一种是实时录制自己的摄像头进行推流。另外一种是使用本地的视频文件进行发送。这里我们分开来讲</p>
<p>对于推流客户端推送实时录制的音视频数据时，其核心操作就用过浏览器来调用摄像头数据，并通过<a href="https://github.com/streamproc/MediaStreamRecorder" target="_blank" rel="noopener">MediaStreamRecorder.js</a>去捕获音视频二进制数据（Blob）注意此处每个时间片返回一个blob，获得当前时间片的Blob后通过WebSocket将blob数据传递给Node中间层。</p>
<p>而对于推流客户端推送视频格式的文件时，需要做的就是将视频文件按照每段时间的视频量进行分片。例如对于一个100s的视频，如果按照每段blob需要发送4s的数据量，那就需要分为25段blob，这些可以通过前端去进行分片，分片发送的中间Node层。后面的操作就和摄像头推流一致了。</p>
<h3 id="Node中间处理层-gt-流媒体服务器"><a href="#Node中间处理层-gt-流媒体服务器" class="headerlink" title="Node中间处理层 =&gt; 流媒体服务器"></a>Node中间处理层 =&gt; 流媒体服务器</h3><p>在Blob数据抵达Node中间层后会被转化为Buffer，在Node层我们需要做的这些分段的视频格式转化为ts格式的片段，再将ts片段（这里就利用到了TS能够无缝拼接进行播放的特性，能够让ffmpeg推送持续的流媒体）通过ffmpeg将持续不断接受到的TS格式的流媒体转化为Flv流并通过RTMP推流到流媒体服务器上。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(12).png" alt="Untitled Diagram (12)"></p>
<p>流媒体服务器是在Node.js环境下通过node-media-server第三方包进行搭建。Node-media-server许多不同协议的推流和拉流的方法。其中它支持外界通过RTMP的方式进行推流拉流（端口1935），也支持将RTMP流转换为HTTP-FLV协议的流对外开放（端口8000）。通过Node-media-server建立一个流媒体服务步骤也很简单，只需要如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeMediaServer = <span class="built_in">require</span>(<span class="string">'node-media-server'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  rtmp: &#123;</span><br><span class="line">    port: <span class="number">1935</span>,</span><br><span class="line">    chunk_size: <span class="number">60000</span>,</span><br><span class="line">    gop_cache: <span class="literal">true</span>,</span><br><span class="line">    ping: <span class="number">30</span>,</span><br><span class="line">    ping_timeout: <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  http: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    allow_origin: <span class="string">'*'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nms = <span class="keyword">new</span> NodeMediaServer(config)</span><br><span class="line">nms.run();</span><br></pre></td></tr></table></figure>

<p>在Node-media-server中，提供了通过使用不用的URL路径来对流进行区分。这里贴上一个官方提供的URL格式</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rtmp:<span class="regexp">//</span>hostname:port<span class="regexp">/appname/</span>stream</span><br><span class="line">http:<span class="regexp">//</span>hostname:port<span class="regexp">/appname/</span>stream.flv</span><br></pre></td></tr></table></figure>
<p>例如对于音视频流A，它的URL是这样的：</p>
<p>rtmp://47.110.88.142:1935/live/root_14465</p>
<p>可以看出对于这个流，appName这里被命名为了live, 而stream被命名为了root_14465。对应的，如果想通过HTTP-FLV进行拉这条流，可以通过下面这条URL:</p>
<p><a href="http://47.110.88.142:8000/live/root_14465.flv" target="_blank" rel="noopener">http://47.110.88.142:8000/live/root_14465.flv</a></p>
<p>在完成流媒体服务器的搭建后，不同用户会生成对应不同的推流URL，只要为观众发放正确对应的拉流URL就会播放正确的流数据。实现了并行串流的目的。</p>
<p>本地演示：</p>
<ol>
<li>起流媒体服务器</li>
<li>通过ffmpeg推流</li>
<li>通过http-flv拉流</li>
</ol>
<h3 id="流媒体服务器-gt-拉流客户端"><a href="#流媒体服务器-gt-拉流客户端" class="headerlink" title="流媒体服务器 =&gt; 拉流客户端"></a>流媒体服务器 =&gt; 拉流客户端</h3><p>通过Http-flv进行传输，浏览器的video标签通过http获取到flv流后，使用Flv.js【后文中介绍】进行转换封包格式后为MP4后便能够持续播放。</p>
<h4 id="Flv-js"><a href="#Flv-js" class="headerlink" title="Flv.js"></a>Flv.js</h4><p>B站开源的一款媒体流转码插件，该插件能够利用Js将接受到的HTTP-FLV实时转码为Video能够接受的MP4格式。</p>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/architecture.png" alt="img" style="zoom: 67%;" />

<p>得益于浏览器提供了Media Source Extensions API（MSE）,使得flv.js能够通过JavaScript来对流数据格式进行转换，并分片为</p>
<p>这里我们贴一段flv.js的简单的使用代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"flv.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"videoElement"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    if (flvjs.isSupported()) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> videoElement = <span class="built_in">document</span>.getElementById(<span class="string">'videoElement'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> flvPlayer = flvjs.createPlayer(&#123;</span></span><br><span class="line"><span class="actionscript">            type: <span class="string">'flv'</span>,</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">'http://example.com/flv/video.flv'</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">        flvPlayer.attachMediaElement(videoElement);</span><br><span class="line">        flvPlayer.load();</span><br><span class="line">        flvPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Flv-js不足"><a href="#Flv-js不足" class="headerlink" title="Flv.js不足"></a>Flv.js不足</h5><p>MSE目前在PC端浏览器上支持较好，但是一些较低版本的移动端流览器就不是那么理想了如图：</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210418002005470.png" alt="image-20210418002005470"></p>
<p>由于Flv.js是基于MSE制作的，所以一些低版本移动端流览器中是无法正常播放的，因此在考虑兼容性的情况下需要慎用。</p>
<h2 id="关于WebRTC"><a href="#关于WebRTC" class="headerlink" title="关于WebRTC"></a>关于WebRTC</h2><p>在研究Web音视频串流的时候，发现了一种新兴的平台 - Web视频会议，用户直接通过PC浏览器即可加入音视频会议。列出一些目前市场上的web视频会议产品：</p>
<p>Google Meet: <a href="https://meet.google.com" target="_blank" rel="noopener">https://meet.google.com</a></p>
<p>轻雀视频会议<a href="https://www.qingque.cn/meet/" target="_blank" rel="noopener">https://www.qingque.cn/meet/</a></p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210419160402279.png" alt="image-20210419160402279"></p>
<p>而移动端的浏览器由于种类繁多并不能较好的适配，因此不被推荐直接在移动端浏览器中使用web视频会议。</p>
<p>Google给出的方案是需要下载一个应用程序GoogleMeet，而轻雀给出的方案比较适合国内的场景，提供了微信小程序或者轻雀APP两种方式供参会者加入。</p>
<p>如果从音视频串流的角度来思考，视频会议就是让传统的单向直播变化为了双向直播，即每个参与者即需要推流，也需要拉流。但是显然这样对流媒体服务器的压力过于庞大，并且还有不可忽视的延时问题。因此促进了Google对WebRTC的建设。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(9).png" alt="Untitled Diagram (9)"></p>
<p>而这两种视频会议都是由WebRTC技术进行实现的</p>
<blockquote>
<p>WebRTC （Web Real-Time Communications） 是一项由Google推行的实时通讯技术，它允许网络应用或者站点，在<strong>不借助中间媒介</strong>的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。</p>
</blockquote>
<p>大部分主流浏览器为开发者开放了可以开箱即用WebRTC - API，可以通过执行API就能呼叫指定的Peer并建立连接。但需要注意使用WebRTC技术虽然音视频数据不经过服务端传输，但是仍然需要服务端去交换一些连接的必要信息。</p>
<h3 id="WebRTC技术的工作流"><a href="#WebRTC技术的工作流" class="headerlink" title="WebRTC技术的工作流"></a>WebRTC技术的工作流</h3><p>WebRTC更适合用来做Web视频会议的原因就是它能够实现浏览器和浏览器之间进行音视频的传输。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(10).png" alt="Untitled Diagram (10)"></p>
<p>这其中的传输过程如图。这里面的PeerN指的是连接的浏览器客户端，在多个Peer连接之前，每个Peer需要和信令服务器（Signaling Server）进行连接，这里面提到的信令服务器需要由开发者自行搭建。</p>
<p>可以看到Peer与 信令服务器的连接是双向的，这是因为连接的各方需要通过信令服务器交换一些关键信息，这些信息都会以信令的信息发送和接受。</p>
<p>Peer之间主要需要交换下面3种类型的信息</p>
<ul>
<li>初始化和关闭通信，及报告错误；</li>
<li>用户WebRTC的的IP和端口号</li>
<li>当前浏览器支持播放的音视频编码及封装格式，以及能播放的最高分辨率等信息。</li>
</ul>
<p>其中需要重点关注第二点，因为需要交换各个Peer之间的IP来进行Peer之间的连接，所以要保证Peer之间是要能够正确访问到对方ip的，如果所有的Peer都是在同一个局域网下没有问题，但是如果参会的Peer来自不通的局域网，那么他们交换的IP是无法访问到的。</p>
<p>所以在这里还需要增加一个借助另一种服务器（称为STUN server）实现NAT/Firewall穿越。主要做的工作就是将用户交换IP的过程中需要把根据局域网IP生成一个公网IP，这样就实现了公网环境的传输。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/Untitled%20Diagram%20(11).png" alt="Untitled Diagram (11)"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>具体应当如何建设一个WebRTC方案的Web音视频会议平台的方法，目前能力尚浅，还需要进一步实践和探索。如果有机会，未来会继续分享有关WebRTC相关的支持。感谢大家宝贵时间！</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>音视频</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器工具函数[持续更新]</title>
    <url>/2021/04/02/%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="TypeScript中的装饰器"><a href="#TypeScript中的装饰器" class="headerlink" title="TypeScript中的装饰器"></a>TypeScript中的装饰器</h2><p>随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。</p>
<a id="more"></a>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>更新tsconfig.json,开启装饰器实验功能</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目中，在方法或属性前一行通过@[装饰器名称] 加入装饰器</p>
<p>例如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Submit &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> onClick(): <span class="built_in">void</span> &#123; <span class="comment">// 这是一个Submit类下普通的方法但是我们现在想为这个onclick方法加入防抖功能</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'submit'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入装饰器后, 这种非入侵式的加入功能，和设计模式中装饰器模式非常契合！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Submit &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Debounce</span>() <span class="comment">// 此处是防抖装饰器</span></span><br><span class="line">  <span class="keyword">private</span> onClick(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'submit'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要知道"><a href="#需要知道" class="headerlink" title="需要知道"></a>需要知道</h3><p>目前浏览器中并不直接支持装饰器的语法，JavaScript中的装饰器也还只在提案阶段。而前端大佬阮一峰也只对之前旧提案的语法进行了解释<a href="https://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">[阮一峰的装饰器教程]</a></p>
<p>因此，TypeScirpt中装饰器在编译后看不到任何@等特殊语法，而是将装饰器和装饰的目标生成一个混合的方法或属性，然后使用<code>Object.defineProperty()</code>来重新定义到原有的方法和属性。</p>
<p>著名的工具函数第三库lodash也发布了装饰器版本，其中包含了大量的工具装饰器<a href="https://github.com/steelsojka/lodash-decorators#readme" target="_blank" rel="noopener">lodash-decorators</a></p>
<h2 id="装饰器方法【持续更新】"><a href="#装饰器方法【持续更新】" class="headerlink" title="装饰器方法【持续更新】"></a>装饰器方法【持续更新】</h2><p>该列表中将会持续更新一些自己编写的装饰器方法（可能lodash中已经存在，但也可能没有），作为方法仓库</p>
<h3 id="Debounce-防抖"><a href="#Debounce-防抖" class="headerlink" title="Debounce 防抖"></a>Debounce 防抖</h3><p>防止抖动</p>
<ul>
<li>delay 延迟</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [装饰器]防止抖动</span></span><br><span class="line"><span class="comment"> * @param delay 延迟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Debounce</span>(<span class="params">delay = 300</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        target: <span class="built_in">Object</span>,</span><br><span class="line">        propertyKey: <span class="built_in">string</span>,</span><br><span class="line">        propertyDecorator: PropertyDescriptor</span><br><span class="line">    ): <span class="function"><span class="params">PropertyDescriptor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> methods = propertyDecorator.value;</span><br><span class="line">        <span class="keyword">let</span> timer: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">        propertyDecorator.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">            timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(methods.bind(<span class="keyword">this</span>, ...args), delay);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> propertyDecorator;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ClickOutside-处理点击某元素外的事件"><a href="#ClickOutside-处理点击某元素外的事件" class="headerlink" title="ClickOutside 处理点击某元素外的事件"></a>ClickOutside 处理点击某元素外的事件</h3><p>处理点击指定元素之外的事件，配合Vue使用，推荐在mounted及以后的生命周期中执行</p>
<ul>
<li>offscaleElRef 指定元素的ref值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理点击指定元素之外的工具，推荐在mounted及以后的生命周期中执行</span></span><br><span class="line"><span class="comment"> * @param offscaleElRef 指定元素的ref值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ClickOutside</span>(<span class="params">offscaleElRef: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        target: <span class="built_in">Object</span>,</span><br><span class="line">        propertyKey: <span class="built_in">string</span>,</span><br><span class="line">        propertyDecorator: PropertyDescriptor</span><br><span class="line">    ): <span class="function"><span class="params">PropertyDescriptor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> methods = propertyDecorator.value;</span><br><span class="line">        propertyDecorator.value = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> offscaleEl = <span class="keyword">this</span>.$refs[offscaleElRef];</span><br><span class="line">            <span class="keyword">if</span> (offscaleEl &amp;&amp; offscaleEl.contains) &#123;</span><br><span class="line">                <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!event || !event.target) <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">const</span> clickEl = event.target <span class="keyword">as</span> HTMLElement;</span><br><span class="line">                    <span class="keyword">const</span> clickSelf = offscaleEl.contains(clickEl);</span><br><span class="line">                    <span class="keyword">if</span> (!clickSelf) &#123;</span><br><span class="line">                        methods.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> propertyDecorator;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Webpack</tag>
        <tag>装饰器语法</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript渐进式入门</title>
    <url>/2021/04/02/TypeScript%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本部分主要是一些基础概念，掌握后可以从JavaScript语法习惯转变为TypeScript。</p>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>表示形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:string = <span class="string">"test"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串：<code>string</code></li>
<li>数字：<code>number</code></li>
<li>布尔值：<code>boolean</code></li>
<li>空值：<code>void</code> (主要用于表示函数无返回值或返回值为null时的定义)</li>
<li>任意值：<code>any</code>  (意味着不限制类型，可以为任意值)</li>
<li>其他：<code>undefined</code>、<code>null</code></li>
</ul>
<a id="more"></a>

<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>TS提供两种类型推论机制（代码中未定义类型时，编译时自动增加类型）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar     <span class="comment">//  等同于 let bar:any</span></span><br><span class="line">bar = <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 = <span class="string">"str"</span> <span class="comment">// 等价于const t1:string = "str"</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用类型推断后，不能在随意修改为其他类型，例如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = <span class="string">"string"</span> <span class="comment">// 此时相当于被ts推断为了 let bar:string = "string"</span></span><br><span class="line">bar = <span class="number">1</span> <span class="comment">// error 类型冲突</span></span><br></pre></td></tr></table></figure>

<p>数组也是如此</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">bar[<span class="number">1</span>] = <span class="string">'c'</span> <span class="comment">// OK</span></span><br><span class="line">bar[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// ERROR</span></span><br><span class="line"></span><br><span class="line">bar = [<span class="string">'b'</span>,<span class="string">'a'</span>] <span class="comment">// OK</span></span><br><span class="line">bar = [<span class="number">2</span>, <span class="number">1</span>] <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>对于对象</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; a: <span class="string">'123'</span>, b: <span class="number">234</span>, c: <span class="literal">true</span> &#125; <span class="comment">//自动被推断生成一个接口</span></span><br><span class="line">bar.a = <span class="string">'test'</span> <span class="comment">// OK</span></span><br><span class="line">bar.b = <span class="string">'test'</span> <span class="comment">//ERROR 类型冲突</span></span><br><span class="line">bar.d = <span class="number">123</span> <span class="comment">// ERROR 不存在属性“d”</span></span><br></pre></td></tr></table></figure>



<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br></pre></td></tr></table></figure>

<p>联合类型使用 <code>|</code> 分隔每个类型。</p>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，开发者只能访问此联合类型的所有类型里共有的属性或方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;  <span class="comment">// 编译器发生报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br></pre></td></tr></table></figure>



<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>extend是一种非常常见的模式，可以从多个对象合并为一个新的对象。而在TS中，交叉类型可以让你安全的使用此模式 ,通过<code>&amp;</code> 对类型进行连接</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">object</span>,<span class="title">B</span>&gt;(<span class="params">first: T, second: U, dsf:B</span>): <span class="title">T</span> &amp; <span class="title">U</span> &amp; <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125; <span class="keyword">as</span> T &amp; U &amp; B <span class="comment">// 将res别名设置为T、U、B泛型的交叉类型,为了能够正常将res return出去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> first) &#123;</span><br><span class="line">        (res <span class="keyword">as</span> T)[key] = first[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> second) &#123;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="built_in">Object</span>.prototype.hasOwnProperty.call(res,key))&#123;</span><br><span class="line">        (res <span class="keyword">as</span> U)[key] = second[key]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> dsf) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Object</span>.prototype.hasOwnProperty.call(res,key))&#123;</span><br><span class="line">         (res <span class="keyword">as</span> B)[key] = dsf[key]</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bp = extend(&#123;a:<span class="string">'123'</span>&#125;,&#123;a:<span class="string">'222'</span>,b:<span class="number">234</span>&#125;,&#123;b: <span class="number">888</span>, c:<span class="literal">true</span>&#125;) <span class="comment">//&#123; a: '123', b: 234, c: true &#125;</span></span><br></pre></td></tr></table></figure>





<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口用于规范对象的属性和方法，是对象的类型。</p>
<h4 id="确定属性"><a href="#确定属性" class="headerlink" title="确定属性"></a>确定属性</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">	name:<span class="built_in">string</span>;</span><br><span class="line">  age:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Tom:Person&#123;</span><br><span class="line">	name: <span class="string">"Tom"</span>,</span><br><span class="line">  age:<span class="number">19</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口定义关键字<code>interface</code>；每个字段定义完毕之后用分号分割</p>
<p>接口的定义与Java一致，实例赋值的时候不能比接口定义的少或者多，需要与接口的形状保持一致。</p>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>使用<code>?</code>修饰的属性是可选的，不要求实例必须实现该属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时<strong>仍然不允许添加未定义的属性</strong></p>
<h4 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h4><p>在有些书上也会被称之为“索引签名”。 有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用[propName: string]定义了任意属性可以取any值</p>
<p>任意属性的<code>string</code>是<code>KeyType</code>，而<code>any</code>代表<code>ValueType</code></p>
<p>需要注意的是，<strong>任意属性被定义后，其他与任意属性相同<code>KeyType</code>的各种属性在赋值时会先去校验一次任意属性的<code>ValueType</code></strong></p>
<p>以下代码将发生变异错误</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;  <span class="comment">// string 无法同时满足name和age</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line"><span class="comment">// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.</span></span><br><span class="line"><span class="comment">//   Index signatures are incompatible.</span></span><br><span class="line"><span class="comment">//     Type 'string | number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="comment">//       Type 'number' is not assignable to type 'string'.</span></span><br></pre></td></tr></table></figure>

<p>上例中将任意属性改为联合类型即可</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">[propName: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>或者把任意属性的类型改成非string类型（当然这也就意味着新增的任意属性值只能为number了）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">[propName: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用一组有限的字符串字面量作为属性"><a href="#使用一组有限的字符串字面量作为属性" class="headerlink" title="使用一组有限的字符串字面量作为属性"></a>使用一组有限的字符串字面量作为属性</h5><p>一个索引签名可以通过映射类型来使索引字符串为联合类型中的一员，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Index = <span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">type</span> FromIndex = &#123; [k <span class="keyword">in</span> Index]?: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> good: FromIndex = &#123; b: <span class="number">1</span>, c: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error:</span></span><br><span class="line"><span class="comment">// `&#123; b: 1, c: 2, d: 3 &#125;` 不能分配给 'FromIndex'</span></span><br><span class="line"><span class="comment">// 对象字面量只能指定已知类型，'d' 不存在 'FromIndex' 类型上</span></span><br><span class="line"><span class="keyword">const</span> bad: FromIndex = &#123; b: <span class="number">1</span>, c: <span class="number">2</span>, d: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>



<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>如果需要某个属性在<strong>对象赋值</strong>后就不能被改变可以在接口中使用<code>readonly</code>关键字来定义只读属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    id: <span class="number">89757</span>,</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure>

<p>只读属性也是在定义时必必须要填的，<strong>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><h4 id="类型-方括号表示法"><a href="#类型-方括号表示法" class="headerlink" title="类型+方括号表示法"></a>类型+方括号表示法</h4><p>数组内容需要符合数组类型定义</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]; <span class="comment">//只能存在number类型的数组元素</span></span><br></pre></td></tr></table></figure>

<h4 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h4><p>也可以使用范型的方式来定义数组类型<code>Array&lt;elemType&gt;</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h4 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h4><p>利用任意属性来表示数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>通常不用这种方法来表示数组，但是这个方式可以有效的用来表示类数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: &#123;</span><br><span class="line">        [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">        length: <span class="built_in">number</span>;</span><br><span class="line">        callee: <span class="built_in">Function</span>;</span><br><span class="line">    &#125; = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> [参考内置对象章节]等：</strong></p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p><strong>function</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数表达式</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型推断简写方式</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum:<span class="function">(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>



<p><strong>箭头函数</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = (a:<span class="built_in">number</span>,b:<span class="built_in">number</span>):<span class="function"><span class="params">number</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>回调函数</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array:<span class="built_in">any</span>[],callback:(el?:<span class="built_in">any</span>,index?:<span class="built_in">number</span>,arr?:<span class="built_in">any</span>[])=&gt;<span class="built_in">any</span></span>):<span class="title">any</span></span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result:<span class="built_in">any</span>[] = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i:<span class="built_in">number</span> = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">  	result.push(callback(array[i],i,[...array]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仿写一个TS版的Array.prototype.map方法。其中map的第二个形参就是回调函数定义的方法。</p>
<h4 id="利用接口定义函数的形状"><a href="#利用接口定义函数的形状" class="headerlink" title="利用接口定义函数的形状"></a>利用接口定义函数的形状</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> sumFunc&#123;</span><br><span class="line">  (a:<span class="built_in">number</span>,b:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum:sumFunc</span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</strong></p>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>正常情况下，输入多余的（或者少于要求的）参数，是不允许的。但是可以用 <code>?</code> 表示可选的参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong></p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>可以为类型定义别名，定义后可以直接使用别名来进行变量声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameResolve = <span class="function"><span class="params">()</span> =&gt;</span> Name</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n:NameResolve</span>):<span class="title">Name</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>字面量类型用来约束取值只能是某几个字符串中的一个。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ab = <span class="number">1</span> | <span class="string">'1'</span> | <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> k:ab = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b:ab = <span class="number">2</span></span><br><span class="line"><span class="comment">//error TS2322: Type '2' is not assignable to type 'ab'.</span></span><br></pre></td></tr></table></figure>



<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>数组是合并相同类型的对象，而元组可以合并不同类型的对象</p>
<p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Tom'</span>, <span class="number">25</span>];</span><br></pre></td></tr></table></figure>

<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">'Tom'</span>;</span><br><span class="line">tom[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">tom[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">tom[<span class="number">1</span>].toFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>也可以只赋值其中一项：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">'Tom'</span>;</span><br></pre></td></tr></table></figure>

<p>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">'Tom'</span>, <span class="number">25</span>];</span><br><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">'Tom'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property '1' is missing in type '[string]' but required in type '[string, number]'.</span></span><br></pre></td></tr></table></figure>

<h4 id="越界的元素"><a href="#越界的元素" class="headerlink" title="越界的元素"></a>越界的元素</h4><p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">'Tom'</span>, <span class="number">25</span>];</span><br><span class="line">tom.push(<span class="string">'male'</span>);</span><br><span class="line">tom.push(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type 'true' is not assignable to parameter of type 'string | number'.</span></span><br></pre></td></tr></table></figure>

<p>注意ts本质上无法进行运行时检测，所以push被优化为了联合类型检测。但是，如果是直接字面量对数组进行赋值，编译是无法通过的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tom:[<span class="built_in">string</span>,<span class="built_in">number</span>]</span><br><span class="line">tom[<span class="number">2</span>] = <span class="number">123</span></span><br><span class="line"><span class="comment">//. Tuple type '[string, number]' of length '2' has no element at index '2'.</span></span><br></pre></td></tr></table></figure>



<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="普通枚举"><a href="#普通枚举" class="headerlink" title="普通枚举"></a>普通枚举</h4><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Days);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  '0': 'Sun',</span></span><br><span class="line"><span class="comment">  '1': 'Mon',</span></span><br><span class="line"><span class="comment">  '2': 'Tue',</span></span><br><span class="line"><span class="comment">  '3': 'Wed',</span></span><br><span class="line"><span class="comment">  '4': 'Thu',</span></span><br><span class="line"><span class="comment">  '5': 'Fri',</span></span><br><span class="line"><span class="comment">  '6': 'Sat',</span></span><br><span class="line"><span class="comment">  Sun: 0,</span></span><br><span class="line"><span class="comment">  Mon: 1,</span></span><br><span class="line"><span class="comment">  Tue: 2,</span></span><br><span class="line"><span class="comment">  Wed: 3,</span></span><br><span class="line"><span class="comment">  Thu: 4,</span></span><br><span class="line"><span class="comment">  Fri: 5,</span></span><br><span class="line"><span class="comment">  Sat: 6</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>事实上，上面的例子会被编译为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Days;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Days</span>) </span>&#123;</span><br><span class="line">    Days[Days[<span class="string">"Sun"</span>] = <span class="number">0</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Mon"</span>] = <span class="number">1</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Tue"</span>] = <span class="number">2</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Wed"</span>] = <span class="number">3</span>] = <span class="string">"Wed"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Thu"</span>] = <span class="number">4</span>] = <span class="string">"Thu"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Fri"</span>] = <span class="number">5</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Sat"</span>] = <span class="number">6</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>手动赋值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123;Sun = <span class="number">7</span>, Mon, Tue, Wed, Thu, Fri, Sat&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Days)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  '7': 'Sun',</span></span><br><span class="line"><span class="comment">  '8': 'Mon',</span></span><br><span class="line"><span class="comment">  '9': 'Tue',</span></span><br><span class="line"><span class="comment">  '10': 'Wed',</span></span><br><span class="line"><span class="comment">  '11': 'Thu',</span></span><br><span class="line"><span class="comment">  '12': 'Fri',</span></span><br><span class="line"><span class="comment">  '13': 'Sat',</span></span><br><span class="line"><span class="comment">  Sun: 7,</span></span><br><span class="line"><span class="comment">  Mon: 8,</span></span><br><span class="line"><span class="comment">  Tue: 9,</span></span><br><span class="line"><span class="comment">  Wed: 10,</span></span><br><span class="line"><span class="comment">  Thu: 11,</span></span><br><span class="line"><span class="comment">  Fri: 12,</span></span><br><span class="line"><span class="comment">  Sat: 13</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>自动赋值规则：未指定值的key将会以前一个key的值加1作为默认值，如果前面没有key则从0开始</p>
<h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>
<p>上例的编译结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure>



<h4 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h4><p>外部枚举（Ambient Enums）是使用 <code>declare enum</code> 定义的枚举类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<p>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</p>
<p>上例的编译结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<p>外部枚举与声明语句一样，常出现在声明文件中。</p>
<p>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure>

<p>编译结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure>



<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>TS中的断言可以用于将当前值变成一个其他形状的兼容工具</p>
<p><strong>语法</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">值 <span class="keyword">as</span> 类型 <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br></pre></td></tr></table></figure>



<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>利用declare关键字声明的为全局模块可访问的实例</p>
<ul>
<li><p><code>declare var</code></p>
<p>声明全局变量，类似的还有<code>declare let</code> 和 <code>declare const</code></p>
</li>
<li><p><code>declare function</code></p>
<p>声明全局方法，</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-class" target="_blank" rel="noopener"><code>declare class</code></a> 声明全局类</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-enum" target="_blank" rel="noopener"><code>declare enum</code></a> 声明全局枚举类型</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-namespace" target="_blank" rel="noopener"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#interface-和-type" target="_blank" rel="noopener"><code>interface</code> 和 <code>type</code></a> 声明全局类型</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#export" target="_blank" rel="noopener"><code>export</code></a> 导出变量</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-namespace" target="_blank" rel="noopener"><code>export namespace</code></a> 导出（含有子属性的）对象</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-default" target="_blank" rel="noopener"><code>export default</code></a> ES6 默认导出</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-1" target="_blank" rel="noopener"><code>export =</code></a> commonjs 导出模块</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#export-as-namespace" target="_blank" rel="noopener"><code>export as namespace</code></a> UMD 库声明全局变量</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-global" target="_blank" rel="noopener"><code>declare global</code></a> 扩展全局变量</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#declare-module" target="_blank" rel="noopener"><code>declare module</code></a> 扩展模块</p>
</li>
<li><p><a href="https://ts.xcatliu.com/basics/declaration-files.html#san-xie-xian-zhi-ling" target="_blank" rel="noopener"><code>///</code></a> 三斜线指令</p>
</li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>TS提供了对内置对象的 类型声明定义。内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
<p><strong>ES内置对象</strong></p>
<p>提供了例如<code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code>等内置对象的声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure>



<p><strong>DOM和BOM内置对象</strong></p>
<p>DOM 和 BOM 提供的内置对象有：</p>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
<p>TypeScript 中会经常用到这些类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>修饰在属性和方法上，用于设置该属性和方法的访问权限</p>
<ul>
<li><p><strong>public</strong>： 在任何地方被访问到。</p>
</li>
<li><p><strong>protected</strong>： 只能被类自身和子类访问，应用于构造函数上则意味着<strong>只能被子类继承</strong></p>
</li>
<li><p><strong>private</strong>： 只能被类自身访问，应用于构造函数上则意味着<strong>该类不能被继承</strong></p>
</li>
</ul>
<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> name:<span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="readonly-关键字"><a href="#readonly-关键字" class="headerlink" title="readonly 关键字"></a>readonly 关键字</h4><p>在属性前添加<code>readonly</code>修饰意味着该属性为只读属性，如果修改该属性将会发生报错</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<p>抽象类不能被直接实例化，需要由子类继承实现 ，并且子类必须实现抽象类中的所有抽象方法。这一点几乎与JAVA对抽象类的设计思想一模一样。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> name:<span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> eat():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' was eat!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kitty = <span class="keyword">new</span> Cat(<span class="string">'kitty'</span>)</span><br><span class="line">kitty.eat()</span><br></pre></td></tr></table></figure>



<h4 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h4><p>给类加上 TypeScript 的类型很简单，与接口类似：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure>

<h4 id="流动的类型"><a href="#流动的类型" class="headerlink" title="流动的类型"></a>流动的类型</h4><h5 id="复制类型和值"><a href="#复制类型和值" class="headerlink" title="复制类型和值"></a>复制类型和值</h5><p>如果想要复制一个类，错误的办法是：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Bar = Foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar: Bar; <span class="comment">// Error: 不能找到名称 'Bar'</span></span><br></pre></td></tr></table></figure>

<p>正确的方式是利用import关键字进行引用，这里利用Hack方法演示下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> importing &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Foo &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Bar = importing.Foo;</span><br><span class="line"><span class="keyword">let</span> bar: Bar; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



<h5 id="捕获变量的类型"><a href="#捕获变量的类型" class="headerlink" title="捕获变量的类型"></a>捕获变量的类型</h5><p>在变量类型声明中利用<code>typeof</code>来利用其他变量的类型，这允许你告诉编译器，一个变量的类型与其他类型相同。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> bar: <span class="keyword">typeof</span> foo; <span class="comment">// 捕获了foo的类型。因此bar当前为number类型</span></span><br><span class="line"></span><br><span class="line">bar = <span class="number">345</span>; <span class="comment">// ok</span></span><br><span class="line">bar = <span class="string">"123"</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>



<h5 id="捕获类成员的类型"><a href="#捕获类成员的类型" class="headerlink" title="捕获类成员的类型"></a>捕获类成员的类型</h5><p>和捕获变量类型一致，需要将类注解到一个声明变量上，通过这个声明变量就可以捕获成员类型咯</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo&#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> _foo: Foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar_1: <span class="keyword">typeof</span> _foo.foo = <span class="number">123</span>; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> bar_2: <span class="keyword">typeof</span> _foo.foo = <span class="string">'123'</span>; <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>



<h5 id="捕获键的名称"><a href="#捕获键的名称" class="headerlink" title="捕获键的名称"></a>捕获键的名称</h5><p><code>keyof</code> 操作符能让你捕获一个类型的键。例如，你可以使用它来捕获变量的键名称，在通过使用 <code>typeof</code> 来获取类型之后：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = &#123;</span><br><span class="line">  red: <span class="string">'red'</span>,</span><br><span class="line">  blue: <span class="string">'blue'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Colors = keyof <span class="keyword">typeof</span> colors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> color: Colors; <span class="comment">// color 的类型是 'red' | 'blue'</span></span><br><span class="line">color = <span class="string">'red'</span>; <span class="comment">// ok</span></span><br><span class="line">color = <span class="string">'blue'</span>; <span class="comment">// ok</span></span><br><span class="line">color = <span class="string">'anythingElse'</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这允许你很容易地拥有像字符串枚举+常量这样的类型，如上例所示。</p>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><p>接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。而事实上接口还有另外的用途</p>
<p>在TS中类与接口其实是比较容易混淆的盖点，接口是描述对象的形状，而类是描述对象的实际行为。在TS中，类和接口在一起还可以碰撞出更加灿烂的火光。</p>
<h4 id="类继承接口"><a href="#类继承接口" class="headerlink" title="类继承接口"></a>类继承接口</h4><p>按照Java中的开发思想，一个类只能继承于一个父类。有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<blockquote>
<p> 在TypeScript中，类实现接口需要把接口中所有的方法都实现，否则会发生报错！</p>
</blockquote>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Door &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SecurityDoor <span class="keyword">extends</span> Door <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SecurityDoor alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以实现多个接口：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Light &#123;</span><br><span class="line">    lightOn(): <span class="built_in">void</span>;</span><br><span class="line">    lightOff(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car light on'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOff() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car light off'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p>
<h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>接口与接口之间可以是继承关系：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> LightableAlarm <span class="keyword">extends</span> Alarm &#123;</span><br><span class="line">    lightOn(): <span class="built_in">void</span>;</span><br><span class="line">    lightOff(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这很好理解，<code>LightableAlarm</code> 继承了 <code>Alarm</code>，除了拥有 <code>alert</code> 方法之外，还拥有两个新方法 <code>lightOn</code> 和 <code>lightOff</code>。</p>
<p>​    </p>
<h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>本质上声明一个类时，还会同时声明一个包含其实例属性和实例方法的同名类型，而该类型本质上和接口一致。因此与其说是“接口继承类”，不如说是“接口继承接口”</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">    z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span>&#125;; <span class="comment">//还记得指定“形状”的赋值方法吗</span></span><br></pre></td></tr></table></figure>



<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">'x'</span>); <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure>

<p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p>
<p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来。</p>
<h4 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h4><p>定义泛型的时候，可以一次定义多个类型的参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">tuple: [T, U]</span>): [<span class="title">U</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="number">7</span>, <span class="string">'seven'</span>]); <span class="comment">// ['seven', 7]</span></span><br></pre></td></tr></table></figure>



<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>可以通过<code>extend</code>    关键字对泛型的形状进行约束</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length) <span class="comment">//error: 类型“T”上不存在属性“length”。</span></span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IShape&#123;</span><br><span class="line">  length:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">IShape</span>&gt;(<span class="params">arg: T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length) <span class="comment">//error: 类型“T”上不存在属性“length”。</span></span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125; </span><br><span class="line">logLength(&#123;length: <span class="number">8</span>&#125;) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非规定入参将发生编译错误</span></span><br><span class="line">logLength(<span class="number">88</span>) <span class="comment">//error: 类型“88”的参数不能赋给类型“IShape”的参数</span></span><br></pre></td></tr></table></figure>



<p><strong>多个泛型类型之间也可以进行约束</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFields</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">U</span> , <span class="title">U</span>&gt;(<span class="params">target:T,source: U</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">        target[key] = (source <span class="keyword">as</span> T)[key] </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123;a: <span class="number">1</span>,b:<span class="number">2</span>,c:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">let</span> y = &#123;b:<span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">copyFields(x,y) <span class="comment">// &#123; a: 1, b: 8, c: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>代码中，既然T收到了U的约束，那么T必须是U的超集。其本质上与受到接口的约束效果一致</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>之前接触过，可以使用接口的方式来定义一个函数学要符合的形状</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch:SearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source:<span class="built_in">string</span>, subString:<span class="built_in">string</span></span>):<span class="title">boolean</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在，可以使用泛型来定义接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ICreateArrayFun&#123;</span><br><span class="line">    &lt;T&gt;(length:<span class="built_in">number</span>,value: T):<span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray:ICreateArrayFun = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createArray(<span class="number">3</span>,<span class="literal">true</span>)) <span class="comment">// [true,true,true]</span></span><br></pre></td></tr></table></figure>

<p>当然，泛型类型的定义也可以提到接口外面</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ICreateArrayFun&lt;T&gt;&#123; <span class="comment">//将泛型提到此处</span></span><br><span class="line">    (length:<span class="built_in">number</span>,value: T):<span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在定义时就进行类型指定</span></span><br><span class="line"><span class="keyword">let</span> createArray:ICreateArrayFun&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">createArray(<span class="number">3</span>,<span class="number">123</span>) <span class="comment">// [123,123,123]</span></span><br><span class="line">createArray(<span class="number">3</span>,<span class="literal">true</span>) <span class="comment">// error: 类型“true”的参数不能赋给类型“number”的参数。</span></span><br></pre></td></tr></table></figure>



<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><del>泛型类</del></h4><p><del>与泛型函数类似，泛型也可以用于类的类型定义中</del></p>
<h4 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h4><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。（很少用到）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="泛型配合Axios使用"><a href="#泛型配合Axios使用" class="headerlink" title="泛型配合Axios使用"></a>泛型配合Axios使用</h4><p>通常将把服务端返回的响应体通过interface来进行声明 <code>interface.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求接口数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResponseData&lt;T = any&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 状态码</span></span><br><span class="line"><span class="comment">   * @type &#123; number &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  code: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据</span></span><br><span class="line"><span class="comment">   * @type &#123; T &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  result: T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 消息</span></span><br><span class="line"><span class="comment">   * @type &#123; string &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  message: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将API单独抽离成模块时<code>user.ts</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'./axios'</span>; <span class="comment">// 此处的axios应当是已经处理后（添加通用配置，拦截器等）的axios实例对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; ResponseData &#125; <span class="keyword">from</span> <span class="string">'./interface.ts'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IRequestParams &#125; <span class="keyword">from</span>  <span class="string">'@/types/global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchUserAccount</span>&lt;<span class="title">T</span>&gt;(<span class="params">params?: IRequestParams</span>) </span>&#123;</span><br><span class="line">	axios.post&lt;ResponseData&lt;T&gt;&gt;(<span class="string">'/user/account'</span>, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchUserAccount &#125; <span class="keyword">from</span> <span class="string">'./user'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IUser &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUserAccount&lt;IUser&gt;();</span><br><span class="line">	<span class="comment">// user 被推断出为</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//  code: number,</span></span><br><span class="line">  <span class="comment">//  result: &#123; name: string, age: number &#125;,</span></span><br><span class="line">  <span class="comment">//  message: string</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>和函数重载一样，接口和类也可以重复声明，TS编译阶段会将他们合并到一块</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">  name:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">  age:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个要合并的接口或者类之间可以有重复的属性，但是属性的类型必须是一致的。否则会发生报错</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    age:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    age:<span class="built_in">number</span> <span class="comment">// error: 后续属性声明必须属于同一类型。属性“age”的类型必须为“string”，但此处却为类型“number”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而方法合并和函数重载规则一致</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>, n: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    alert(s: <span class="built_in">string</span>, n: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TypeScript项目"><a href="#TypeScript项目" class="headerlink" title="TypeScript项目"></a>TypeScript项目</h3><h4 id="编译上下文"><a href="#编译上下文" class="headerlink" title="编译上下文"></a>编译上下文</h4><p>所谓编译上下文指的是TS编译的范围，通过配置文件可以对当前编译上下文中的TS文件提供编译选项，而这个配置文件事实上指的就是<code>tsconfig.json</code></p>
<h5 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h5><p>开始使用 <code>tsconfig.json</code> 是一件比较容易的事，你仅仅需要写下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例如，在项目的根目录下创建一个空 JSON 文件。通过这种方式，TypeScript 将 会把此目录和子目录下的所有 .ts 文件作为编译上下文的一部分，它还会包含一部分默认的编译选项。</p>
<p><strong>编译选项</strong></p>
<p>可以通过<code>compilerOptions</code>来定制当前编译上下文的编译选项</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'</span></span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                  <span class="comment">// 指定使用模块:  'None', 'CommonJS', 'AMD', 'System', 'UMD', 'ES6', 'ES2015', 'ES2020' or 'ESNext'.</span></span><br><span class="line">    <span class="attr">"lib"</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="attr">"checkJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="attr">"jsx"</span>: <span class="string">"preserve"</span>,                     <span class="comment">// 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 '.d.ts' 文件</span></span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 '.map' 文件</span></span><br><span class="line">    <span class="attr">"outFile"</span>: <span class="string">"./"</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./"</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="attr">"removeComments"</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="attr">"noEmit"</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="attr">"importHelpers"</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="attr">"isolatedModules"</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件作为单独的模块 （与 'ts.transpileModule' 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="attr">"noImplicitThis"</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="attr">"alwaysStrict"</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="attr">"noUnusedLocals"</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="attr">"noUnusedParameters"</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="attr">"noImplicitReturns"</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="attr">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,            <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="attr">"paths"</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="attr">"rootDirs"</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="attr">"typeRoots"</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="attr">"types"</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="attr">"sourceRoot"</span>: <span class="string">"./"</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="attr">"mapRoot"</span>: <span class="string">"./"</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="attr">"inlineSourceMap"</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="attr">"inlineSources"</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="attr">"emitDecoratorMetadata"</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当配置完毕时，VScode将会提供对TS的即时编译，但是如果想从命令行运行TS编译器，可以通过以下方式：</p>
<ul>
<li>直接运行 <code>tsc</code>, 它会从当前目录或者父级目录寻找<code>tsconfig.json</code></li>
<li>运行<code>tsc -p ./path-to-project-directory</code> ，它会从指定路径进行编译</li>
</ul>
<p>你也可以显式指定需要编译的文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="string">"./some/file.ts"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>include</code> 和 <code>exclude</code> 选项来指定需要包含的文件和排除的文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"include"</span>: [</span><br><span class="line">    <span class="string">"./folder"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">    <span class="string">"./folder/**/*.spec.ts"</span>,</span><br><span class="line">    <span class="string">"./folder/someSubFolder"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> </p>
<p>使用 <code>globs</code>：<code>**/*</code> （一个示例用法：<code>some/folder/**/*</code>）意味着匹配所有的文件夹和所有文件（扩展名为 <code>.ts/.tsx</code>，当开启了 <code>allowJs: true</code> 选项时，扩展名可以是 <code>.js/.jsx</code>）。</p>
</blockquote>
<h4 id="声明空间"><a href="#声明空间" class="headerlink" title="声明空间"></a>声明空间</h4><ul>
<li><p>声明空间指的是TS在编译阶段会将类型和变量添加到编译声明空间中</p>
</li>
<li><p>声明空间可以分为变量声明空间和类型声明空间</p>
<ul>
<li><p>类型声明空间</p>
<p>通过<code>interface</code>定义的接口都会被ts编译器添加到类型声明空间</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Person&#123; <span class="comment">//将会提升到类型声明空间</span></span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量声明空间</p>
<p>类、变量、函数都会被ts编译器添加到变量声明空间中</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123; <span class="comment">//提升到变量声明空间 &amp;&amp; 但是在声明类时如果类型声明空间中没有该类型，则会自动创建一个同名类型，其内容为类型中已声明的属性。</span></span><br><span class="line">              <span class="comment">//如果类型声明空间中已存在该类型，则利用声明合并规则进行合并</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>全局声明空间的范围是当前编译上下文</p>
</li>
<li><p>默认声明的将会成为全局的声明空间，加入export后成为局部模块声明空间</p>
<p>`</p>
</li>
</ul>
<h4 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h4><ul>
<li><strong>Typescript <code>模块解析</code>就是指导 ts <code>编译器</code>查找导入（import）内容的<code>流程</code></strong></li>
<li>TS模块解析供有两种策略：<ul>
<li><code>Classic</code>: 以前是TypeScript 默认的解析策略，目前仅用作向后兼容</li>
<li><code>Node</code>: 与 NodeJS 模块机制一致的解析策略</li>
</ul>
</li>
</ul>
<h5 id="Node模块解析策略"><a href="#Node模块解析策略" class="headerlink" title="Node模块解析策略"></a>Node模块解析策略</h5><p>当导入路径不是相对路径时，模块解析将会模仿 <a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener">Node 模块解析策略</a>，下面我将给出一个简单例子：</p>
<ul>
<li><p>当你使用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure>

<p>，将会按如下顺序查找模块：ts</p>
<ul>
<li><code>./node_modules/foo</code></li>
</ul>
</li>
<li><p><code>../node_modules/foo</code></p>
<ul>
<li><code>../../node_modules/foo</code></li>
<li>直到系统的根目录</li>
</ul>
</li>
<li><p>当你使用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">'something/foo'</span></span><br></pre></td></tr></table></figure>

<p>，将会按照如下顺序查找内容</p>
<ul>
<li><code>./node_modules/something/foo</code></li>
</ul>
</li>
<li><p><code>../node_modules/something/foo</code></p>
<ul>
<li><code>../../node_modules/something/foo</code></li>
<li>直到系统的根目录</li>
</ul>
</li>
<li><p>当你使用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xx <span class="keyword">from</span> <span class="string">'./foo'</span></span><br></pre></td></tr></table></figure>

<p>将会按照如下顺序查找内容</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210106105126793.png" alt="image-20210106105126793"  />

<p>优先查找<code>.ts</code>后缀 如无则查找 <code>.d.ts</code>同名文件</p>
<h5 id="Classic解析策略"><a href="#Classic解析策略" class="headerlink" title="Classic解析策略"></a>Classic解析策略</h5><ul>
<li><p>当你使用文件路径</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xx <span class="keyword">from</span> <span class="string">'./foo'</span></span><br></pre></td></tr></table></figure>

<p>将会按照如下顺序查找内容</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210106110526489.png" alt="image-20210106110526489"></p>
</li>
<li><p>当你使用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xx <span class="keyword">from</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure>

<p>将会按照如下顺序查找内容</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/image-20210106111747235.png" alt="image-20210106111747235"></p>
</li>
</ul>
<h5 id="重写文件查找策略"><a href="#重写文件查找策略" class="headerlink" title="重写文件查找策略"></a>重写文件查找策略</h5><p>在TypeScript中，可以通过声明全局模块的方法，来绕过文件查找策略</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global.d.ts</span></span><br><span class="line"><span class="comment">// 在当前编译上下文作用域内 声明全局模块</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'foo' &#123;</span><br><span class="line">    <span class="comment">// some variable declarations</span></span><br><span class="line">      <span class="keyword">export</span> <span class="keyword">var</span> bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="comment">// TypeScript 将假设（在没有做其他查找的情况下）</span></span><br><span class="line"><span class="comment">// foo 是 &#123; bar: number &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态导入表达式"><a href="#动态导入表达式" class="headerlink" title="动态导入表达式"></a>动态导入表达式</h4><p>动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块，TC39 JavaScript 委员会有一个提案，目前处于第四阶段，它被称为 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">import() proposal for JavaScript</a>。</p>
<p>此外，<strong>webpack</strong> bundler 有一个 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener"><code>Code Splitting</code></a> 功能，它能允许你将代码拆分为许多块，这些块在将来可被异步下载。因此，你可以在程序中首先提供一个最小的程序启动包，并在将来异步加载其他模块。</p>
<p>这很自然就会让人想到（如果我们工作在 webpack dev 的工作流程中）<a href="https://github.com/Microsoft/TypeScript/wiki/What' target="_blank" rel="noopener"s-new-in-TypeScript#dynamic-import-expressions">TypeScript 2.4 dynamic import expressions</a> 将会把你最终生成的 JavaScript 代码自动分割成很多块。但是这似乎并不容易实现，因为它依赖于我们正在使用的 <code>tsconfig.json</code> 配置文件。</p>
<p>webpack 实现代码分割的方式有两种：使用 <code>import()</code> （首选，ECMAScript 的提案）和 <code>require.ensure()</code> （最后考虑，webpack 具体实现）。因此，我们期望 TypeScript 的输出是保留 <code>import()</code> 语句，而不是将其转化为其他任何代码。</p>
<p>让我们来看一个例子，在这个例子中，我们演示了如何配置 webpack 和 TypeScript 2.4 +。</p>
<p>在下面的代码中，我希望懒加载 <code>moment</code> 库，同时我也希望使用代码分割的功能，这意味 <code>moment</code> 会被分割到一个单独的 JavaScript 文件，当它被使用时，会被异步加载。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "momentjs" */</span> <span class="string">'moment'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">moment</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 懒加载的模块拥有所有的类型，并且能够按期工作</span></span><br><span class="line">    <span class="comment">// 类型检查会工作，代码引用也会工作  :100:</span></span><br><span class="line">    <span class="keyword">const</span> time = moment().format();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'TypeScript &gt;= 2.4.0 Dynamic Import Expression:'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(time);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Failed to load moment'</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这是 <code>tsconfig.json</code> 的配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"esnext"</span>,</span><br><span class="line">    <span class="string">"lib"</span>: [</span><br><span class="line">      <span class="string">"dom"</span>,</span><br><span class="line">      <span class="string">"es5"</span>,</span><br><span class="line">      <span class="string">"scripthost"</span>,</span><br><span class="line">      <span class="string">"es2015.promise"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./dist/js"</span>,</span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="string">"typeRoots"</span>: [</span><br><span class="line">      <span class="string">"./node_modules/@types"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"types"</span>: [</span><br><span class="line">      <span class="string">"node"</span>,</span><br><span class="line">      <span class="string">"react"</span>,</span><br><span class="line">      <span class="string">"react-dom"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要的提示</p>
<ul>
<li>使用 <code>&quot;module&quot;: &quot;esnext&quot;</code> 选项：TypeScript 保留 <code>import()</code> 语句，该语句用于 Webpack Code Splitting。</li>
<li>进一步了解有关信息，推荐阅读这篇文章：<a href="https://blog.josequinto.com/2017/06/29/dynamic-import-expressions-and-webpack-code-splitting-integration-with-typescript-2-4/" target="_blank" rel="noopener">Dynamic Import Expressions and webpack 2 Code Splitting integration with TypeScript 2.4.</a></li>
</ul>
</blockquote>
<h4 id="从JavaScript迁移"><a href="#从JavaScript迁移" class="headerlink" title="从JavaScript迁移"></a>从JavaScript迁移</h4><p>一般来说，将 JavaScript 代码迁移至 TypeScript 包括以下步骤：</p>
<ul>
<li>添加一个 <code>tsconfig.json</code> 文件；</li>
<li>把文件扩展名从 <code>.js</code> 改成 <code>.ts</code>，开始使用 <code>any</code> 来减少错误；</li>
<li>开始在 TypeScript 中写代码，尽可能的减少 <code>any</code> 的使用；</li>
<li>回到旧代码，开始添加类型注解，并修复已识别的错误；</li>
<li>为第三方 JavaScript 代码定义环境声明(*.d.ts)。</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">[TypeScript 入门教程]</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">[深入理解 TypeScript]</a></li>
<li><a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">[TypeScript官方教程]</a></li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Promise</title>
    <url>/2020/09/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Promise/</url>
    <content><![CDATA[<blockquote>
<p>ES6提供的Promise对象是异步控制相较于回调的更好的一种方法。包括ES8提供的asyncFunction本质上也是基于Promise和生成器的结合，因此在已经了解Promise对象的常用API基础上，更加深入的去了解如何使用Promise去解决一些常见的难题对于开发将会有一些帮助。</p>
</blockquote>
<a id="more"></a>

<p><strong>文章阅读前，希望读者已经对Promise的使用及相关api有了一定的了解 。[ <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">快速学习Promise</a> ]</strong></p>
<h2 id="一、如何对Promise异步任务进行超时监听"><a href="#一、如何对Promise异步任务进行超时监听" class="headerlink" title="一、如何对Promise异步任务进行超时监听"></a>一、如何对Promise异步任务进行超时监听</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>作为一道开胃小菜，这个问题还是不难解决的。平时对于一些异步任务很有可能需要进行超时监听，那么如何利用<code>Promise</code>来进行超时监听/监控呢？</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个严格任务函数，第一个参数为promise对象，第二个参数为判定的超时标准，默认3s</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strictTack</span>(<span class="params">promise,delay = <span class="number">3</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数返回一个超时基准promise对象</span></span><br><span class="line">  <span class="keyword">let</span> promiseTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        rej(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"运行超时！"</span>))</span><br><span class="line">      &#125;,<span class="number">1000</span> * delay)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// race，参数数组内的promise并发执行，一旦其中有一个promise对象产生判决就会终止其余的promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise,promiseTimeout(delay)])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步任务p1</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    res(<span class="string">"p1 was resoved"</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span> * <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务p2</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    res(<span class="string">"p2 was resoved"</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span> * <span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">strictTack(p1)</span><br><span class="line">.then(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)<span class="comment">// p1 was resoved</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">strictTack(p2)</span><br><span class="line">.then(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">// Error:运行超时！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="任务总结"><a href="#任务总结" class="headerlink" title="任务总结"></a>任务总结</h3><p>对于这个问题来说，核心部分就是利用好<code>Promise.race</code>这个API，因为使用它所执行的的<code>Promise</code>对象中的异步任务都是“竞态”的，只接受第一个发生判决的Promise对象。那么此时采用超时基准<code>promise</code>对象配合<code>race</code>正好巧妙的解决了超时监听的问题。</p>
<h2 id="二、如何自己实现一个Promise"><a href="#二、如何自己实现一个Promise" class="headerlink" title="二、如何自己实现一个Promise"></a>二、如何自己实现一个Promise</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>这种具有一定难bian度tai的题目一般会在面试中遇到，那么如何手动实现一个Promise（或部分功能）？</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p><code>V 0.1</code>初步版本的Promise (不支持正规Promise的链式调用)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromisePolyfill</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(exector = ()=&gt;&#123;&#125;)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span> <span class="comment">// promise当前状态</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span> <span class="comment">// 用户回显到reject函数的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span> <span class="comment">// 用户回显到resolve函数的值</span></span><br><span class="line">    <span class="comment">// 成功事件回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallBacks = []</span><br><span class="line">    <span class="comment">// 失败事件回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallBacks = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现resolve函数</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallBacks.map(<span class="function"><span class="params">e</span>=&gt;</span>e())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现reject函数</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallBacks.map(<span class="function"><span class="params">e</span>=&gt;</span>e())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 运行执行器</span></span><br><span class="line">      exector(resolve,reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled,onRejected)&#123;</span><br><span class="line">    <span class="comment">// 同步情况</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span> &amp;&amp; onFulfilled)&#123;</span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'rejected'</span> &amp;&amp; onRejected)&#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步情况</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// 将任务成功回调加入到成功队列中</span></span><br><span class="line">      onFulfilled &amp;&amp; <span class="keyword">this</span>.onFulfilledCallBacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">      &#125;)</span><br><span class="line">       <span class="comment">// 将任务失败回调加入到失败队列中</span></span><br><span class="line">      onRejected &amp;&amp; <span class="keyword">this</span>.onRejectedCallBacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">catch</span>(onRejected)&#123;</span><br><span class="line">        <span class="comment">// 将任务失败回调加入到失败队列中</span></span><br><span class="line">    onRejected &amp;&amp; <span class="keyword">this</span>.onRejectedCallBacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>V 0.2</code>支持链式调用，但是未实现Promise的相关<code>API</code> – <code>all、race、reject、resolve</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromisePolyfill</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(exector = ()=&gt;&#123;&#125;)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span> <span class="comment">// promise当前状态</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span> <span class="comment">// 用户回显到reject函数的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span> <span class="comment">// 用户回显到resolve函数的值</span></span><br><span class="line">    <span class="comment">// 成功事件回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallBacks = []</span><br><span class="line">    <span class="comment">// 失败事件回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallBacks = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现resolve函数</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallBacks.map(<span class="function"><span class="params">e</span>=&gt;</span>e())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现reject函数</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallBacks.map(<span class="function"><span class="params">e</span>=&gt;</span>e())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 运行执行器</span></span><br><span class="line">      exector(resolve,reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled,onRejected)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> PromisePolyfill(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span> &amp;&amp; onFulfilled)&#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">        <span class="comment">// resolvePromise函数，处理自己return的promise和默认的promise2的关系</span></span><br><span class="line">        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'rejected'</span> &amp;&amp; onRejected)&#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 异步情况</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="comment">// 将任务成功回调加入到成功队列中</span></span><br><span class="line">        onFulfilled &amp;&amp; <span class="keyword">this</span>.onFulfilledCallBacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">          <span class="comment">// resolvePromise函数，处理自己return的promise和默认的promise2的关系</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">         <span class="comment">// 将任务失败回调加入到失败队列中</span></span><br><span class="line">        onRejected &amp;&amp; <span class="keyword">this</span>.onRejectedCallBacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 循环引用报错</span></span><br><span class="line">  <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">    <span class="comment">// reject报错</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止多次调用</span></span><br><span class="line">  <span class="keyword">let</span> called;</span><br><span class="line">  <span class="comment">// x不是null 且x是对象或者函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise了</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123; </span><br><span class="line">        <span class="comment">// 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调</span></span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// resolve的结果依旧是promise 那就继续解析</span></span><br><span class="line">          resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(err);<span class="comment">// 失败了就失败了</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x); <span class="comment">// 直接成功即可</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 也属于失败</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 取then出错了那就不要在继续执行了</span></span><br><span class="line">      reject(e); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>v0.2</code>基础上封装相关API</p>
<ul>
<li><code>all(iterable)</code> 这个方法接受一个promise数组，返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PromisePolyfill.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">processData</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Arr = []</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">index,data,resolve</span>)</span>&#123;</span><br><span class="line">      Arr[index] = data</span><br><span class="line">      i++</span><br><span class="line">      <span class="keyword">if</span>(i === promises.length)&#123;</span><br><span class="line">        resolve(Arr)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> process = processData()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromisePolyfill(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    promises.map(<span class="function">(<span class="params">promise,index</span>) =&gt;</span> &#123;</span><br><span class="line">      promise.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        process(index,data,resolve)</span><br><span class="line">      &#125;,reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>race(iterable)</code> 这个方法接受一个promise数组。当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PromisePolyfill.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromisePolyfill(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    promises.map(<span class="function"><span class="params">promise</span>=&gt;</span>&#123;</span><br><span class="line">      promise.then(resolve,reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>resolve(value)</code> 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PromisePolyfill.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromisePolyfill(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>reject(value)</code> 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PromisePolyfill.reject = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromisePolyfill(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  	reject(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="三、手写一个Promise的Ajax函数"><a href="#三、手写一个Promise的Ajax函数" class="headerlink" title="三、手写一个Promise的Ajax函数"></a>三、手写一个Promise的Ajax函数</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>老生常谈的问题了，面试官喜欢问的问题。主要思想实现出来就好了</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequset()</span><br><span class="line">        <span class="comment">//设置请求方式和请求地址</span></span><br><span class="line">    	request.open(params.type || <span class="string">'get'</span>,params.url)</span><br><span class="line">    	</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//当请求返回响应时</span></span><br><span class="line">            <span class="keyword">if</span>(request.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="comment">// 默认情况下返回200意味着请求成功</span></span><br><span class="line">                <span class="keyword">if</span>(request.status === <span class="number">200</span>)&#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(request.responseText))</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(<span class="built_in">JSON</span>.parse(request.responseText))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//携带请求头发送请求</span></span><br><span class="line">        request.send(params.data || <span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、理论部分"><a href="#四、理论部分" class="headerlink" title="四、理论部分"></a>四、理论部分</h2><h3 id="关于then和catch的返回值"><a href="#关于then和catch的返回值" class="headerlink" title="关于then和catch的返回值"></a>关于then和catch的返回值</h3><p>如果自己去实现了一次<code>Promise</code>对象之后会发现，<code>then</code>和<code>catch</code>如果没有返回一个标准的promise对象时，将会默认返回一个<code>Promise.resolve(基本值)</code>，即使你没有写任何<code>return</code>语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// rej("p1 was rejected")</span></span><br><span class="line">    res(<span class="string">"p1 was resoved"</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span> * <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Then1:"</span>+res)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Then2:"</span>+res)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Error1:"</span>+err)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">"Error For Catch 1"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Then3:"</span>+res)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'ERROR For Then 3'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Then4:"</span>+res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Error2:"</span>+err)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Then5:"</span>+res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">Then1:p1 was rejected</span></span><br><span class="line"><span class="comment">Then2:undefined</span></span><br><span class="line"><span class="comment">Then3:Hello</span></span><br><span class="line"><span class="comment">Error2:ERROR For Then 3</span></span><br><span class="line"><span class="comment">Then5:undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>经过分析不难发现，对于一个<code>Promise</code>中的链式调用的顺序是这样的：</p>
<ol>
<li>对于一个<code>then/catch</code>，默认返回为一个<code>resolve</code></li>
<li>当返回一个<code>reject</code>时，将调用当前节点往后的最近的<code>catch</code>节点中的回调（跳过中间的<code>then</code>）</li>
<li>如果当前节点并没有返回<code>reject</code> 但是恰巧后面的节点就是是<code>catch</code>，那么将会跳过这个（或连续几个）<code>catch</code>，直接到后面最近的<code>then</code>节点</li>
</ol>
<p><strong>以上为现象，原理请参考第二节<code>Promise</code>的实现</strong></p>
<h3 id="关于async-Function-async-await"><a href="#关于async-Function-async-await" class="headerlink" title="关于async Function (async/await)"></a>关于async Function (<em>async/await</em>)</h3><p><code>asyncFunction</code>是ES8中提出的更好的异步解决方案，实际用起来也确实如此。那么<code>asyncFunction</code>与<code>Promise</code>之间存在什么样的关系呢？</p>
<p> [ <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">快速学习async Function</a></strong> ]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Fetch is RUNING"</span>) <span class="comment">// 立即输出Fetch is RUNING</span></span><br><span class="line">  <span class="keyword">let</span>  data1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      res(<span class="number">1</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span> * <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(data1) <span class="comment">//时间线至少2s后打印1</span></span><br><span class="line">  <span class="keyword">let</span>  data2 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      res(<span class="number">2</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span> * <span class="number">5</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// 时间线至少2+5=7s后打印2</span></span><br><span class="line">  <span class="built_in">console</span>.log(data1+data2) <span class="comment">// 紧接着上一句执行，打印 3</span></span><br><span class="line">&#125;</span><br><span class="line">fetch()</span><br></pre></td></tr></table></figure>

<p>上例中展示了<em>async/await</em>的基本用法和执行过程</p>
<ol>
<li>第一句同步打印任务可以直接输出。</li>
<li>第二句遇到<code>await</code>,将会等待当前<em>await<em>任务返回</em>Promise.resolve<em>后才会继续执行下一句。这种模式和生成器的模式非常相像，</em>async/await<em>优于生成器的地方就是，生成器需要手动</em>next<em>才能进行下一步，而</em>async/await<em>是自动</em>next</em>,显然实现上要更为复杂。</li>
<li>依次类推…</li>
</ol>
<blockquote>
<p>从这个例子中可以看出，多个<em>await</em>产生的异步任务是逐个执行的，而不是并发。所以想要实现多异步任务并发控制，仍然需要使用<code>Promise.all或者Promise.race</code>。</p>
</blockquote>
<p>接下来，再来看个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span>  data1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      res(<span class="number">1</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span> * <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span>  data2 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      res(<span class="number">2</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span> * <span class="number">5</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> data1 + data2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 至少7s后输出 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你没看错，<em>asyncFunction</em>将会默认返回一个<em>Promise</em>对象，和<em>Promise.prototype.then</em>返回<em>Promise</em>的效果一致</p>
<p>到这儿不难看出<em>Promise</em>的重要性了吧，现在的主要异步任务控制方式实际上都没有离开<em>Promise</em>。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在Vue中使用Echarts</title>
    <url>/2020/05/04/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8Echarts/</url>
    <content><![CDATA[<h2 id="在Vue中使用Echarts"><a href="#在Vue中使用Echarts" class="headerlink" title="在Vue中使用Echarts"></a>在Vue中使用Echarts</h2><blockquote>
<p>实际的Vue项目开发中可能需要用到<code>Echarts</code>来制作图表。本文将分享在VueCli3中使用Echarts的小经验。</p>
</blockquote>
<a id="more"></a>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>将<code>echarts</code>与<code>vue-echarts</code> ( <code>vue-echarts</code>是基于<code>echarts</code>封装实现的一个组件库)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i echarts vue<span class="literal">-echarts</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>



<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>在<code>main.js</code>中导入包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ECharts <span class="keyword">from</span> <span class="string">'vue-echarts'</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span></span><br><span class="line">Vue.component(<span class="string">'chart'</span>, ECharts)</span><br><span class="line">Vue.prototype.$echarts = echarts</span><br></pre></td></tr></table></figure>

<p>引入一些echarts中比较常用的模块,其他主要模块到使用的组件内按需引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"echarts/lib/chart/bar"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"echarts/lib/component/tooltip"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"echarts/lib/component/legend"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"echarts/lib/component/title"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用相关"><a href="#使用相关" class="headerlink" title="使用相关"></a>使用相关</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>使用注册的全局组件<code>chart</code>即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;chart  :options&#x3D;&quot;options&quot; :auto-resize&#x3D;&quot;true&quot;&gt;&lt;&#x2F;chart&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;line&#39; &#x2F;&#x2F;加入折现表</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                options:&#123;&#125; &#x2F;&#x2F;设置echarts中的参数options</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="更为优雅的使用"><a href="#更为优雅的使用" class="headerlink" title="更为优雅的使用"></a>更为优雅的使用</h4><p>由于实际开发时可能遇到不同的数据格式。我比较推荐将图表封装为一个与项目中实际数据结构相同的组件。</p>
<p><code>options</code>的数据结构可以参考官网 <a href="https://www.echartsjs.com/zh/option.html#title" target="_blank" rel="noopener">https://www.echartsjs.com/zh/option.html#title</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;chart  :options&#x3D;&quot;options&quot; :auto-resize&#x3D;&quot;true&quot;&gt;&lt;&#x2F;chart&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;line&#39;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props:&#123;</span><br><span class="line">            title:String, &#x2F;&#x2F;图表标题</span><br><span class="line">            Cats:Array, &#x2F;&#x2F;对象数组&#123;name:String,data:[]&#125;</span><br><span class="line">            xData:Array &#x2F;&#x2F;x轴的标记</span><br><span class="line">        &#125;,</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                options:&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            this.options &#x3D;  &#123;</span><br><span class="line">                title: &#123;</span><br><span class="line">                    left:&#39;center&#39;,</span><br><span class="line">                    top:&quot;0&quot;,</span><br><span class="line">                    text: this.title</span><br><span class="line">                &#125;,</span><br><span class="line">                tooltip: &#123;</span><br><span class="line">                    trigger: &#39;axis&#39;</span><br><span class="line">                &#125;,</span><br><span class="line">                legend: &#123;</span><br><span class="line">                    top:&quot;40&quot;,</span><br><span class="line">                    data: this.Cats.map(e&#x3D;&gt;e.name)</span><br><span class="line">                &#125;,</span><br><span class="line">                grid: &#123;</span><br><span class="line">                    left: &#39;3%&#39;,</span><br><span class="line">                    right: &#39;4%&#39;,</span><br><span class="line">                    top: &#39;20%&#39;,</span><br><span class="line">                    containLabel: true</span><br><span class="line">                &#125;,</span><br><span class="line">                toolbox: &#123;</span><br><span class="line">                    feature: &#123;</span><br><span class="line">                        saveAsImage: &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                xAxis: &#123;</span><br><span class="line">                    type: &#39;category&#39;,</span><br><span class="line">                    boundaryGap: false,</span><br><span class="line">                    data: this.xData</span><br><span class="line">                &#125;,</span><br><span class="line">                yAxis: &#123;</span><br><span class="line">                    type: &#39;value&#39;</span><br><span class="line">                &#125;,</span><br><span class="line">                series: this.Cats.map(e &#x3D;&gt; &#123;e.type &#x3D; &quot;line&quot;;return e&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>图表中的数据是由<strong>后端</strong>获取的，那么当图表绘制完成后，由于图表<strong>options</strong>中有些数据比较深，更新时可能会发生数据<strong>监听不到</strong>的问题。</p>
<p>我的解决办法是在在组件中加入一个<strong>vue侦听</strong>，侦听要发生变化的变量，例如上例中我加入了<strong>watch</strong>来侦听会发生变化的属性<code>Cats</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    Cats(newValue)&#123;</span><br><span class="line">        this.$set(this.options,&#39;series&#39;,newValue.map(e &#x3D;&gt; &#123;e.type &#x3D; &quot;line&quot;;return e&#125;))</span><br><span class="line">        this.$set(this.options.legend,&#39;data&#39;,newValue.map(e&#x3D;&gt;e.name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完整代码与效果"><a href="#完整代码与效果" class="headerlink" title="完整代码与效果"></a>完整代码与效果</h3><h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><p><strong>数据结构内容说明</strong></p>
<img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200504211539.png" style="zoom:67%;" />

<p><strong>组件代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;chart  :options&#x3D;&quot;options&quot; :auto-resize&#x3D;&quot;true&quot;&gt;&lt;&#x2F;chart&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;line&#39;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props:&#123;</span><br><span class="line">            title:String,</span><br><span class="line">            Cats:Array,</span><br><span class="line">            xData:Array</span><br><span class="line">        &#125;,</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                options:&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            this.options &#x3D;  &#123;</span><br><span class="line">                title: &#123;</span><br><span class="line">                    left:&#39;center&#39;,</span><br><span class="line">                    top:&quot;0&quot;,</span><br><span class="line">                    text: this.title</span><br><span class="line">                &#125;,</span><br><span class="line">                tooltip: &#123;</span><br><span class="line">                    trigger: &#39;axis&#39;</span><br><span class="line">                &#125;,</span><br><span class="line">                legend: &#123;</span><br><span class="line">                    top:&quot;40&quot;,</span><br><span class="line">                    data: this.Cats.map(e&#x3D;&gt;e.name)</span><br><span class="line">                &#125;,</span><br><span class="line">                grid: &#123;</span><br><span class="line">                    left: &#39;3%&#39;,</span><br><span class="line">                    right: &#39;4%&#39;,</span><br><span class="line">                    top: &#39;20%&#39;,</span><br><span class="line">                    containLabel: true</span><br><span class="line">                &#125;,</span><br><span class="line">                toolbox: &#123;</span><br><span class="line">                    feature: &#123;</span><br><span class="line">                        saveAsImage: &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                xAxis: &#123;</span><br><span class="line">                    type: &#39;category&#39;,</span><br><span class="line">                    boundaryGap: false,</span><br><span class="line">                    data: this.xData</span><br><span class="line">                &#125;,</span><br><span class="line">                yAxis: &#123;</span><br><span class="line">                    type: &#39;value&#39;</span><br><span class="line">                &#125;,</span><br><span class="line">                series: this.Cats.map(e &#x3D;&gt; &#123;e.type &#x3D; &quot;line&quot;;return e&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">            Cats(newValue)&#123;</span><br><span class="line">                this.$set(this.options,&#39;series&#39;,newValue.map(e &#x3D;&gt; &#123;e.type &#x3D; &quot;line&quot;;return e&#125;))</span><br><span class="line">                this.$set(this.options.legend,&#39;data&#39;,newValue.map(e&#x3D;&gt;e.name))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong></p>
<img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200504210539.png" style="zoom:67%;" />



<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p><strong>数据结构内容说明</strong></p>
<img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200504211847.png" style="zoom:67%;" />

<p><strong>组件代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;chart ref&#x3D;&quot;charts&quot; :options&#x3D;&quot;options&quot; :auto-resize&#x3D;&quot;true&quot;&gt;&lt;&#x2F;chart&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#39;echarts&#x2F;lib&#x2F;chart&#x2F;pie&#39;</span><br><span class="line">    import &quot;echarts&#x2F;lib&#x2F;component&#x2F;legendScroll&quot;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props:&#123;</span><br><span class="line">            title:String,</span><br><span class="line">            Cats:Array</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            CatsName()&#123;</span><br><span class="line">                return this.Cats.map(e&#x3D;&gt;e.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                options:&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            this.options&#x3D;&#123;</span><br><span class="line">                tooltip: &#123;</span><br><span class="line">                    trigger: &#39;item&#39;,</span><br><span class="line">                    formatter: &#39;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&#39;</span><br><span class="line">                &#125;,</span><br><span class="line">                legend: &#123;</span><br><span class="line">                    type:&#39;scroll&#39;,</span><br><span class="line">                    orient: &#39;vertical&#39;,</span><br><span class="line">                    left: 2,</span><br><span class="line">                    top: 20,</span><br><span class="line">                    height:140,</span><br><span class="line">                &#125;,</span><br><span class="line">                 title: [&#123;</span><br><span class="line">                   left: &#39;center&#39;,</span><br><span class="line">                   text: this.title</span><br><span class="line">                &#125;],</span><br><span class="line">                series: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: &#39;访问量&#39;,</span><br><span class="line">                        type: &#39;pie&#39;,</span><br><span class="line">                        radius: &#39;63%&#39;,</span><br><span class="line">                        left:150,</span><br><span class="line">                        avoidLabelOverlap: false,</span><br><span class="line">                        label: &#123;</span><br><span class="line">                            normal: &#123;</span><br><span class="line">                                show: true,</span><br><span class="line">                                position: &#39;top&#39;</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        labelLine: &#123;</span><br><span class="line">                            normal: &#123;</span><br><span class="line">                                show: true</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">            Cats(newValue)&#123;</span><br><span class="line">                this.$set(this.options.series[0],&#39;data&#39;,newValue)</span><br><span class="line">                this.$set(this.options.legend,&#39;data&#39;,this.CatsName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong></p>
<img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200504211340.png" style="zoom:67%;" />]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js通过cron模块实现定时执行脚本</title>
    <url>/2020/05/04/Node-js%E9%80%9A%E8%BF%87cron%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="Node-js通过cron模块实现定时执行脚本"><a href="#Node-js通过cron模块实现定时执行脚本" class="headerlink" title="Node.js通过cron模块实现定时执行脚本"></a>Node.js通过cron模块实现定时执行脚本</h2><blockquote>
<p>实际开发中，可能会由定时执行某段代码的需求。下面分享如何使用cron在Node.js中如何实现该需求</p>
</blockquote>
<a id="more"></a>



<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当前项目遇到了一个需求，每天的<strong>0时0分0秒</strong>统计前一天的网站访问量，并将该数据保存到一张表中。暂时不考虑数据库操作部分，只考虑如何实现<strong>定时执行某段脚本</strong>。</p>
<p>由于使用Node.js开发，一拍脑袋刚开始想到的是使用<code>setInterval</code>：每秒执行一次，判断当前时间是否为<strong>0时0分0秒</strong>，如果是则执行脚本。但是后来考虑到这样做实在是太不美观了，所以使用了一款第三方包<code>cron</code>。</p>
<p><strong><code>cron</code></strong>就是一款可让您按计划执行<strong>某些任务</strong>的工具。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>安装</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install cron -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>引入 cron</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CronJob = <span class="built_in">require</span>(<span class="string">'cron'</span>).CronJob</span><br></pre></td></tr></table></figure>

<p>建立定时任务 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CronJob(<span class="string">'0 0 0 * * *'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//每天0：0：0执行</span></span><br><span class="line">    定时任务</span><br><span class="line">&#125;,<span class="literal">null</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p><strong>计时规则</strong></p>
<p>计时规则就是 <code>CronJob</code>中的第一个字符串参数，该字符串由5个空格隔开的6个数字或字符构成。由左向右分别代表的含义为：</p>
<ul>
<li>秒：0-59</li>
<li>分钟：0-59</li>
<li>时间：0-23</li>
<li>每月的日期：1-31</li>
<li>月：0-11（1月-12月）</li>
<li>星期几：0-6（周六）</li>
</ul>
<p><strong>如果该值为*则代表不限制某个时间</strong></p>
<p><strong>例如</strong></p>
<p><code>0 0 0 * * *</code>则代表每一天的0:0:0执行；</p>
<p><code>* * * * * *</code>则代表每一秒都执行；</p>
<p><code>1 * * * * *</code>则代表每分钟的第一秒执行；</p>
<p><code>1 * * 1 * *</code>则代表每月的第一天 的 每分钟的第一秒执行；</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title>在WEB项目中防御XSS攻击</title>
    <url>/2020/05/04/%E5%9C%A8WEB%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%98%B2%E5%BE%A1XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="在WEB项目中防御XSS攻击"><a href="#在WEB项目中防御XSS攻击" class="headerlink" title="在WEB项目中防御XSS攻击"></a>在WEB项目中防御XSS攻击</h2><blockquote>
<p>所谓XSS攻击就是开发者在网站开发时提供了用户的输入入口中输入可执行代码或标记语言（当然本意可能只是想让用户输入文本），并且该内容能够直接在网页中执行（例如在VUE中提供的v-html指令）时，攻击者利用该漏洞，注入一些恶意代码攻击该网站的用户。</p>
</blockquote>
<a id="more"></a>

<h3 id="有效的XSS攻击可能造成的后果"><a href="#有效的XSS攻击可能造成的后果" class="headerlink" title="有效的XSS攻击可能造成的后果"></a>有效的XSS攻击可能造成的后果</h3><p>一次有效的XSS攻击轻则导致网页乱码（通过注入HTML），重则为了搜集用户信息，攻击者甚至会在有漏洞的程序中插入 JavaScript、VBScript、 ActiveX或Flash以欺骗用户。一旦得手，他们可以盗取用户帐户，修改用户设置，盗取/污染cookie，做虚假广告等。</p>
<p>所以说防御XSS的WEB安全最重要的事。</p>
<h3 id="防御XSS攻击"><a href="#防御XSS攻击" class="headerlink" title="防御XSS攻击"></a>防御XSS攻击</h3><p>XSS攻击的两个充分条件是网站提供输入接口，并且该内容将直接被浏览器执行。所以在对用户输入的内容直接放到浏览器中去执行前，需要过滤掉一些关键词，例如HTML的标签、JS的执行语句。目前这些工作都有比较成熟的工具来做了</p>
<h3 id="使用XSS模块"><a href="#使用XSS模块" class="headerlink" title="使用XSS模块"></a>使用XSS模块</h3><p><code>xss</code>是用于过滤用户输入以防止XSS攻击的模块。</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i xss -save</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xss <span class="keyword">from</span> <span class="string">'xss'</span> <span class="comment">// const xss = require('xss')</span></span><br><span class="line">xss(要过滤的字符串) <span class="comment">//返回过滤后的结果</span></span><br></pre></td></tr></table></figure>

<p>xss模块提供过滤白名单</p>
<p>参考 <a href="https://github.com/leizongmin/js-xss/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/leizongmin/js-xss/blob/master/README.zh.md</a></p>
<h3 id="实际开发的建议"><a href="#实际开发的建议" class="headerlink" title="实际开发的建议"></a>实际开发的建议</h3><p>笔者也是在实际开发过程中有幸了解到xss模块以解决我的问题。而在使用中，我的做法是当用户将内容在上传到服务端后，服务端在保存到数据库前将用户内容使用<code>xss</code>模块过滤一遍。而用户请求该内容到前端渲染前再用户端再使用xss模块过滤一遍。这样做可以很大程度上防止xss攻击。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>在VueCli3项目中使用Bootstrap</title>
    <url>/2020/05/04/%E5%9C%A8VueCli3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Bootstrap/</url>
    <content><![CDATA[<h2 id="在VueCli3项目中使用Bootsrap"><a href="#在VueCli3项目中使用Bootsrap" class="headerlink" title="在VueCli3项目中使用Bootsrap"></a>在VueCli3项目中使用Bootsrap</h2><blockquote>
<p>在Vue开发中，为了实现响应式效果加入了Bootstrap框架</p>
</blockquote>
<a id="more"></a>

<p><strong>安装</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i bootstrap jquery popper.js -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p><strong>配置</strong></p>
<p>在项目根目录下新建或修改<code>vue.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    configureWebpack:&#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">                $: <span class="string">'jquery'</span>,</span><br><span class="line">                jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">                <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span>,</span><br><span class="line">                Popper: [<span class="string">'popper.js'</span>, <span class="string">'default'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引入</strong></p>
<p>在<code>main.js</code>中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"bootstrap"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"bootstrap/dist/css/bootstrap.css"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'jquery'</span></span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<p>在组件模板中，可以像常规开发那样使用bootstrap</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row mt-0 mt-md-2"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-12 col-lg-9 px-0"</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="Right d-none d-lg-block col-lg-3  pl-2 p-0"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">"scss"</span> scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>在Vue中点击某个元素以外的元素时让这个元素隐藏或关闭</title>
    <url>/2020/05/04/%E5%9C%A8Vue%E4%B8%AD%E7%82%B9%E5%87%BB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%83%E7%B4%A0%E6%97%B6%E8%AE%A9%E8%BF%99%E4%B8%AA%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E6%88%96%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h2 id="在Vue中点击某个元素以外的元素时让这个元素隐藏或关闭"><a href="#在Vue中点击某个元素以外的元素时让这个元素隐藏或关闭" class="headerlink" title="在Vue中点击某个元素以外的元素时让这个元素隐藏或关闭"></a>在Vue中点击某个元素以外的元素时让这个元素隐藏或关闭</h2><blockquote>
<p>在实际开发中，可能会有点击某个元素以外的元素时让这个元素隐藏或关闭的需求。在Vue中实现则更加简单。</p>
</blockquote>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为全局<code>document</code>添加<code>click</code>事件，判断是否为指定节点及其子节点，如果不是则隐藏该指定节点。</p>
<p>例如该组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    	&lt;span v-show&#x3D;&quot;isShow&quot;&gt;没点击我我就消失了哦&lt;&#x2F;span&gt;</span><br><span class="line">		&lt;button @click&#x3D;&quot;isShow &#x3D; true&quot;&gt;显示&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isShow:false,</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>当前组件现有功能是：<code>span</code>默认不显示，当点击<code>button</code>时显示<code>span</code>。</p>
<p><strong>而现在想要的功能是</strong>，当点击<code>button</code>时显示<code>span</code>，当点击<code>span</code>和<code>button</code>以外的节点都导致<code>span</code>隐藏。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>为span加上ref 以便于获取该DOM节点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span v-show&#x3D;&quot;isShow&quot; ref&#x3D;&quot;showPanel&quot;&gt;没点击我我就消失了哦&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当前组件添加<code>created</code> hook</strong></p>
<ul>
<li>为所有<code>document</code>添加<code>click</code>事件句柄</li>
<li>判断当前的<code>span</code>（<code>this.$refs.showPanel</code>）是否存在</li>
<li>判断当前点击的元素(<code>e.target</code>)是否被span所包含</li>
<li>若不包含则导致<code>span</code>隐藏</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">   document.addEventListener(&#39;click&#39;,(e)&#x3D;&gt;&#123;</span><br><span class="line">       if(this.$refs.showPanel)&#123;</span><br><span class="line">           let isSelf &#x3D; this.$refs.showPanel.contains(e.target)</span><br><span class="line">           if(!isSelf)&#123;</span><br><span class="line">               this.isShow &#x3D; false</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong></p>
<p>实时上述工作完成后，还存在一个问题就是当点击<code>button</code>时导致<code>isShow</code>最终又变为<code>false</code>（事件冒泡，<code>button</code>也是<code>span</code>之外的元素）。所以为了防止冒泡，需要为<code>button</code>的<code>click</code>事件添加<code>.stop</code>修饰符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click.stop&#x3D;&quot;isShow &#x3D; true&quot;&gt;显示&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>在Node.js中实现邮箱验证码功能</title>
    <url>/2020/05/04/%E5%9C%A8Node-js%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="在Node-js中实现邮箱验证码的发送与验证"><a href="#在Node-js中实现邮箱验证码的发送与验证" class="headerlink" title="在Node.js中实现邮箱验证码的发送与验证"></a>在Node.js中实现邮箱验证码的发送与验证</h2><blockquote>
<p>在实际开发中，可能会遇到注册时提供邮箱验证码的需求。在Node.js中是可以实现的。以下分享一些我的开发经验。</p>
</blockquote>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li>Node.js<ul>
<li>Express</li>
<li>Mongoose</li>
</ul>
</li>
<li>MongoDB</li>
</ul>
<a id="more"></a>

<h3 id="邮箱验证码思路"><a href="#邮箱验证码思路" class="headerlink" title="邮箱验证码思路"></a>邮箱验证码思路</h3><h4 id="验证码发送阶段"><a href="#验证码发送阶段" class="headerlink" title="验证码发送阶段"></a>验证码发送阶段</h4><p>客户端上传邮箱地址到服务端，服务端通过生成随机验证码，并将这个验证码发送到用户上传的这个邮箱中。此时服务端需要将这个邮箱和验证码<strong>保存到数据库</strong>的某张表中（后文中使用<strong>Code</strong>来称呼这个表），同时保证这条记录的唯一性。并在<strong>有效时间</strong>内将这条记录删除（此时间就是验证码的有效时间）</p>
<h4 id="验证码验证阶段"><a href="#验证码验证阶段" class="headerlink" title="验证码验证阶段"></a>验证码验证阶段</h4><p>客户端将收到的<strong>验证码和邮箱</strong>重新发送到服务端，服务端开始验证：</p>
<ul>
<li>是否能够从<strong>Code</strong>中查询到这条验证码和邮箱与客户端发送<strong>一致</strong>的记录<ul>
<li><strong>是</strong>：验证通过，并删除这条记录</li>
<li><strong>否</strong>：验证不通过</li>
</ul>
</li>
</ul>
<h3 id="验证码发送阶段-1"><a href="#验证码发送阶段-1" class="headerlink" title="验证码发送阶段"></a>验证码发送阶段</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装提供发送邮件的模块：<code>nodemailer</code>、<code>nodemailer-smtp-transport</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i nodemailer nodemailer<span class="literal">-smtp</span><span class="literal">-transport</span> <span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="引入发送邮件的模块"><a href="#引入发送邮件的模块" class="headerlink" title="引入发送邮件的模块"></a>引入发送邮件的模块</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">'nodemailer'</span>)</span><br><span class="line"><span class="keyword">const</span> smtpTransport = <span class="built_in">require</span>(<span class="string">'nodemailer-smtp-transport'</span>)</span><br></pre></td></tr></table></figure>



<h5 id="创建连接对象"><a href="#创建连接对象" class="headerlink" title="创建连接对象"></a>创建连接对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transport = nodemailer.createTransport(smtpTransport(&#123;</span><br><span class="line">    host: <span class="string">'smtp.163.com'</span>, <span class="comment">// 服务 由于我用的163邮箱</span></span><br><span class="line">    port: <span class="number">465</span>, <span class="comment">// smtp端口 默认无需改动</span></span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      user: <span class="string">'crackerlink@163.com'</span>, <span class="comment">// 用户名</span></span><br><span class="line">      pass: <span class="string">'xxxxxxxxx'</span> <span class="comment">// SMTP授权码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>host</strong>:如果发件使用sina邮箱的话就填写 smtp.sina.com；qq邮箱同理</p>
</li>
<li><p><strong>secure</strong>:如果为<em>true<em>，则连接到服务器时连接将使用TLS。如果为</em>false<em>（默认值），则在服务器支持STARTTLS扩展名的情况下使用TLS。在大多数情况下，如果要连接到端口465，请将此值设置为</em>true<em>。对于端口587或25，请将其保留为</em>false</em></p>
</li>
<li><p><strong>auth</strong>:发件人身份验证对象</p>
<ul>
<li><strong>user</strong>:用户名</li>
<li><strong>pass</strong>：SMTP授权码 (通常在邮箱网站的设置里)</li>
<li><strong>login</strong>:认真类型,默认login（普通用户无需填写这一项）</li>
</ul>
</li>
</ul>
<h5 id="生成随机验证码函数-及-邮箱验证正则"><a href="#生成随机验证码函数-及-邮箱验证正则" class="headerlink" title="生成随机验证码函数 及 邮箱验证正则"></a>生成随机验证码函数 及 邮箱验证正则</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> randomFns=<span class="function"><span class="params">()</span>=&gt;</span> &#123; <span class="comment">// 生成6位随机数</span></span><br><span class="line">    <span class="keyword">let</span> code = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        code += <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code </span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">const</span> regEmail=<span class="regexp">/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span> <span class="comment">//验证邮箱正则</span></span><br></pre></td></tr></table></figure>



<h5 id="建立连接发送验证码"><a href="#建立连接发送验证码" class="headerlink" title="建立连接发送验证码"></a>建立连接发送验证码</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EMAIL=req.body.e_mail <span class="comment">//req为请求体对象 我使用的是post请求方式，所以通过req.body获取用户提交的邮箱</span></span><br><span class="line"><span class="keyword">if</span> (regEmail.test(EMAIL))&#123;  <span class="comment">//邮箱验证通过</span></span><br><span class="line">  <span class="keyword">let</span> code=randomFns()</span><br><span class="line">  transport.sendMail(&#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'crackerlink@163.com'</span>, <span class="comment">// 发件邮箱</span></span><br><span class="line">    to: EMAIL, <span class="comment">// 收件列表</span></span><br><span class="line">    subject: <span class="string">'验证你的电子邮件'</span>, <span class="comment">// 标题</span></span><br><span class="line">    html: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;p&gt;你好！&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;您正在注册Cracker社区账号&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;你的验证码是：&lt;strong style="color: #ff4e2a;"&gt;<span class="subst">$&#123;code&#125;</span>&lt;/strong&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;***该验证码5分钟内有效***&lt;/p&gt;`</span> <span class="comment">// html 内容</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">    assert(!error,<span class="number">500</span>,<span class="string">"发送验证码错误！"</span>)</span><br><span class="line">    transport.close(); <span class="comment">// 如果没用，关闭连接池</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//....验证码发送后的相关工作 </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    assert(<span class="literal">false</span>,<span class="number">422</span>,<span class="string">'请输入正确的邮箱格式！'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="验证码发送后的相关工作"><a href="#验证码发送后的相关工作" class="headerlink" title="验证码发送后的相关工作"></a>验证码发送后的相关工作</h5><p>接下来需要将这个邮箱和验证码保存到<strong>Code</strong>中，同时保证这条记录的唯一性。并在<strong>5分钟</strong>内将这条记录删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">const</span> Code = <span class="built_in">require</span>(<span class="string">"../models/Code"</span>)</span><br><span class="line">   <span class="keyword">const</span> e_mail = EMAIL</span><br><span class="line"><span class="keyword">await</span> Code.deleteMany(&#123;e_mail&#125;) <span class="comment">//删除该旧的验证码，保证该邮箱是最新的验证码有效</span></span><br><span class="line">   <span class="keyword">const</span> [data] = <span class="keyword">await</span> Code.insertMany(&#123;e_mail,<span class="attr">veri_code</span>:code&#125;) <span class="comment">//插入新邮箱验证码组合</span></span><br><span class="line">   setTimeout(<span class="keyword">async</span> ()=&gt;&#123;    <span class="comment">//5分钟后删除</span></span><br><span class="line">       <span class="keyword">await</span> Code.deleteMany(&#123;e_mail&#125;)</span><br><span class="line">   &#125;,<span class="number">1000</span>*<span class="number">60</span>*<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h5 id="发送阶段完整代码"><a href="#发送阶段完整代码" class="headerlink" title="发送阶段完整代码"></a>发送阶段完整代码</h5><p><strong>（推荐将其封装为中间件）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">'nodemailer'</span>)</span><br><span class="line">    <span class="keyword">const</span> smtpTransport = <span class="built_in">require</span>(<span class="string">'nodemailer-smtp-transport'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'http-assert'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> transport = nodemailer.createTransport(smtpTransport(&#123;</span><br><span class="line">        host: <span class="string">'smtp.163.com'</span>, <span class="comment">// 服务</span></span><br><span class="line">        port: <span class="number">465</span>, <span class="comment">// smtp端口</span></span><br><span class="line">        secure: <span class="literal">true</span>,</span><br><span class="line">        auth: &#123;</span><br><span class="line">          user: <span class="string">'crackerlink@163.com'</span>, <span class="comment">//用户名</span></span><br><span class="line">          pass: <span class="string">'xxxxxxx'</span> <span class="comment">// SMTP授权码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">const</span> randomFns=<span class="function"><span class="params">()</span>=&gt;</span> &#123; <span class="comment">// 生成6位随机数</span></span><br><span class="line">        <span class="keyword">let</span> code = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            code += <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> regEmail=<span class="regexp">/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span> <span class="comment">//验证邮箱正则</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span>(req,res,next)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> EMAIL=req.body.e_mail</span><br><span class="line">        <span class="keyword">if</span> (regEmail.test(EMAIL))&#123;</span><br><span class="line">          <span class="keyword">let</span> code=randomFns()</span><br><span class="line">          transport.sendMail(&#123;</span><br><span class="line">            <span class="keyword">from</span>: <span class="string">'crackerlink@163.com'</span>, <span class="comment">// 发件邮箱</span></span><br><span class="line">            to: EMAIL, <span class="comment">// 收件列表</span></span><br><span class="line">            subject: <span class="string">'验证你的电子邮件'</span>, <span class="comment">// 标题</span></span><br><span class="line">            html: <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;p&gt;你好！&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;您正在注册Cracker社区账号&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;你的验证码是：&lt;strong style="color: #ff4e2a;"&gt;<span class="subst">$&#123;code&#125;</span>&lt;/strong&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;***该验证码5分钟内有效***&lt;/p&gt;`</span> <span class="comment">// html 内容</span></span><br><span class="line">          &#125;, </span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">            assert(!error,<span class="number">500</span>,<span class="string">"发送验证码错误！"</span>)</span><br><span class="line">            transport.close(); <span class="comment">// 如果没用，关闭连接池</span></span><br><span class="line">          &#125;)        </span><br><span class="line">          <span class="keyword">const</span> Code = <span class="built_in">require</span>(<span class="string">"../models/Code"</span>)</span><br><span class="line">          <span class="keyword">const</span> e_mail = EMAIL</span><br><span class="line">          <span class="keyword">await</span> Code.deleteMany(&#123;e_mail&#125;)</span><br><span class="line">          <span class="keyword">const</span> [data] = <span class="keyword">await</span> Code.insertMany(&#123;e_mail,<span class="attr">veri_code</span>:code&#125;)</span><br><span class="line">          setTimeout(<span class="keyword">async</span> ()=&gt;&#123;    <span class="comment">//5分钟后失效</span></span><br><span class="line">              <span class="keyword">await</span> Code.deleteMany(&#123;e_mail&#125;)</span><br><span class="line">          &#125;,<span class="number">1000</span>*<span class="number">60</span>*<span class="number">5</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            assert(<span class="literal">false</span>,<span class="number">422</span>,<span class="string">'请输入正确的邮箱格式！'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="验证码验证阶段-1"><a href="#验证码验证阶段-1" class="headerlink" title="验证码验证阶段"></a>验证码验证阶段</h3><p>验证阶段只需要通过获取用户得邮箱和验证码是否在<strong>Code</strong>中查询到即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/new'</span>,<span class="keyword">async</span> (req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;e_mail,veri_code&#125; = req.body</span><br><span class="line">    <span class="comment">// 验证码验证</span></span><br><span class="line">    <span class="keyword">const</span> vire = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">'../../models/Code'</span>).findOne(&#123;e_mail,veri_code&#125;)</span><br><span class="line">    assert(vire,<span class="number">422</span>,<span class="string">'验证码出错'</span>)</span><br><span class="line">    </span><br><span class="line">    awaitrequire(<span class="string">'../../models/Code'</span>).deleteMany(&#123;e_mail&#125;)</span><br><span class="line">    <span class="keyword">return</span> res.send(&#123;<span class="attr">message</span>:<span class="string">"验证码正确"</span>&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express框架</tag>
        <tag>nodemailer</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-clipboard2实现复制功能</title>
    <url>/2020/05/04/vue-clipboard2%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="vue-clipboard2实现复制功能"><a href="#vue-clipboard2实现复制功能" class="headerlink" title="vue-clipboard2实现复制功能"></a>vue-clipboard2实现复制功能</h2><blockquote>
<p>在Vue中通过该模块能够实现 将内容复制到剪贴板的功能</p>
</blockquote>
<a id="more"></a>

<p><strong>安装</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i vue<span class="literal">-clipboard2</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>



<p><strong>在<code>main.js</code>中注册</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueClipboard <span class="keyword">from</span> <span class="string">'vue-clipboard2'</span></span><br><span class="line">Vue.use(VueClipboard)</span><br></pre></td></tr></table></figure>



<p><strong>使用</strong></p>
<ol>
<li>vue-clipboard2提供自定义指令使用（默认点击事件执行复制）</li>
</ol>
<p><strong>绑定要复制的内容</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-clipboard:copy=<span class="string">"url"</span></span><br></pre></td></tr></table></figure>

<p><strong>复制成功后执行的hook</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-clipboard:success=<span class="string">"cpySuccess"</span> <span class="comment">//cpySuccess为一个自定义方法</span></span><br></pre></td></tr></table></figure>

<p><strong>复制失败后执行的hook</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-clipboard:error=<span class="string">"cpyError"</span> <span class="comment">//cpyError为一个自定义方法</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>vue-clipboard2提供使用$copyText方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        copy()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$copyText(<span class="built_in">String</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                ..复制成功</span><br><span class="line">            &#125;,err=&gt;&#123;</span><br><span class="line">                ..复制失败</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>vue-clipboard2</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS补缺备忘</title>
    <url>/2020/02/27/CSS%20%E4%B9%8B%20%E8%A1%A5%E7%BC%BA%E7%AF%87/</url>
    <content><![CDATA[<h1 id="CSS-之-补缺备忘用"><a href="#CSS-之-补缺备忘用" class="headerlink" title="CSS 之 补缺备忘用"></a>CSS 之 补缺备忘用</h1><p>个人补缺时记录。</p>
<a id="more"></a>

<h2 id="一、段落相关"><a href="#一、段落相关" class="headerlink" title="一、段落相关"></a>一、段落相关</h2><blockquote>
<p>关于文字，这次要补充的并不多，是一些并不太常见，但又有实用价值的属性及其值</p>
</blockquote>
<h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>在段落标签中，可以使用<code>text-indent:length</code>属性对段落进行指定长度的首行缩进，值得一提的是将长度设置为负数并不能达到悬挂缩进的效果，反而会隐藏前面的<code>content</code>。</p>
<h4 id="词间距"><a href="#词间距" class="headerlink" title="词间距"></a>词间距</h4><p>每个单词之间的间距<code>word-spacing:length</code>,实际上是对内容中的空格的长度进行了设置。</p>
<h4 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h4><p><code>letter-spacing:length</code></p>
<h4 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">    <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span><br><span class="line">    <span class="comment">/*文本溢出部分使用省略号表示*/</span></span><br><span class="line">    <span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span><br><span class="line">    <span class="comment">/*设置文本不换行*/</span></span><br><span class="line">    <span class="selector-tag">white-space</span><span class="selector-pseudo">:nowrap</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多行文本溢出省略"><a href="#多行文本溢出省略" class="headerlink" title="多行文本溢出省略"></a>多行文本溢出省略</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="selector-tag">display</span><span class="selector-pseudo">:-webkit-box</span>;</span><br><span class="line">   	<span class="comment">/*设置为3行溢出*/</span></span><br><span class="line">    <span class="selector-tag">-webkit-line-clamp</span><span class="selector-pseudo">:3</span>;</span><br><span class="line">    <span class="selector-tag">-webkit-box-orient</span><span class="selector-pseudo">:vertical</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ol>
<li><code>-webkit-line-clamp</code>用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：</li>
<li><code>display: -webkit-box;</code>： 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</li>
<li><code>-webkit-box-orient</code>： 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</li>
</ol>
<h4 id="段落换行"><a href="#段落换行" class="headerlink" title="段落换行"></a>段落换行</h4><p>默认情况下，对于在固定宽度的块级标签中的英文内容，不会拆分单词换行（以空格之间的字符串算作单词），为了解决这个问题，可以通过</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">word-wrap</span>:break-word;</span><br><span class="line">    <span class="comment">/*或者*/</span></span><br><span class="line">    <span class="attribute">word-break</span>: break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="段落中文字相对于inline-block元素的垂直对齐方式"><a href="#段落中文字相对于inline-block元素的垂直对齐方式" class="headerlink" title="段落中文字相对于inline-block元素的垂直对齐方式"></a>段落中文字相对于inline-block元素的垂直对齐方式</h4><p>例如对于段落中的图片所在的一行中的文字位于上/中/下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    vertical-align:top/middle/bottom/*length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131131158.png" alt="默认/buttom"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131131409.png" alt="top"></p>
<h2 id="二、关于背景-Background"><a href="#二、关于背景-Background" class="headerlink" title="二、关于背景 Background"></a>二、关于背景 Background</h2><blockquote>
<p>在css中其实对于元素的背景有很多丰富的功能定义，在此次笔记中，将不再赘述我所认为的background常规属性及值。</p>
</blockquote>
<h4 id="背景裁剪"><a href="#背景裁剪" class="headerlink" title="背景裁剪"></a>背景裁剪</h4><p>默认情况下，元素设置背景是在盒子模型的边框以内（包括边框）的空间内都会渲染到。</p>
<p>背景裁剪就是，限制背景渲染空间：包括边框以内 / 包括padding以内 / 包括内容以内。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.bg1</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	background-clip:border-box/padding-box/content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="背景滚动"><a href="#背景滚动" class="headerlink" title="背景滚动"></a>背景滚动</h4><p>默认下背景会跟随网页一起滚动，实际上也可以将背景固定在屏幕上</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.bg2</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	background-attachment:screen/fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="背景线性渐变"><a href="#背景线性渐变" class="headerlink" title="背景线性渐变"></a>背景线性渐变</h4><ol>
<li><p>为背景色按指定角度进行线性渐变</p>
<p><code>backgoround:linear-gradient(90deg,red,blue)</code>（90度，由红均等向蓝色渐变）</p>
</li>
<li><p>可以设置多种颜色<code>linear-gradient(90deg,red,blue，yellow,...)</code></p>
</li>
<li><p>设置渐变的距离<code>linear-gradient(90deg,red 50%,blue 60%)</code> 即（50%，60%）为渐变空间，来认识一下完整写法其实为<code>linear-gradient(90deg,red 0%,red 50%,blue 60%,blue 100%)</code> ，多色同理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131134830.png" alt=""></p>
</li>
<li><p>若两色之间的渐变空间为0，既：<code>linear-gradient(90deg,red 50%,blue 50%)</code>，就是直接变换的效果了</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131135102.png" alt=""></p>
</li>
<li><p><strong>重复线性渐变</strong> ，通过<code>repeating-linear-gradient(角度，颜色1 起始位置，颜色1 结束位置，颜色2起始位置，...)</code>方法设定，可以实现重复已定义区域的效果完成未定义内容的背景。例如</p>
<p><code>repeating-linear-gradient(45deg,yellow 0px,yellow 25px,black 25px,black 50px)</code>实现警示条</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131134857.png" alt=""></p>
</li>
</ol>
<h4 id="背景径向渐变"><a href="#背景径向渐变" class="headerlink" title="背景径向渐变"></a>背景径向渐变</h4><ol>
<li><p><code>background/background-image: radial-gradient(shape size at position, start-color, ..., last-color);</code></p>
<p>shape 为由内向外的形状，默认为Ellipse椭圆，可设为Circle原型</p>
<p>例如<code>radial-gradient(Circle,red 0,yellow 40%,black 70%)</code></p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131134846.png" alt=""></p>
<ol start="2">
<li><p>重复径向渐变</p>
<p><code>repeating-radial-gradient(shape size at position, start-color beginLength, ..., last-color endLength)</code></p>
<p>例如 <code>repeating-radial-gradient(black 0px,black 10px,yellow 10px,yellow 20px)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131150541.png" alt=""></p>
</li>
</ol>
<h2 id="三、关于表格Table"><a href="#三、关于表格Table" class="headerlink" title="三、关于表格Table"></a>三、关于表格Table</h2><h4 id="css定义表格"><a href="#css定义表格" class="headerlink" title="css定义表格"></a>css定义表格</h4><p>使用css通过设定display 属性的方式绘制表格，效率很低，但是得知道。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200131152116.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.table</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="selector-tag">display</span><span class="selector-pseudo">:table</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为表格内容垂直定位"><a href="#为表格内容垂直定位" class="headerlink" title="为表格内容垂直定位"></a>为表格内容垂直定位</h4><p>普通单元格只需要使用<code>vertical-align:top/middle/bottom</code>。</p>
<p>但是，值得一提的是caption标签对以上属性无效，需要利用该属性<code>caption{ caption-side:bottom/top; }</code></p>
<h4 id="设置单元格间距"><a href="#设置单元格间距" class="headerlink" title="设置单元格间距"></a>设置单元格间距</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="selector-tag">border-space</span>:水平间距，垂直间距;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为单元格去除互相之间的边距和重复框线"><a href="#为单元格去除互相之间的边距和重复框线" class="headerlink" title="为单元格去除互相之间的边距和重复框线"></a>为单元格去除互相之间的边距和重复框线</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="selector-tag">border-collapse</span>: <span class="selector-tag">collapse</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、关于粘性定位-Sticky"><a href="#四、关于粘性定位-Sticky" class="headerlink" title="四、关于粘性定位 Sticky"></a>四、关于粘性定位 Sticky</h2><p>在被声明为sticky定位的元素，在参照对象（至少为父元素）为relative的前提下，当该元素的处于相对于参照对象的某一位置阈值前该元素按照正常的文档流定位，然而当其超过该阈值后，则该元素按照fixed定位方式固定在父元素上。</p>
<p>例如</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/gg1.gif" alt=""></p>
<p>对于每个分段<code>section</code>的标题<code>h4</code>和底部<code>footer</code>都设置为sticky定位方式，而他们的参照元素是<code>article</code>，当其相对于参照元素的顶部距离小于等于0时，切换为fixed方式固定于窗体顶端否则为正常文档流。</p>
<p>而对于底部，当其相对于参照元素的底部距离小于等于50px时则切换为fixed固定于距参照元素底部50px的位置，一旦大于则切换为正常相对定位。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">article</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">margin</span>: auto;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">5px</span> <span class="number">#ddd</span> solid;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">            <span class="attribute">position</span>: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.content</span>&#123;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">article</span> <span class="selector-tag">h4</span>&#123;</span><br><span class="line">            <span class="attribute">padding</span>:<span class="number">15px</span> <span class="number">5px</span>;</span><br><span class="line">            <span class="attribute">margin-bottom</span>: <span class="number">0px</span>;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#323232</span>;</span><br><span class="line">            <span class="attribute">position</span>: -webkit-sticky;</span><br><span class="line">            <span class="attribute">position</span>: sticky;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">            <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">article</span> <span class="selector-tag">footer</span>&#123;</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">            <span class="attribute">position</span>:-webkit-sticky;</span><br><span class="line">            <span class="attribute">position</span>: sticky;</span><br><span class="line">            <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">bottom</span>: <span class="number">50px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h2 id="五、弹性布局方式Flex"><a href="#五、弹性布局方式Flex" class="headerlink" title="五、弹性布局方式Flex"></a>五、弹性布局方式Flex</h2><blockquote>
<p> 弹性（Flex）布局是一种灵活响应式的布局方式，目前已获得主流浏览器的支持。</p>
</blockquote>
<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202201335.png" alt=""></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<p>定义容器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">   	<span class="comment">/*块级*/</span></span><br><span class="line">    <span class="attribute">display</span>:-webkit-flex;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="comment">/*行内*/</span></span><br><span class="line">    <span class="attribute">display</span>:inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器的属性（6个）"><a href="#容器的属性（6个）" class="headerlink" title="容器的属性（6个）"></a>容器的属性（6个）</h3><h4 id="1-项目的排列方向"><a href="#1-项目的排列方向" class="headerlink" title="1. 项目的排列方向"></a>1. 项目的排列方向</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-direction: row|row-reverse|column|column-reverse</span><br></pre></td></tr></table></figure>

<p>主轴分别为自左而右，自右而左，自上而下，自下而上</p>
<p><strong>注意，根据该属性的定义，会决定主轴和交叉轴的水平和垂直方式。例如，为<code>row/row-reverse</code>时,主轴为水平，交叉轴为垂直，当属性值为<code>column/column-reverse</code>时，主轴为垂直，交叉轴为水平。</strong></p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">....    </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line">            width: 550px;</span><br><span class="line">            margin: auto;</span><br><span class="line">            display: flex;</span><br><span class="line">            border: 2px yellow solid;</span><br><span class="line"><span class="css">            <span class="comment">/*默认值*/</span></span></span><br><span class="line">            flex-direction: row;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-id">#fff</span> <span class="selector-tag">solid</span>;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#888</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            font-size: 40px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item1"</span> &gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202203145.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="selector-tag">flex-derection</span><span class="selector-pseudo">:row-reverse</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202204046.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="selector-tag">flex-derection</span><span class="selector-pseudo">:column</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202204002.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="selector-tag">flex-derection</span><span class="selector-pseudo">:column-reverse</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202203852.png" alt=""></p>
<h4 id="2-项目的换行方式"><a href="#2-项目的换行方式" class="headerlink" title="2. 项目的换行方式"></a>2. 项目的换行方式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-wrap: nowrap|wrap|wrap-reverse</span><br></pre></td></tr></table></figure>

<p>当主轴上排不下时，对于项目的换行方法，分别为不换行（均等减少所有项目的<code>main size</code>）、溢出部分补到后面、溢出部分添至前面</p>
<p>根据上例再追加2个项目6，7后，分别实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202204352.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202204442.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202204513.png" alt=""></p>
<h4 id="3-排列换行的简写"><a href="#3-排列换行的简写" class="headerlink" title="3. 排列换行的简写"></a>3. 排列换行的简写</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line"><span class="comment">/*例如*/</span></span><br><span class="line"><span class="selector-tag">flex-flow</span><span class="selector-pseudo">:row</span> <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-项目在主轴上对齐方式"><a href="#4-项目在主轴上对齐方式" class="headerlink" title="4. 项目在主轴上对齐方式"></a>4. 项目在主轴上对齐方式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure>

<p>设置项目在主轴上的对齐方式</p>
<ul>
<li>主轴起始处对齐（默认值）</li>
<li>主轴终止处对齐</li>
<li>根据主轴居中</li>
<li>两端对齐</li>
<li>均等对齐。每个项目两端展开的距离相等，因此项目间的距离是项目与边界间的距离的两倍</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202225037.png" alt=""></p>
<h4 id="5-项目在交叉轴上的对齐方式"><a href="#5-项目在交叉轴上的对齐方式" class="headerlink" title="5. 项目在交叉轴上的对齐方式"></a>5. 项目在交叉轴上的对齐方式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure>

<ul>
<li>交叉轴起点处对齐</li>
<li>交叉轴终点处对齐</li>
<li>根据交叉轴居中</li>
<li>项目第一行文字为基线对齐</li>
<li>如果项目未设置高度或设为auto，默认将占满整个容器的高度，否则以<code>flex-start</code>对齐。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202212313.png" alt=""></p>
<h4 id="6-多行项目在交叉轴上的对齐方式"><a href="#6-多行项目在交叉轴上的对齐方式" class="headerlink" title="6. 多行项目在交叉轴上的对齐方式"></a>6. 多行项目在交叉轴上的对齐方式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">align-content:flex-start | flex-end | center | space-between | space-around | stretch</span><br></pre></td></tr></table></figure>

<p><strong>注意，只对多行的项目的容器有效</strong></p>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
<p><em>和<code>justify-content</code>效果基本一致，仅依据轴相反，因此不再置示意图。</em></p>
<h3 id="项目的属性（6个）"><a href="#项目的属性（6个）" class="headerlink" title="项目的属性（6个）"></a>项目的属性（6个）</h3><h4 id="1-调整项目顺序"><a href="#1-调整项目顺序" class="headerlink" title="1. 调整项目顺序"></a>1. 调整项目顺序</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">order</span>:&lt;<span class="selector-tag">number</span>&gt; <span class="comment">/*默认为0*/</span></span><br></pre></td></tr></table></figure>

<p><code>order</code>的值确定项目先后顺序，按从低到高，同级间按dom先后顺序排，是一种优雅的调整项目先后顺序的方式。</p>
<p>例如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		<span class="selector-class">.item4</span>&#123;</span><br><span class="line">            <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.item1</span>&#123;</span><br><span class="line">            <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202214943.png" alt=""></p>
<h4 id="2-项目按比例放大"><a href="#2-项目按比例放大" class="headerlink" title="2. 项目按比例放大"></a>2. 项目按比例放大</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 0 负数无效 */</span></span><br></pre></td></tr></table></figure>

<p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<p>默认情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202220124.png" alt=""></p>
<p>所有项目等分剩余空间：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">flex-grow</span><span class="selector-pseudo">:1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202215502.png" alt=""></p>
<p>或者：item2是item1分得剩余空间的2倍，而item3为item1的3倍</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span>&#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span>&#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>:<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202220004.png" alt=""></p>
<h4 id="3-项目按比例缩小"><a href="#3-项目按比例缩小" class="headerlink" title="3.项目按比例缩小"></a>3.项目按比例缩小</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 1 负数无效*/</span></span><br></pre></td></tr></table></figure>

<p>当该属性值为默认1时，在<code>flex-wrap</code>为<code>nowrap</code>的情况下，所有项目在超出主轴宽度时会等比缩小。而<code>flex-shrink</code>的属性值越大则缩小的比例也就越高。</p>
<p><strong>值得一提的是，当某项目的该属性值为0时，则该项目不会被自动缩小。</strong></p>
<h4 id="4-项目main-size的设置"><a href="#4-项目main-size的设置" class="headerlink" title="4.项目main size的设置"></a>4.项目<code>main size</code>的设置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; /* default auto */</span><br></pre></td></tr></table></figure>

<p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。     </p>
<h4 id="5-简写方式"><a href="#5-简写方式" class="headerlink" title="5. 简写方式"></a>5. 简写方式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</span><br></pre></td></tr></table></figure>

<p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>这就有了我们常见的写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202215502.png" alt="各个项目等比放大"></p>
<p>或者：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>:<span class="number">1</span> <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202222743.png" alt="等比放大，但不自动缩小"></p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202222803.png" alt="与上同"></p>
<h4 id="6-对项目单独设置在交叉轴上的对齐方式"><a href="#6-对项目单独设置在交叉轴上的对齐方式" class="headerlink" title="6.对项目单独设置在交叉轴上的对齐方式"></a>6.对项目单独设置在交叉轴上的对齐方式</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure>

<p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<p>例如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">align-items</span><span class="selector-pseudo">:center</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>:flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200202223829.png" alt=""></p>
<h2 id="六、栅格布局方式Grid"><a href="#六、栅格布局方式Grid" class="headerlink" title="六、栅格布局方式Grid"></a>六、栅格布局方式Grid</h2><blockquote>
<p>众人云，Grid布局是CSS中最强的布局方式。Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p>
<p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p>
</blockquote>
<p><strong>注</strong></p>
<ul>
<li>容器和项目：<em>和Flex布局所述一致，只对项目生效，但不包括项目的子元素</em></li>
<li>行<code>row</code>和列<code>column</code>与单元格<code>cell</code>：<em>容器中的水平方向为行，垂直方向为列，行列交叉处为单元格</em></li>
<li>网格线<code>grid line</code>:<em>划分网格的线，分水平网格线和垂直网格线</em></li>
</ul>
<p>定义为Grid容器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="comment">/*或行内元素*/</span></span><br><span class="line">    <span class="attribute">display</span>:inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="容器的属性container"><a href="#容器的属性container" class="headerlink" title="容器的属性container"></a>容器的属性<code>container</code></h3><h4 id="1-依次定义各列各行宽度"><a href="#1-依次定义各列各行宽度" class="headerlink" title="1. 依次定义各列各行宽度"></a>1. 依次定义各列各行宽度</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-rows</span>: 第一行高度 第二行高度 ... ;</span><br><span class="line"><span class="selector-tag">grid-template-column</span>: 第一列宽度 第二列宽度 ...;</span><br></pre></td></tr></table></figure>

<p>通过这两个属性的设置，可以确定该容器内有多少行和多少列，定义多少就有多少。</p>
<p>例如定义个3*3的表格：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">dispaly</span><span class="selector-pseudo">:grid</span>;</span><br><span class="line">    <span class="selector-tag">grid-template-rows</span><span class="selector-pseudo">:100px</span> 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="comment">/*当然百分比或者其他单位也可以*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200203154736.png" alt="3*3等距表格"></p>
<p>又或者定义一个 不规则 2*4的表格：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">         </span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">dispaly</span><span class="selector-pseudo">:grid</span>;</span><br><span class="line">    <span class="selector-tag">grid-template-rows</span><span class="selector-pseudo">:100px</span> 200<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> 100<span class="selector-tag">px</span> 50<span class="selector-tag">px</span> 100<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200203155309.png" alt="2*4"></p>
<p><strong>对于容器内超出单元格总数的项目会自动按行追加下去，注意，宽度仍依照Grid定义的宽度，但是行高为项目自身的宽度</strong></p>
<p>可以注意到，如果对于具有要定义很多行列数据的容器，这两个属性的属性值写起来很繁琐。所以CSS提供了一些方法分别用于处理一些特殊情况：</p>
<ul>
<li><p>repeat()</p>
</li>
<li><p>auto-fill关键字</p>
</li>
<li><p>fr关键字</p>
</li>
<li><p>minmax()</p>
</li>
<li><p>auto关键字</p>
</li>
<li><p>[]</p>
<p><strong>repeat 按某些值重复</strong></p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="built_in">repeat</span>(重复次数，长度<span class="number">1</span> | 长度<span class="number">2</span> | ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>auto-fill 自动设置重复次数</strong></p>
<p>与repeat函数配合使用，根据容器的<code>width</code>或者<code>height</code>来确定最大能放下这容器行或列的重复次数。假设容器宽度为400px,那么下面这段代码将会将容器确定为4列。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attribute">grid-template-rows</span>:<span class="number">100px</span> <span class="number">100px</span> ;</span><br><span class="line">	<span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill,<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fr作为单位 在项目的尺寸没有明确定义时，根据容器的宽或高分别按比分配项目的列宽或行高</strong></p>
<p>类似于Flex中的flex-grow属性，但是fs是根据容器的整个尺寸确定的，而flex-grow是根据容器的剩余空间按比分配。如果值列表中有明确的长度定义，则根据剩余尺寸按比分配如例2。</p>
<p>例1</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="built_in">repeat</span>(<span class="number">4</span>,<span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200203163244.png" alt="4*2"></p>
<p>例2</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>:<span class="built_in">repeat</span>(<span class="number">4</span>,<span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若容器宽度为400px ,则列宽分别为100px、100px、200px。</p>
<p> <strong>minmax() 确定项目所能取得行高或列宽的范围</strong></p>
<p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure>



<p><strong>[]为网格线命名</strong></p>
<p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4 endL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和类名一样，可以为一个网格线同时定义多个名称如<code>[r4 endL]</code>。</p>
<h4 id="2-设置行列间距"><a href="#2-设置行列间距" class="headerlink" title="2.设置行列间距"></a>2.设置行列间距</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*行间距*/</span></span><br><span class="line"><span class="selector-tag">row-gap</span><span class="selector-pseudo">:length</span>;</span><br><span class="line"><span class="comment">/*列间距*/</span></span><br><span class="line"><span class="selector-tag">column-gap</span><span class="selector-pseudo">:length</span>;</span><br><span class="line"><span class="comment">/*简写方式*/</span></span><br><span class="line"><span class="selector-tag">grid-gap</span>:&lt;<span class="selector-tag">row-gap</span>&gt; &lt;<span class="selector-tag">column-gap</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这里的行间距仅指行与行之间的距离，不包括行与边界的距离。列间距同理。若行列间距都相等，<code>grid-gap</code>也可以只填一个值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">column-gap</span>: 30<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">row-gap</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200203170046.png" alt=""></p>
<h4 id="3-区域划分"><a href="#3-区域划分" class="headerlink" title="3. 区域划分"></a>3. 区域划分</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">gird-template-areas:'第一行第一列区域名 第一行第二列区域名 第一行第三列区域名 ...'</span><br><span class="line">					'第二行第一列区域名...'</span><br><span class="line">					...</span><br></pre></td></tr></table></figure>

<p>对每个单元格来说，可能多个单元格同属一个区域，可以为他们进行定义区域，同一区域的区域名一致。</p>
<p>例如 划分为3*3个不同的区域</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'a b c'</span></span><br><span class="line">                       <span class="string">'d e f'</span></span><br><span class="line">                       <span class="string">'g h i'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>划分3*1个不同区域</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'a a a'</span></span><br><span class="line">                       <span class="string">'b b b'</span></span><br><span class="line">                       <span class="string">'c c c'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，存在一些不需要利用的单元格区域，可以使用<code>.</code>号</strong></p>
<p>例如，不需要利用最后一列</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'a a .'</span></span><br><span class="line">                       <span class="string">'b b .'</span></span><br><span class="line">                       <span class="string">'c c .'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区域的命名会影响到网格线。每个区域的起始的水平网格线和垂直网格线会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p>
<h4 id="4-单元格排列换行"><a href="#4-单元格排列换行" class="headerlink" title="4. 单元格排列换行"></a>4. 单元格排列换行</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-auto-flow: row | column | row dense |column dense;</span><br></pre></td></tr></table></figure>

<p>分别为</p>
<ul>
<li>按行排列，换行时添加到下一行第一列（默认）</li>
<li>按列排列，换行时添加到下一列第一行</li>
<li>按行排列，换行时添加到下一行第一列，但并不严格，会自动填充</li>
<li>按列排列，换行时添加到下一列第一行，但并不严格，会自动填充</li>
</ul>
<h4 id="5-项目内容对齐方式"><a href="#5-项目内容对齐方式" class="headerlink" title="5.项目内容对齐方式"></a>5.项目内容对齐方式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
<ol>
<li><p>前两个分别是单元格内容的水平对齐方式和垂直对齐方式，这两个并不陌生，各个属性值的效果和<code>flex</code>布局中的一致（当然，相比之下去掉了一些<code>flex</code>前缀）。注意的是当单元格内容的高宽都没有定义的时候，默认值是<code>stretch</code>,一旦定义高或宽后，其对应的<code>justify-items</code>或<code>align-items</code>默认值改为<code>start</code></p>
</li>
<li><p>而<code>place-items</code>是前两者的简写方式,如果省略第二个值，则浏览器认为与第一个值相等。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200204151912.png" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">justify-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">    <span class="selector-tag">align-items</span>: <span class="selector-tag">end</span>;</span><br><span class="line">    <span class="comment">/*或者*/</span></span><br><span class="line">    <span class="selector-tag">place-items</span><span class="selector-pseudo">:center</span> <span class="selector-tag">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-表格整体在容器内的对齐方式"><a href="#6-表格整体在容器内的对齐方式" class="headerlink" title="6. 表格整体在容器内的对齐方式"></a>6. 表格整体在容器内的对齐方式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line"></span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">place-content</span>:&lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt; ;</span><br></pre></td></tr></table></figure>



<ul>
<li>start - 对齐容器的起始边框。</li>
<li>end - 对齐容器的结束边框。</li>
<li>center - 容器内部居中。</li>
<li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li>
<li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li>
<li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li>
<li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li>
</ul>
<h4 id="7-设置新增行列的高宽"><a href="#7-设置新增行列的高宽" class="headerlink" title="7. 设置新增行列的高宽"></a>7. 设置新增行列的高宽</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gird-auto-rows</span><span class="selector-pseudo">:length</span>;</span><br><span class="line"><span class="selector-tag">grid-auto-columns</span><span class="selector-pseudo">:length</span>;</span><br></pre></td></tr></table></figure>

<p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<blockquote>
<p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p>
<p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p>
</blockquote>
<h3 id="项目的属性item"><a href="#项目的属性item" class="headerlink" title="项目的属性item"></a>项目的属性<code>item</code></h3><h4 id="1-根据网格线控制项目位置"><a href="#1-根据网格线控制项目位置" class="headerlink" title="1.根据网格线控制项目位置"></a>1.根据网格线控制项目位置</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-column-start</span>:左边框所在的垂直网格线</span><br><span class="line"><span class="selector-tag">grid-column-end</span>:右边框所在的垂直网格线</span><br><span class="line"><span class="selector-tag">grid-row-start</span>:上边框所在的水平网格线</span><br><span class="line"><span class="selector-tag">grid-row-end</span>:下边框所在的水平网格线</span><br></pre></td></tr></table></figure>

<p><strong>简写模式</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-column:起始值 / 结束值；</span><br><span class="line">grid-row：起始值 / 结束值；</span><br></pre></td></tr></table></figure>

<p><strong>斜杠以及后面的部分可以省略，默认跨越一个网格。</strong></p>
<p>决定项目的左右框线和上下框线，其中框线可以用数字（从1开始计数）表示，也可以使用在容器阶段定义的网格线名称。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="selector-tag">grid-template-rows</span><span class="selector-pseudo">:repeat(4</span>,100<span class="selector-tag">px</span>);</span><br><span class="line">    <span class="selector-tag">grid-template-columns</span>: <span class="selector-attr">[l1]</span>1<span class="selector-tag">fr</span> <span class="selector-attr">[l2]</span>2<span class="selector-tag">fr</span> <span class="selector-attr">[l3]</span>; <span class="comment">/*之前说过这里可以定义网格线名称*/</span></span><br><span class="line">&#125;        </span><br><span class="line"><span class="selector-class">.item1</span>&#123;        </span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">1</span>;    </span><br><span class="line">    <span class="attribute">grid-column-end</span>:<span class="number">3</span>;    </span><br><span class="line">    <span class="comment">/*简写*/</span></span><br><span class="line">    <span class="attribute">grid-column</span>:<span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item4</span>&#123;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">3</span>;    </span><br><span class="line">    <span class="attribute">grid-row-end</span>: <span class="number">5</span>;    </span><br><span class="line">    <span class="attribute">grid-column-start</span>: l1;   <span class="comment">/*使用之前定义的网格线名称*/</span>  </span><br><span class="line">    <span class="attribute">grid-column-end</span>: l3;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200204161213.png" alt="项目1和项目4发生的变化"></p>
<p>这里值得一提的是，当某单元格发生改变后，具体的填充效果由容器阶段定义的<code>grid-auto-flow</code>决定。</p>
<p>这四个属性的值还可以使用<strong><code>span</code>关键字</strong>，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。<strong>当跨越的网格数超出该行或者该列最大剩余数目的时候会扩大该项目所属容器的宽或高</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*使用span时，两者效果一致*/</span></span><br><span class="line">  <span class="attribute">grid-column-end</span>: span <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*使用简写模式时，只在终止值使用span*/</span></span><br><span class="line">  <span class="attribute">grid-column</span>:<span class="number">1</span> / span2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用简写方式，再重新实现<code>item4</code>的位置控制</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item4</span>&#123;</span><br><span class="line">    <span class="attribute">grid-row</span>:<span class="number">3</span> / span <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column</span>: l1 / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-根据区域放置项目"><a href="#2-根据区域放置项目" class="headerlink" title="2.根据区域放置项目"></a>2.根据区域放置项目</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-area</span>:区域名;</span><br></pre></td></tr></table></figure>

<p>通过该方法，我们可以指定该项目放到任何一个在容器中使用<code>grid-template-areas</code>属性来定义过的区域中去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JackyM06/MyPictures/20200204163847.png" alt=""></p>
<p>上例中设置了一个3*2的表格，4共个项目，并设定了4个区域，分别指定了每个项目的区域:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    grid-template-areas: 'head head'</span><br><span class="line">                         'content note'</span><br><span class="line">                         'foot foot';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="selector-class">.item1</span>&#123;</span><br><span class="line">            <span class="attribute">grid-area</span>: content;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.item2</span>&#123;</span><br><span class="line">            <span class="attribute">grid-area</span>: note;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.item3</span>&#123;</span><br><span class="line">            <span class="attribute">grid-area</span>: head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.item4</span>&#123;</span><br><span class="line">            <span class="attribute">grid-area</span>:foot;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以上上例中的<code>item4</code>可以简写为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item4</span>&#123;</span><br><span class="line">    <span class="attribute">gird-area</span>:<span class="number">3</span> / <span class="number">1</span> / span <span class="number">2</span> / span <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-单个项目中内容对齐方式"><a href="#3-单个项目中内容对齐方式" class="headerlink" title="3.单个项目中内容对齐方式"></a>3.单个项目中内容对齐方式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">justify-self: start | end | center | stretch;</span><br><span class="line">align-self: start | end | center | stretch;</span><br><span class="line"><span class="selector-tag">place-self</span>:&lt;<span class="selector-tag">align-self</span>&gt; &lt;<span class="selector-tag">justify-self</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>和容器中定义的<code>justify-items</code>那三个属性效果一致，唯一的区别就是，容器中定义的是所有的项目的对齐方式，而<code>xxx-self</code>是项目独自的对齐方式。</p>
<h2 id="七、计量单位"><a href="#七、计量单位" class="headerlink" title="七、计量单位"></a>七、计量单位</h2><h3 id="px"><a href="#px" class="headerlink" title="px"></a><code>px</code></h3><p>以像素数目为基准的绝对单位。</p>
<h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a><code>pt</code></h3><p>以物理尺寸”磅“为绝对单位，类似于word中的字体单位，一般12磅字相当于五号字。</p>
<h3 id="em"><a href="#em" class="headerlink" title="em"></a><code>em</code></h3><p><code>1em</code>表示相对于父元素的字体大小的一种相对单位。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a><code>rem</code></h3><p><code>1rem</code>表示根元素(<code>html</code>)的字体大小的一种相对单位。默认情况下，网页的字体大小是<code>16px</code>，所以默认下<code>1rem</code>为<code>16px</code>。更改根元素的字体大小：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">10px</span>;  <span class="comment">/*此时 1rem = 10px*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a><code>vw</code></h3><p>表示viewpoint width,视窗宽度。<code>1vw</code>代表视窗宽度的<code>1%</code>，是一种相对单位。</p>
<h3 id="vh"><a href="#vh" class="headerlink" title="vh"></a><code>vh</code></h3><p>表示viewpoint height 视窗高度。<code>1vh</code>代表视窗高度的<code>1%</code>，是一种相对单位。</p>
<h3 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a><code>vmax</code></h3><p><code>vmax</code>相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的<code>vmax</code>。</p>
<h3 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a><code>vmin</code></h3><p><code>vmin</code>相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的<code>vmin</code>。</p>
<h2 id="八、媒体查询"><a href="#八、媒体查询" class="headerlink" title="八、媒体查询"></a>八、媒体查询</h2><p>媒体查询就是对于不同的设备（以屏幕分辨率作为区分）使用一部分或者完全不同的css样式。</p>
<p>常见的默认种类有：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>所有媒体类型</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑屏幕，平板电脑，智能手机等</td>
</tr>
<tr>
<td>print</td>
<td>打印设备</td>
</tr>
<tr>
<td>speech</td>
<td>应用于屏幕阅读器等发声设备</td>
</tr>
</tbody></table>
<blockquote>
<p>注：tty, tv, projection, handheld, braille, embossed, aural 设备类型已经被废弃</p>
</blockquote>
<ul>
<li><p>可以使用 link 与 style 中定义媒体查询</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"screen.css"</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用 <code>@import url(screen.css) screen</code> 形式媒体使用的样式</p>
<p>使用<code>@import</code> 可以引入指定设备的样式规则。文件中引入一个样式文件，在这个文件中再引入其他媒体的样式文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>style.css</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import url(screen.css) screen;</span><br><span class="line">@import url(print.css) print;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用逗号分隔同时支持多个媒体设备</p>
</li>
<li><p>未指定媒体设备时等同于all</p>
</li>
<li><p>如果上述常见设备并不能解决需求，可以使用查询条件<code>@media</code>来进一步细分</p>
<p>例如横屏和最小宽度不得低于1000px的设备时，将根元素的字体大小设置为20px:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">1000px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">html</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>连接符与 and 、 或 or、 非 not</li>
<li>一些常见的条件：除了常见媒体名称，其余每个独立条件需要使用括号（）</li>
</ul>
<table>
<thead>
<tr>
<th align="left">媒体特性</th>
<th align="left">取值</th>
<th align="left">接受min/max</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">width</td>
<td align="left"><length></td>
<td align="left">yes</td>
<td align="left">定义输出设备中的页面可见区域宽度</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left"><length></td>
<td align="left">yes</td>
<td align="left">定义输出设备中的页面可见区域高度</td>
</tr>
<tr>
<td align="left">device-width</td>
<td align="left"><length></td>
<td align="left">yes</td>
<td align="left">定义输出设备的屏幕可见宽度</td>
</tr>
<tr>
<td align="left">device-height</td>
<td align="left"><length></td>
<td align="left">yes</td>
<td align="left">定义输出设备的屏幕可见高度</td>
</tr>
<tr>
<td align="left">orientation</td>
<td align="left">portrait | landscape</td>
<td align="left">no</td>
<td align="left">定义’height’是否大于或等于’width’。值portrait代表是，landscape代表否</td>
</tr>
<tr>
<td align="left">aspect-ratio</td>
<td align="left"><ratio></td>
<td align="left">yes</td>
<td align="left">定义’width’与’height’的比率</td>
</tr>
<tr>
<td align="left">device-aspect-ratio</td>
<td align="left"><ratio></td>
<td align="left">yes</td>
<td align="left">定义’device-width’与’device-height’的比率。如常见的显示器比率：4/3, 16/9, 16/10</td>
</tr>
<tr>
<td align="left">color</td>
<td align="left"><integer></td>
<td align="left">yes</td>
<td align="left">定义每一组输出设备的彩色原件个数。如果不是彩色设备，则值等于0</td>
</tr>
<tr>
<td align="left">color-index</td>
<td align="left"><integer></td>
<td align="left">yes</td>
<td align="left">定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0</td>
</tr>
<tr>
<td align="left">monochrome</td>
<td align="left"><integer></td>
<td align="left">yes</td>
<td align="left">定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0</td>
</tr>
<tr>
<td align="left">resolution</td>
<td align="left"><resolution></td>
<td align="left">yes</td>
<td align="left">定义设备的分辨率。如：96dpi, 300dpi, 118dpcm</td>
</tr>
<tr>
<td align="left">scan</td>
<td align="left">progressive | interlace</td>
<td align="left">no</td>
<td align="left">定义电视类设备的扫描工序</td>
</tr>
<tr>
<td align="left">grid</td>
<td align="left"><integer></td>
<td align="left">no</td>
<td align="left">用来查询输出设备是否使用栅格或点阵。只有1和0才是有效值，1代表是，0代表否</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios网络框架</title>
    <url>/2019/09/07/Axios%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="一、axios网络框架"><a href="#一、axios网络框架" class="headerlink" title="一、axios网络框架"></a>一、axios网络框架</h2><blockquote>
<ul>
<li>包含了对<code>XMLHttpRequest</code>浏览器的支持</li>
<li>能够在node.js环境中发起<code>http</code>请求</li>
<li>支持<code>Promise</code> API</li>
<li>支持拦截请求和响应</li>
<li>支持转换请求和响应数据</li>
<li>支持取消请求</li>
<li>支持自动转换JSON数据</li>
</ul>
</blockquote>
<p><code>axios</code>更适合在Vue框架中使用，如果使用<code>ajax</code>需要引用整个<code>jquery</code>，而一个<code>jquery</code>的大小都快抵上<code>Vue</code>框架的大小了，所以在<code>Vue</code>中使用<code>ajax</code>来发送网络请求并不合适。而使用原始的<code>XMLHttpRequest</code>来发送请求又过于繁琐了。所以更推荐<code>axios</code>。</p>
<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i axios -s</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="二、axios的使用"><a href="#二、axios的使用" class="headerlink" title="二、axios的使用"></a>二、axios的使用</h2><p><code>axios</code><strong>支持的请求方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(config)</span><br><span class="line"></span><br><span class="line">axios.request(config)</span><br><span class="line"></span><br><span class="line">axios.get(url[,config])</span><br><span class="line"></span><br><span class="line">axios.delete(url[,config])</span><br><span class="line"></span><br><span class="line">axios.head(url[,config])</span><br><span class="line"></span><br><span class="line">axios.post(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>

<h3 id="2-1-发送简单的网络请求"><a href="#2-1-发送简单的网络请求" class="headerlink" title="2.1 发送简单的网络请求"></a>2.1 发送简单的网络请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url:<span class="string">'xxxx'</span>,</span><br><span class="line">    method:<span class="string">'post'</span>  <span class="comment">//该项为可选，如无该项则默认为get请求</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>axios</code>都是经过<code>promise</code>对象封装的，所有可以大胆的使用<code>promise</code>的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url:<span class="string">'http://123.207.32.32:8000/api/v1/home/multidata'</span>,</span><br><span class="line">  method:<span class="string">'get'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-发送带query参数的请求"><a href="#2-2-发送带query参数的请求" class="headerlink" title="2.2 发送带query参数的请求"></a>2.2 发送带query参数的请求</h3><p>发送<code>http://123.207.32.32:8000/api/v1/home/data?type=sell&amp;page=1</code>这种带有query参数的请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url:<span class="string">'http://123.207.32.32:8000/api/v1/home/data'</span>,</span><br><span class="line">  params:&#123;</span><br><span class="line">      type:<span class="string">'sell'</span>,</span><br><span class="line">      page:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-发送并发请求"><a href="#2-3-发送并发请求" class="headerlink" title="2.3 发送并发请求"></a>2.3 发送并发请求</h3><p>当需要同时发送多个请求时，可以使用<code>all</code>方法，这个方法其实就是promise中的all方法，毕竟axios都是经过promise封装过的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">    axios(...),</span><br><span class="line">    axios(...)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(res)   <span class="comment">//[请求结果1，请求结果2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url:<span class="string">'http://123.207.32.32:8000/api/v1/home/multidata?callback=json123'</span>,</span><br><span class="line">    method:<span class="string">'get'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url:<span class="string">'http://123.207.32.32:8000/api/v1/home/data'</span>,</span><br><span class="line">    params:&#123;</span><br><span class="line">        type:<span class="string">'sell'</span>,</span><br><span class="line">        page:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[res1,res2]</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1,res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>关于then中返回的请求结果res，我是做了一个数组的解构。除此之外更推荐使用axios提供的方法来做</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.then(axios.spread(<span class="function">(<span class="params">res1,res2</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1,res2)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="2-4-全局配置"><a href="#2-4-全局配置" class="headerlink" title="2.4 全局配置"></a>2.4 全局配置</h3><p>axios为需要全局配置的属性提供了方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.default.xxx= xxx   <span class="comment">//为需要全局配置的属性赋值</span></span><br></pre></td></tr></table></figure>

<p>例如为全局的axios请求默认的请求时长设置为5秒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.default.timeout = <span class="number">5000</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5-常用的配置项"><a href="#2-5-常用的配置项" class="headerlink" title="2.5 常用的配置项"></a>2.5 常用的配置项</h3><ol>
<li><strong>请求地址</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url:<span class="string">'地址'</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>请求类型</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">method:<span class="string">''</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>请求根路径</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">baseURL:<span class="string">'根路径'</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>请求前的数据处理</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">transformRequest:[<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;&#125;]</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>请求后的数据处理</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">transformResponse:[<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;&#125;]</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>URL查询对象</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">params:&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>自定义的请求头</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers:&#123;<span class="string">'x-Requested-width'</span>:<span class="string">'XMLHttpRequest'</span>&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>查询对象序列化函数</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><strong>request body</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;<span class="attr">key</span>:value&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><strong>超时设置</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">timeout: <span class="number">1000</span>   <span class="comment">//ms</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li><strong>跨域是否带Token</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">withCredentials: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ol start="12">
<li><strong>自定义请求处理</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">adapter: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject, config</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li><strong>身份验证信息</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">auth: &#123; <span class="attr">uname</span>:<span class="string">''</span>,<span class="attr">pwd</span>: <span class="string">'12'</span>&#125;,</span><br></pre></td></tr></table></figure>

<ol start="14">
<li><strong>响应的数据格式json / blob /document /arraybuffer / text, stream</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">responseType: <span class="string">'json'</span></span><br></pre></td></tr></table></figure>

<h2 id="三、axios实例封装"><a href="#三、axios实例封装" class="headerlink" title="三、axios实例封装"></a>三、axios实例封装</h2><p>实际开发中,会遇到需要提供大量不同axios请求,且这些请求可能出现比较高的重复性,配置项只有一小部分不同,此时,我们可以将重复出现的不同请求抽离并封装起来</p>
<p>axios提供了实例封装方法<code>axios.create</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseConfig  <span class="comment">//抽离出来的公共配置项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用实例发起请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance(&#123;</span><br><span class="line">    Config <span class="comment">//特有配置项</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="3-1-请求实例独立封装"><a href="#3-1-请求实例独立封装" class="headerlink" title="3.1 请求实例独立封装"></a>3.1 请求实例独立封装</h3><p><strong>在文件中统一定义</strong></p>
<p>请求的实例的定义可以放在独立的文件中,以供调用，并且易于统一管理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">network</span><br><span class="line">    request.js</span><br></pre></td></tr></table></figure>

<p><strong>封装样例<code>request.js</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        baseURL:<span class="string">'http://123.207.32.32:8000'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用样例<code>main.js</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'./network/request'</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url:<span class="string">'/api/v1/home/data'</span>,</span><br><span class="line">  params:&#123;</span><br><span class="line">    type:<span class="string">'sell'</span>,</span><br><span class="line">    page:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors</span><br></pre></td></tr></table></figure>

<h3 id="4-1-请求拦截"><a href="#4-1-请求拦截" class="headerlink" title="4.1 请求拦截"></a>4.1 请求拦截</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<ul>
<li>比如<code>config</code>中的数据不符合服务器的要求</li>
<li>比如每次发送网络请求时，都希望在网页中加入等待图标</li>
<li>某些网络请求，例如<code>token</code>,必须携带一些特殊的信息</li>
</ul>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config)</span><br><span class="line">    <span class="keyword">return</span> config   <span class="comment">//一定要return config,否则请求将无法继续往下执行</span></span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-2-响应拦截"><a href="#4-2-响应拦截" class="headerlink" title="4.2 响应拦截"></a>4.2 响应拦截</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.response</span><br></pre></td></tr></table></figure>

<p>在完成响应时进行拦截</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加载成功'</span>)</span><br><span class="line">    <span class="keyword">return</span> config.data</span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>axios</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>VueX（Vue状态管理模式）</title>
    <url>/2019/09/03/VueX%EF%BC%88Vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、初识VueX"><a href="#一、初识VueX" class="headerlink" title="一、初识VueX"></a>一、初识VueX</h2><h3 id="1-1-关于VueX"><a href="#1-1-关于VueX" class="headerlink" title="1.1 关于VueX"></a>1.1 关于<code>VueX</code></h3><p><code>VueX</code>是适用于在<code>Vue</code>项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步<code>data</code>中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，<code>Vue</code>为这些被多个组件频繁使用的值提供了一个统一管理的工具——<code>VueX</code>。在具有<code>VueX</code>的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</p>
<a id="more"></a>

<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><p>由于<code>VueX</code>是在学习<code>VueCli</code>后进行的，所以在下文出现的项目的目录请参照<code>VueCli 2.x</code>构建的目录。</p>
<p>以下步骤的前提是你已经完成了Vue项目构建，并且已转至该项目的文件目录下。</p>
<ul>
<li><p>Npm安装Vuex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vuex -s</span><br></pre></td></tr></table></figure>
</li>
<li><p>在项目的根目录下新增一个<code>store</code>文件夹，在该文件夹内创建index.js</p>
<p>此时你的项目的<code>src</code>文件夹应当是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">│  App.vue</span><br><span class="line">│  main.js</span><br><span class="line">│</span><br><span class="line">├─assets</span><br><span class="line">│      logo.png</span><br><span class="line">│</span><br><span class="line">├─components</span><br><span class="line">│      HelloWorld.vue</span><br><span class="line">│</span><br><span class="line">├─router</span><br><span class="line">│      index.js</span><br><span class="line">│</span><br><span class="line">└─store</span><br><span class="line">       index.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h3><h4 id="1-3-1-初始化store下index-js中的内容"><a href="#1-3-1-初始化store下index-js中的内容" class="headerlink" title="1.3.1 初始化store下index.js中的内容"></a>1.3.1 初始化<code>store</code>下<code>index.js</code>中的内容</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建VueX对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-将store挂载到当前项目的Vue实例当中去"><a href="#1-3-2-将store挂载到当前项目的Vue实例当中去" class="headerlink" title="1.3.2 将store挂载到当前项目的Vue实例当中去"></a>1.3.2 将store挂载到当前项目的Vue实例当中去</h4><p>打开main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,  <span class="comment">//store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-在组件中使用Vuex"><a href="#1-3-3-在组件中使用Vuex" class="headerlink" title="1.3.3 在组件中使用Vuex"></a>1.3.3 在组件中使用Vuex</h4><p>例如在App.vue中，我们要将state中定义的name拿来在h1标签中显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        name:</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者要在组件方法中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...,</span><br><span class="line">methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$store.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>注意，请不要在此处更改<code>state</code>中的状态的值，后文中将会说明</strong></p>
<h3 id="1-4-安装Vue开发工具VueDevtools"><a href="#1-4-安装Vue开发工具VueDevtools" class="headerlink" title="1.4 安装Vue开发工具VueDevtools"></a>1.4 安装Vue开发工具VueDevtools</h3><p>在Vue项目开发中，需要监控项目中得各种值，为了提高效率，Vue提供了一款浏览器扩展——VueDevtools。</p>
<p><img src="https://s2.ax1x.com/2019/09/01/n9k3v9.png" alt=""></p>
<p>在学习VueX时，更为需要使用该插件。关于该插件的使用可以移步官网，在此不再赘叙。</p>
<h2 id="二、VueX中的核心内容"><a href="#二、VueX中的核心内容" class="headerlink" title="二、VueX中的核心内容"></a>二、VueX中的核心内容</h2><p>在VueX对象中，其实不止有<code>state</code>,还有用来操作<code>state</code>中数据的方法集，以及当我们需要对<code>state</code>中的数据需要加工的方法集等等成员。</p>
<p>成员列表：</p>
<ul>
<li>state     存放状态</li>
<li>mutations   state成员操作</li>
<li>getters     加工state成员给外界</li>
<li>actions     异步操作</li>
<li>modules   模块化状态管理</li>
</ul>
<h3 id="2-1-VueX的工作流程"><a href="#2-1-VueX的工作流程" class="headerlink" title="2.1 VueX的工作流程"></a>2.1 VueX的工作流程</h3><p><img src="https://vuex.vuejs.org/vuex.png" alt="Vuex官网给出的流程图"></p>
<p>首先，<code>Vue</code>组件如果调用某个<code>VueX</code>的方法过程中需要向后端请求时或者说出现异步操作时，需要<code>dispatch</code> VueX中<code>actions</code>的方法，以保证数据的同步。可以说，<code>action</code>的存在就是为了让<code>mutations</code>中的方法能在异步操作中起作用。</p>
<p>如果没有异步操作，那么我们就可以直接在组件内提交状态中的<code>Mutations</code>中自己编写的方法来达成对<code>state</code>成员的操作。注意，<code>1.3.3节</code>中有提到，不建议在组件中直接对<code>state</code>中的成员进行操作，这是因为直接修改(例如：<code>this.$store.state.name = &#39;hello&#39;</code>)的话不能被<code>VueDevtools</code>所监控到。</p>
<p>最后被修改后的state成员会被渲染到组件的原位置当中去。</p>
<h3 id="2-2-Mutations"><a href="#2-2-Mutations" class="headerlink" title="2.2 Mutations"></a>2.2 Mutations</h3><p><code>mutations</code>是操作<code>state</code>数据的方法的集合，比如对该数据的修改、增加、删除等等。</p>
<h4 id="2-2-1-Mutations使用方法"><a href="#2-2-1-Mutations使用方法" class="headerlink" title="2.2.1 Mutations使用方法"></a>2.2.1 Mutations使用方法</h4><p><code>mutations</code>方法都有默认的形参：</p>
<p>(<strong>[state]</strong> <strong>[,payload]</strong>)</p>
<ul>
<li><code>state</code>是当前<code>VueX</code>对象中的<code>state</code></li>
<li><code>payload</code>是该方法在被调用时传递参数使用的</li>
</ul>
<p>例如，我们编写一个方法，当被执行时，能把下例中的name值修改为<code>&quot;jack&quot;</code>,我们只需要这样做</p>
<p><code>index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        name:<span class="string">'helloVueX'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        <span class="comment">//es6语法，等同edit:funcion()&#123;...&#125;</span></span><br><span class="line">        edit(state)&#123;</span><br><span class="line">            state.name = <span class="string">'jack'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>而在组件中，我们需要这样去调用这个<code>mutation</code>——例如在App.vue的某个<code>method</code>中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-Mutation传值"><a href="#2-2-2-Mutation传值" class="headerlink" title="2.2.2 Mutation传值"></a>2.2.2 Mutation传值</h4><p>在实际生产过程中，会遇到需要在提交某个<code>mutation</code>时需要携带一些参数给方法使用。</p>
<p>单个值提交时:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>当需要多参提交时，推荐把他们放在一个对象中来提交:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'edit'</span>,&#123;<span class="attr">age</span>:<span class="number">15</span>,<span class="attr">sex</span>:<span class="string">'男'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>接收挂载的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">edit(state,payload)&#123;</span><br><span class="line">    state.name = <span class="string">'jack'</span></span><br><span class="line">    <span class="built_in">console</span>.log(payload) <span class="comment">// 15或&#123;age:15,sex:'男'&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一种提交方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">    type:<span class="string">'edit'</span>,</span><br><span class="line">    payload:&#123;</span><br><span class="line">        age:<span class="number">15</span>,</span><br><span class="line">        sex:<span class="string">'男'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-增删state中的成员"><a href="#2-2-3-增删state中的成员" class="headerlink" title="2.2.3 增删state中的成员"></a>2.2.3 增删state中的成员</h4><p>为了配合Vue的响应式数据，我们在Mutations的方法中，应当使用Vue提供的方法来进行操作。如果使用<code>delete</code>或者<code>xx.xx = xx</code>的形式去删或增，则Vue不能对数据进行实时响应。</p>
<ul>
<li><p>Vue.set 为某个对象设置成员的值，若不存在则新增</p>
<p>例如对state对象中添加一个age成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(state,<span class="string">"age"</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.delete 删除成员</p>
<p>将刚刚添加的age成员删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.delete(state,<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="2-3-Getters"><a href="#2-3-Getters" class="headerlink" title="2.3 Getters"></a>2.3 Getters</h3><p>可以对state中的成员加工后传递给外界</p>
<p>Getters中的方法有两个默认参数</p>
<ul>
<li>state 当前VueX对象中的状态对象</li>
<li>getters 当前getters对象，用于将getters下的其他getter拿来用</li>
</ul>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    nameInfo(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名:"</span>+state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    fullInfo(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.nameInfo+<span class="string">'年龄:'</span>+state.age</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.getters.fullInfo</span><br></pre></td></tr></table></figure>



<h3 id="2-4-Actions"><a href="#2-4-Actions" class="headerlink" title="2.4 Actions"></a>2.4 Actions</h3><p>由于直接在<code>mutation</code>方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交<code>mutation</code>方法。</p>
<p><code>Actions</code>中的方法有两个默认参数</p>
<ul>
<li><code>context</code> 上下文(相当于箭头函数中的this)对象</li>
<li><code>payload</code> 挂载参数</li>
</ul>
<p>例如，我们在两秒中后执行<code>2.2.2</code>节中的<code>edit</code>方法</p>
<p>由于<code>setTimeout</code>是异步操作，所以需要使用<code>actions</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">    aEdit(context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中调用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'aEdit'</span>,&#123;<span class="attr">age</span>:<span class="number">15</span>&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>改进:</strong></p>
<p>由于是异步操作，所以我们可以为我们的异步操作封装为一个<code>Promise</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">aEdit(context,payload)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        	context.commit(<span class="string">'edit'</span>,payload)</span><br><span class="line">        	resolve()</span><br><span class="line">    	&#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-Models"><a href="#2-5-Models" class="headerlink" title="2.5 Models"></a>2.5 Models</h3><p>当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 <code>state、mutation、action、getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;&#125;,</span><br><span class="line">        getters:&#123;&#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件内调用模块a的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.a</span><br></pre></td></tr></table></figure>

<p>而提交或者<code>dispatch</code>某个方法和以前一样,会自动执行所有模块内的对应<code>type</code>的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'editKey'</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'aEditKey'</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-5-1-模块的细节"><a href="#2-5-1-模块的细节" class="headerlink" title="2.5.1 模块的细节"></a>2.5.1 模块的细节</h4><ul>
<li><p>模块中<code>mutations</code>和<code>getters</code>中的方法接受的第一个参数是自身局部模块内部的<code>state</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;<span class="attr">key</span>:<span class="number">5</span>&#125;,</span><br><span class="line">        mutations:&#123;</span><br><span class="line">            editKey(state)&#123;</span><br><span class="line">                state.key = <span class="number">9</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>getters</code>中方法的第三个参数是根节点状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;<span class="attr">key</span>:<span class="number">5</span>&#125;,</span><br><span class="line">        getters:&#123;</span><br><span class="line">            getKeyCount(state,getter,rootState)&#123;</span><br><span class="line">                <span class="keyword">return</span>  rootState.key + state.key</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>actions</code>中方法获取局部模块状态是<code>context.state</code>,根节点状态是<code>context.rootState</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">models:&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        state:&#123;<span class="attr">key</span>:<span class="number">5</span>&#125;,</span><br><span class="line">        actions:&#123;</span><br><span class="line">            aEidtKey(context)&#123;</span><br><span class="line">                <span class="keyword">if</span>(context.state.key === context.rootState.key)&#123;</span><br><span class="line">                    context.commit(<span class="string">'editKey'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="三、规范目录结构"><a href="#三、规范目录结构" class="headerlink" title="三、规范目录结构"></a>三、规范目录结构</h2><p>如果把整个<code>store</code>都放在<code>index.js</code>中是不合理的，所以需要拆分。比较合适的目录格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">store:.</span><br><span class="line">│  actions.js</span><br><span class="line">│  getters.js</span><br><span class="line">│  index.js</span><br><span class="line">│  mutations.js</span><br><span class="line">│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入</span><br><span class="line">│</span><br><span class="line">└─modules</span><br><span class="line">        Astore.js</span><br></pre></td></tr></table></figure>



<p>对应的内容存放在对应的文件中，和以前一样，在<code>index.js</code>中存放并导出<code>store</code>。<code>state</code>中的数据尽量放在<code>index.js</code>中。而<code>modules</code>中的<code>Astore</code>局部模块状态如果多的话也可以进行细分。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>VueCli</tag>
        <tag>VueX</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Router路由构建</title>
    <url>/2019/08/10/Vue-Router%E8%B7%AF%E7%94%B1%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="一、前端路由和后端路由"><a href="#一、前端路由和后端路由" class="headerlink" title="一、前端路由和后端路由"></a>一、前端路由和后端路由</h2><h3 id="1-1-路由"><a href="#1-1-路由" class="headerlink" title="1.1 路由"></a>1.1 路由</h3><p>路由就是通过互联的网络把信息从源地址传输到目的地址的活动。在Web的路由中，最重要的就是有一个路由映射表。这个映射表能够完整的表现出映射关系，便于路由管理。</p>
<a id="more"></a>

<h3 id="1-2-后端路由"><a href="#1-2-后端路由" class="headerlink" title="1.2 后端路由"></a>1.2 后端路由</h3><p>有过服务端开发经验的Coder应该知道，在服务端开发中需要专门来写一个Router,其中包括了请求路径<code>/index</code>和请求方法比如<code>get/post</code>然后再写其对应的处理方法。</p>
<p>再后端渲染开发中，可以用这个图来简单描述。</p>
<p><img src="https://s2.ax1x.com/2019/08/09/eqkorT.png" alt=""></p>
<p>从这里可以看出，后端路由的工作就是处理一个URL对应一个页面数据的关系。</p>
<h3 id="1-3-前端路由"><a href="#1-3-前端路由" class="headerlink" title="1.3 前端路由"></a>1.3 前端路由</h3><p>在学习Vue当中，应该听过最多的词就是SPA(单页面富应用)。SPA的概念相信不需要我多说，就是在页面不跳转的情况下访问页面的各个功能，并且还有历史记录信息。</p>
<p>随着SPA的功能越来越多，我们必然需要有一个路由映射关系来便于管理。这就是我们所说的前端路由</p>
<p><img src="https://s2.ax1x.com/2019/08/09/eq3L28.png" alt=""></p>
<p>如图，客户端会把所有需要的数据都请求下来。但是并不是全部都显示，而是只显示一部分，所以前端路由需要提供一个URL和显示内容或者说组件的一个映射关系。</p>
<p>这是一个被模拟的一个完整的 URL，于是当 URL 改变时，页面不会重新加载。就是<code>Hash</code>或者H5的<code>history</code>来实现的。</p>
<h2 id="二、-Vue-Router初使用"><a href="#二、-Vue-Router初使用" class="headerlink" title="二、 Vue-Router初使用"></a>二、 Vue-Router初使用</h2><p>Vue也提供了一个前端路由管理包，就是<code>vue-router</code>。可以手动npm方式安装，但是为了方便，接下来的演示都在用<code>vueCli</code>构建后的项目中演示。</p>
<p>在使用<code>vueCli</code>构建项目时选择安装<code>vue-router</code></p>
<h3 id="2-1-配置路由"><a href="#2-1-配置路由" class="headerlink" title="2.1 配置路由"></a>2.1 配置路由</h3><p>在项目根目录下新建<code>router</code>目录，并在<code>router</code> 建立<code>index.js</code></p>
<ul>
<li><p>导入<code>vue</code>,<code>vue-router</code>包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>vue-router</code>挂载到<code>Vue</code>上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立路由关系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">	&#123;</span><br><span class="line">		path:<span class="string">''</span>,</span><br><span class="line">		redirect:<span class="string">'/home'</span>  <span class="comment">//若需要页面重定向</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path:<span class="string">'/home'</span>,</span><br><span class="line">		component:<span class="built_in">require</span>(<span class="string">'组件'</span>), <span class="comment">//建立标准路由对应组件(查看2.3了解)</span></span><br><span class="line">		childrens:[      <span class="comment">//若是使用嵌套路由</span></span><br><span class="line">			&#123;</span><br><span class="line">				path:<span class="string">'new'</span> <span class="comment">//无需加“/”,</span></span><br><span class="line">				component:<span class="built_in">require</span>(<span class="string">'组件'</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出路由对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> RouterVue(&#123;</span><br><span class="line">    routes:routes <span class="comment">//ES6下可以直接用routes</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-挂载路由"><a href="#2-2-挂载路由" class="headerlink" title="2.2 挂载路由"></a>2.2 挂载路由</h3><p>配置完路由，需要把路由挂载到Vue实例对象上才能生效，届时，整个Vue实例上的组件链上的组件都可以使用路由了。</p>
<ul>
<li><p><code>main.js</code> 下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>  <span class="comment">//自动执行/router/index.js</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,      <span class="comment">//挂载路由</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-使用路由"><a href="#2-3-使用路由" class="headerlink" title="2.3 使用路由"></a>2.3 使用路由</h3><p>通过以上两步，我们的前端路由已经准备就绪，映射关系也已经建立完成。接下来我们就是要来看看如何通过请求这个URL，来达到显示出对应的组件内容的目的。</p>
<p>在<code>template</code>中</p>
<ul>
<li>通过<code>router-link</code>标签来发送请求</li>
<li>通过<code>router-view</code>来显示对应的组件内容</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Vue-router<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to:</span>'/<span class="attr">home</span>/<span class="attr">news</span>' &gt;</span>新闻<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/home'</span> <span class="attr">tag</span>=<span class="string">'button'</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/about'</span> <span class="attr">replace</span>=<span class="string">""</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user/'+userID"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;path:'/profile',query:&#123;name:'mjk',age:18,sex:'男'&#125;&#125;"</span>&gt;</span>档案<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在最终的网页上，<code>router-link</code>标签会被默认处理为a标签，而<code>router-view</code>会被处理为在<code>routes</code>定义的对应路径的对应组间，如没有则为空。</p>
<h2 id="三、路由上的一些细节"><a href="#三、路由上的一些细节" class="headerlink" title="三、路由上的一些细节"></a>三、路由上的一些细节</h2><p>至此，我们已经可以完成一个最最基本的路由构建了。点击<code>router-link</code> 可以在<code>router-view</code>显示对应的<code>component</code>。但是在实际开发中，肯定不止那么点需求。</p>
<h3 id="3-1-关于VueRouter构造函数"><a href="#3-1-关于VueRouter构造函数" class="headerlink" title="3.1 关于VueRouter构造函数"></a>3.1 关于VueRouter构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">'history'</span>, <span class="comment">//路由模式从默认的Hash改为H5的history模式</span></span><br><span class="line">  linkActiveClass:<span class="string">'active'</span>   <span class="comment">//设置全局router-link被点击后的class</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p>
<p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p>
<h3 id="3-2-关于router-link"><a href="#3-2-关于router-link" class="headerlink" title="3.2 关于router-link"></a>3.2 关于<code>router-link</code></h3><p>在<code>router-link</code>上有一些属性，可以供我们使用</p>
<ul>
<li><p><code>replace</code></p>
<p>该属性是替换当前url,默认是Push。它可以不被赋任何值就能声明</p>
</li>
<li><p><code>tag</code> </p>
<p><code>router-link</code>最终默认会被处理为a标签，而使用该属性，可以设置被处理为其他标签。</p>
<p>如下，<code>router-link</code>会被处理为<code>button</code>标签，且为replace模式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/home'</span> <span class="attr">replace</span>=<span class="string">""</span> <span class="attr">tag</span>=<span class="string">'button'</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>active-class</code></p>
<p>当<code>router-link</code>被点击后，将会获得一个特殊的类—-<code>router-link-active</code>,当你不想使用类名时，就可以使用该属性，设置你的自定义类名。和在构造函数中设置<code>linkActiveClass</code>有所不同，一个是当前router-link,一个是全局的router-link</p>
</li>
<li><p><code>to</code></p>
<p>对于这个属性来说，它可以让你点击该router-link时跳转到指定的路径。实际上它就是执行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">to=<span class="string">'/home'</span>  <span class="comment">//对于这条语句来说就等于将会执行</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>)<span class="comment">//或者</span></span><br><span class="line"><span class="keyword">this</span>.$router.replace(<span class="string">'/home'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-3-关于传值"><a href="#3-3-关于传值" class="headerlink" title="3.3 关于传值"></a>3.3 关于传值</h3><p>在URL中，请求方是可以动态的传入一些数据，而接受方也可以接受到该值。并且不会影响路径的识别。</p>
<h4 id="3-3-1-params传值方式"><a href="#3-3-1-params传值方式" class="headerlink" title="3.3.1 params传值方式"></a>3.3.1 <code>params</code>传值方式</h4><ul>
<li><p>在路由中设置你的值名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path:<span class="string">'/home/:id'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home/123456"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收,在对应的/home组件中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure>
</li>
<li><p>URL形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/123456</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3-3-2-query传值方式"><a href="#3-3-2-query传值方式" class="headerlink" title="3.3.2 query传值方式"></a>3.3.2 <code>query</code>传值方式</h4><p>如果要传送一组键值对数据，可以使用query传值</p>
<ul>
<li><p>使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123;path:'/profile',query:&#123;name:'mjk',age:18,sex:'男'&#125;&#125;"</span>&gt;</span>档案<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.query.name</span><br><span class="line"><span class="keyword">this</span>.$route.query.age ....</span><br></pre></td></tr></table></figure>
</li>
<li><p>URL形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/profile?name=mjk&amp;age=18&amp;sex=男</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-4-Keep-Alive"><a href="#3-4-Keep-Alive" class="headerlink" title="3.4 Keep-Alive"></a>3.4 Keep-Alive</h3><p>在不断切换<code>router-view</code>中的组件过程中，实际上就是不断地创建和销毁经历过的组件。但是我们也许要使某些组件在被切换后不被销毁，这就需要使用<code>keep-alive</code>了，他能够让组件被保存到缓存中去。下次再使用这个组件时，我们只需要到缓存中去拿就可以了，不用再重新创建了。</p>
<ul>
<li><p>使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只对指定组件使用keep-alive</p>
<ul>
<li><code>include</code>只对某些属性使用<code>keep-alive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">'home,news'</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>exclude</code>不对某些属性使用<code>keep-alive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">'profile'</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配合<code>activated</code>和 <code>deactivated</code>钩子函数</p>
<p>在能使用<code>keep-alive</code>的组件中，这两个钩子函数在当被切换到该组件和该组件被切换时触发。</p>
</li>
</ul>
<h2 id="四、导航守卫"><a href="#四、导航守卫" class="headerlink" title="四、导航守卫"></a>四、导航守卫</h2><h3 id="4-1-关于导航守卫"><a href="#4-1-关于导航守卫" class="headerlink" title="4.1 关于导航守卫"></a>4.1 关于导航守卫</h3><p>导航守卫是关于路由状态的钩子函数</p>
<p>参数一般由<code>to,from,next</code>构成。</p>
<ul>
<li><p><code>to</code></p>
<p>要跳转到的<code>route</code>对象</p>
</li>
<li><p><code>from</code></p>
<p>当前的<code>route</code>对象，或者上一个<code>route</code>对象</p>
</li>
<li><p><code>next</code></p>
<p>你必须在你的函数体中加入<code>next()</code>以保证动作继续执行下去</p>
<p>参数</p>
<ul>
<li><p>next()默认</p>
</li>
<li><p>next(false)中断整个导航动作</p>
</li>
<li><p>next({path:’’}) 重定向到其他路径</p>
</li>
<li><p>next(err)抛出错误</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-定义导航守卫"><a href="#4-2-定义导航守卫" class="headerlink" title="4.2 定义导航守卫"></a>4.2 定义导航守卫</h3><p>导航守卫的钩子函数，可以定义为全局和组件个体的和路由独享的</p>
<ul>
<li><p>全局定义</p>
<p>在router目录下的<code>index.js</code>中，我们定义过一个<code>router</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>组件个体定义</p>
<p>在<code>router-view</code>可能被显示的组件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            path:<span class="string">'/home/news'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'create'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    activated()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$router.push(<span class="keyword">this</span>.path)</span><br><span class="line">    &#125;,</span><br><span class="line">     deactivated()&#123;</span><br><span class="line">         <span class="keyword">return</span>  <span class="keyword">this</span>.path = <span class="keyword">this</span>.$route.path</span><br><span class="line">     &#125;</span><br><span class="line">    beforeRouteLeave(to,<span class="keyword">from</span>,next)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(to,<span class="keyword">from</span>)</span><br><span class="line">        <span class="keyword">this</span>.path = <span class="keyword">this</span>.$route.path</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">4.3</span> 关于更多的钩子函数</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>路由独享守卫</p>
<p>在路由中定义，可以保证该导航下的嵌套路由都被守卫到</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attribute">path</span>:<span class="string">'/home'</span>,</span><br><span class="line">	component: home,</span><br><span class="line">	//路由独享守卫</span><br><span class="line">	beforeRouteLeave:(to,from,next)=&gt;&#123;</span><br><span class="line">		....</span><br><span class="line">		<span class="built_in">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-3-更多信息"><a href="#4-3-更多信息" class="headerlink" title="4.3 更多信息"></a>4.3 更多信息</h3><p>关于更多的导航守卫的钩子函数， 可以在<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">官网</a>中查询</p>
<h2 id="五、路由懒加载"><a href="#五、路由懒加载" class="headerlink" title="五、路由懒加载"></a>五、路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>格式 :<code>()=&gt;import(&#39;xxxx&#39;)</code></p>
<p>我们只需要将之前定义的<code>routes</code>稍作修改即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">	&#123;</span><br><span class="line">		path:<span class="string">''</span>,</span><br><span class="line">		redirect:<span class="string">'/home'</span>  <span class="comment">//若需要页面重定向</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path:<span class="string">'/home'</span>,</span><br><span class="line">        <span class="comment">//路由懒加载</span></span><br><span class="line">		component:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'xxx'</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>前端框架</tag>
        <tag>VueRouter</tag>
        <tag>Vue-Cli</tag>
      </tags>
  </entry>
  <entry>
    <title>VueCli构建工具</title>
    <url>/2019/08/07/VueCli%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、VueCli构建工具"><a href="#一、VueCli构建工具" class="headerlink" title="一、VueCli构建工具"></a>一、VueCli构建工具</h2><p>如果我们所有的项目都像原来那样配置，难免过于繁琐。所以Vue官方提供了一个构建工具——<code>VueCli</code>来快速构建一个工具 。他可以帮助我们快速安装webPack的插件、<code>loader</code>等等配套的包。以及帮我们自动化构建配置目录等等。</p>
<a id="more"></a>

<h2 id="二、VueCli-2-x"><a href="#二、VueCli-2-x" class="headerlink" title="二、VueCli 2.x"></a>二、VueCli 2.x</h2><p>虽然在2018年8月尤雨溪发布了<code>VueCli 3</code>，但是由于现在还有大量的项目都是通过2.x.x版本构建的。所以在此需要记录一下<code>VueCli 2</code>的一些特性。</p>
<ul>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @vue/cli -g</span><br></pre></td></tr></table></figure>

<p>虽然是3版本，如果想像2版本那样构建，需要使用他们提供的一个桥接工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @vue/cli-init -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建一个Vue项目(2版本)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue init webpack 项目名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要你选择一些关键项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">? Project name (test)   ##填写项目文件名称</span><br><span class="line"></span><br><span class="line">? Project description (A Vue.js project)  ## 填写项目介绍</span><br><span class="line"></span><br><span class="line">? Author MaoJacky &lt;34392872+JackyM06@users.noreply.github.com&gt;   ## 填写作者信息，默认读取全局git中的信息</span><br><span class="line"></span><br><span class="line">? Vue build  ## 选择一个构建方式，初学者建议选择第一个，后文有介绍这两种方式的区别</span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> Runtime + Compiler: recommended <span class="keyword">for</span> most users</span></span><br><span class="line">  	  Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere</span><br><span class="line">  </span><br><span class="line">? Install vue-router? (Y/n) n   ## 是否加载Vue-router</span><br><span class="line"></span><br><span class="line">? Use ESLint to lint your code? No   ## 是否使用一种js代码标准</span><br><span class="line"></span><br><span class="line">? Setup unit tests No   ##是否安装单元测试</span><br><span class="line"></span><br><span class="line">? Setup e2e tests with Nightwatch? (Y/n) n   ##是否安装端对端测试</span><br><span class="line"></span><br><span class="line">? Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys)   ##选择一种包管理工具</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Yes, use NPM</span></span><br><span class="line">  Yes, use Yarn</span><br><span class="line">  No, I will handle that myself</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成后的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">│  .babelrc</span><br><span class="line">│  .editorconfig</span><br><span class="line">│  .gitignore</span><br><span class="line">│  .postcssrc.js</span><br><span class="line">│  index.html</span><br><span class="line">│  package.json</span><br><span class="line">│  README.md</span><br><span class="line">│</span><br><span class="line">├─build</span><br><span class="line">│      build.js</span><br><span class="line">│      check-versions.js</span><br><span class="line">│      logo.png</span><br><span class="line">│      utils.js</span><br><span class="line">│      vue-loader.conf.js</span><br><span class="line">│      webpack.base.conf.js</span><br><span class="line">│      webpack.dev.conf.js</span><br><span class="line">│      webpack.prod.conf.js</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│      dev.env.js</span><br><span class="line">│      index.js</span><br><span class="line">│      prod.env.js</span><br><span class="line">│</span><br><span class="line">├─src</span><br><span class="line">│  │  App.vue</span><br><span class="line">│  │  main.js</span><br><span class="line">│  │</span><br><span class="line">│  ├─assets</span><br><span class="line">│  │      logo.png</span><br><span class="line">│  │</span><br><span class="line">│  └─components</span><br><span class="line">│          HelloWorld.vue</span><br><span class="line">│</span><br><span class="line">└─static</span><br><span class="line">        .gitkeep</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>构建完成😄</li>
</ul>
<h2 id="三、VueCli-3-x"><a href="#三、VueCli-3-x" class="headerlink" title="三、VueCli 3.x"></a>三、VueCli 3.x</h2><p><code>VueCli 3</code>在原来基础上，减去了<code>build</code>文件夹等等，修改<code>static</code>文件夹为<code>public</code>。官方的话来说就是0配置，那么就让我们来瞅一瞅怎么用的吧</p>
<p>因为上面我们已经安装过了，所以我们只需要换一种构建方式即可。</p>
<ul>
<li><p>构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create 项目名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择关键项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">? Please pick a preset: ##选择你的配置方案，一般选择手动</span><br><span class="line">  default (babel, eslint)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Manually select features</span></span><br><span class="line"></span><br><span class="line">? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) ##选择需要的关键项</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">(*) Babel</span></span><br><span class="line"> ( ) TypeScript</span><br><span class="line"> ( ) Progressive Web App (PWA) Support</span><br><span class="line"> ( ) Router</span><br><span class="line"> ( ) Vuex</span><br><span class="line"> ( ) CSS Pre-processors</span><br><span class="line"> (*) Linter / Formatter</span><br><span class="line"> ( ) Unit Testing</span><br><span class="line"> ( ) E2E Testing</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> ? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.?</span><br><span class="line"><span class="meta"> #</span><span class="bash"><span class="comment">#你要将的一些Babel配置信息保存到哪里，可以选择保存到Package.json，或自定义文件中去</span></span></span><br><span class="line"> </span><br><span class="line"> ? Save this as a preset for future projects? (y/N)y</span><br><span class="line"><span class="meta"> #</span><span class="bash"><span class="comment">#是否将你的这些配置信息保存下来，在未来能够使用</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注：如果要删除你所保存的个人配置信息项  ，你可以在C盘用户目录下的.vuerc文件中管理</strong></p>
<p><code>VueCli 3</code>开始,还提供了一个<code>vue ui</code>命令，可以让你在可视化工具上进行修改你的项目配置</p>
</li>
<li><p>文件目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">│  .browserslistrc</span><br><span class="line">│  .gitignore</span><br><span class="line">│  babel.config.js</span><br><span class="line">│  package-lock.json</span><br><span class="line">│  package.json</span><br><span class="line">│  postcss.config.js</span><br><span class="line">│  README.md</span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│      favicon.ico</span><br><span class="line">│      index.html</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    │  App.vue</span><br><span class="line">    │  main.js</span><br><span class="line">    │</span><br><span class="line">    ├─assets</span><br><span class="line">    │      logo.png</span><br><span class="line">    │</span><br><span class="line">    └─components</span><br><span class="line">            HelloWorld.vue</span><br></pre></td></tr></table></figure>

<p><strong>注意：VueCli3构建的默认是Runtime-only方式的，可以在可视化工具中修改</strong></p>
</li>
</ul>
<h2 id="四、关于Runtime方式的说明"><a href="#四、关于Runtime方式的说明" class="headerlink" title="四、关于Runtime方式的说明"></a>四、关于Runtime方式的说明</h2><h3 id="4-1-问题说明"><a href="#4-1-问题说明" class="headerlink" title="4.1 问题说明"></a>4.1 问题说明</h3><p>在<code>VueCli 2</code>中构建Vue项目时，有一个让你选择<code>runtime-compiler</code> or <code>runtime-only</code>。那这两者有什么区别呢？</p>
<p>先看一下分别使用两种方式构建的<code>main.js</code></p>
<ul>
<li><code>runtime-compiler</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>runtime-only</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span>=&gt;</span>h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>render使用方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 1.普通用法 createElement(标签名，&#123;属性&#125;，[内容或者嵌套使用createElement])</span></span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">    <span class="string">'h2'</span>,</span><br><span class="line">    &#123;<span class="attr">class</span>:<span class="string">'box'</span>&#125;,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'我是魔鬼'</span>,</span><br><span class="line">      createElement(<span class="string">'p'</span>,&#123;<span class="attr">class</span>:<span class="string">'pp'</span>&#125;,[<span class="string">'hello'</span>])</span><br><span class="line">    ])</span><br><span class="line"> <span class="comment">// 2.真正的用法 createElement(导入的组件)</span></span><br><span class="line">    <span class="keyword">return</span> createElement(App)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-两种方式的区别"><a href="#4-2-两种方式的区别" class="headerlink" title="4.2 两种方式的区别"></a>4.2 两种方式的区别</h3><p>显然，前者是用我们熟悉的方式引用的App组件，而后者是以<code>render</code>函数的方式出现。这到底是怎么回事呢？</p>
<p>我们首先需要看一下Vue程序的过程</p>
<p>首先将<code>template</code>解析为<code>ats</code>-抽象语法树，然后使用vue实例中的render方法将ats编译为虚拟节点，然后建立<code>vDom</code>-虚拟Dom树，最终把<code>vDom</code>转换为我们在浏览器上所能看到的<code>ui</code>。</p>
<p>简单来说就是：</p>
<p><code>template</code>-&gt; <code>ats</code>-&gt;<code>render</code>-&gt;<code>vDom</code>-&gt;<code>ui</code></p>
<p>那么,对于<code>runtime-compiler</code>方式来说，就是完整的用上述流程运行的。</p>
<p>而对于<code>runtime-only</code>来说，他是直接从<code>render</code>开始(<code>render</code>-&gt;<code>vDom</code>-&gt;<code>ui</code>)。显然这种方式的性能更高。</p>
<h3 id="4-3-最后的问题"><a href="#4-3-最后的问题" class="headerlink" title="4.3 最后的问题"></a>4.3 最后的问题</h3><p>也许各位也会有一个疑问，那再子组件中挂载其他子组件岂不是都需要用render方法来做了？</p>
<p>我们来看看App.vue的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>显然，在导出对象中我们并没有使用<code>render</code>方法来挂载子组件，这是为撒子呢🤔</p>
<p>看过我上一篇关于<code>webpack</code>的文章的童鞋应该知道，我们在使用webpack导入vue文件使安装了两个东西。</p>
<p>其中一个是为了支持.vue文件导入的<code>vue-loader</code>，还有一个是<code>vue-template-compiler</code>。而在VueCli构建中，这些它已经自动为我们安装了。</p>
<p>它能够在导出过程中将<code>template</code>编译为一个<code>ast</code>，我们只需要按原来的方式来挂载组件，最后形成一颗抽象语法树，在main.js中我们只需要使用<code>render</code>方法就可以。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>VueCli</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>WebPack打包工具</title>
    <url>/2019/08/06/WebPack%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、模块化开发"><a href="#一、模块化开发" class="headerlink" title="一、模块化开发"></a>一、模块化开发</h2><h3 id="1-1-关于模块化"><a href="#1-1-关于模块化" class="headerlink" title="1.1 关于模块化"></a>1.1 关于模块化</h3><p>模块化是现在Web前端开发的趋势，它可以解决以前Js多文件协同开发会出现的命名问题等等。</p>
<p>再模块化下，每一个Js文件都是独立的文件，每个独立的js文件可以导入和导出数据。</p>
<p>像在Node.js环境下用CommonJS开发流程一样，ES6也制定了一些关于模块化开发的标准以保证他们可以再浏览器上运行。</p>
<a id="more"></a>

<h3 id="1-2-ES6下的模块化"><a href="#1-2-ES6下的模块化" class="headerlink" title="1.2 ES6下的模块化"></a>1.2 ES6下的模块化</h3><p>在ES6制定的标准中，声明一个Js为模块化文件需要在该js文件在被HTML当中引用时加入<code>type = &quot;module&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"./src/test.js"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Js文件中导入一个js模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./src/test.js'</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">import</span> value <span class="keyword">from</span> <span class="string">'./src/test/js'</span></span><br></pre></td></tr></table></figure>

<p>导出模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    a:<span class="number">5</span>,</span><br><span class="line">    b:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、WebPack工具"><a href="#二、WebPack工具" class="headerlink" title="二、WebPack工具"></a>二、WebPack工具</h2><p>webpack是一个打包工具。何谓打包，就是将你的编写的模块化的Js文件联系起来，编译并压缩合成为能成被对应环境识别的文件。</p>
<p>现在主流的打包工具就是WebPack，配合前端框架来用简直开心。</p>
<h3 id="2-1-WebPack的安装"><a href="#2-1-WebPack的安装" class="headerlink" title="2.1 WebPack的安装"></a>2.1 WebPack的安装</h3><p>WebPack是基于Node.js环境运行的，所以使用npm即可完成下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i webpack@3.6.0 -g</span><br></pre></td></tr></table></figure>

<p><strong>现在最新版是4.x.x,但是因为3和4版本变化略大，为了便于学习，所以下载3.6.0版本。</strong></p>
<h3 id="2-2-WebPack打包JavaScript"><a href="#2-2-WebPack打包JavaScript" class="headerlink" title="2.2 WebPack打包JavaScript"></a>2.2 WebPack打包JavaScript</h3><p>webpack打包Js有好几种方法，最常用的是利用配置文件来打包。</p>
<h4 id="2-2-1-命令行打包"><a href="#2-2-1-命令行打包" class="headerlink" title="2.2.1 命令行打包"></a>2.2.1 命令行打包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack 入口模块 ./dist/bundle.js</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-配置文件打包"><a href="#2-2-2-配置文件打包" class="headerlink" title="2.2.2 配置文件打包"></a>2.2.2 配置文件打包</h4><p>很显然，我们并不想每次都利用命令行来打包。甚至于如果有多个入口和多个出口的话每次打包都过于麻烦。所以在4.x.x版本的webpack中上面的方法已经被摒弃。</p>
<p>在项目文件夹中新建一个<code>webpack.config.js</code>文件，作为webpack打包配置文件。</p>
<p>一个最基本的配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry=<span class="string">'入口'</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">    	path:<span class="string">'绝对路径'</span>,</span><br><span class="line">    	filename:<span class="string">'文件名'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-Loader预处理打包CSS"><a href="#2-3-Loader预处理打包CSS" class="headerlink" title="2.3 Loader预处理打包CSS"></a>2.3 Loader预处理打包CSS</h3><p><code>Webpack</code>本身只支持Js文件的打包，但是在实际开发中常常需要对css等等其他文件一并进行打包。所以<code>Webpack</code>有一个Loader扩展，使用对应的Loader就可以完成对css文件的打包。</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i style-loader css-loader -s-d</span><br></pre></td></tr></table></figure>



<ul>
<li>使用</li>
</ul>
<p>在配置文件导出对象中加入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你就可以使用<code>require(&#39;./css/main.css&#39;)</code>的方式来引用<code>css</code>文件了。最终我们仍然只需引用<code>bundle。js</code>一个文件再HTML中即可。</p>
<p>需要说明的是，<code>style-loader</code>是用于将css内容编译并挂载到Dom上，而<code>css-loader</code>只是负责使css文件能够通过模块化导入的方式导入到js文件当中。而且use数组中对多个<code>loader</code>的顺序有严格的要求。所以按照逻辑来说，应当是先<code>css-loader</code>再<code>style-loader</code>。但是webpack比较特殊，他是从右向左逐个使用<code>loader</code>。</p>
<h3 id="2-4-处理图片文件"><a href="#2-4-处理图片文件" class="headerlink" title="2.4 处理图片文件"></a>2.4 处理图片文件</h3><p>在Css中我们可能会使用到以url方式引用的图片文件，但是在打包过程中将无法识别图片，所以Loader拓展给出了解决方案。</p>
<ol>
<li><code>url-loader</code></li>
</ol>
<p>安装好<code>url-loader</code>后，写入以下规则即可完成对图片的打包。</p>
<p>其中，<code>limit</code>是一个阈值，如果图片文件小于该阈值，将使用<code>base64</code>的方式来将图片打包为一个字符串/</p>
<p>如果大于该阈值则自动调用<code>file-loader</code>来进行打包，如果未安装，则报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jpg|png|jpeg|gif)$/</span>,</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:<span class="string">'url-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:<span class="number">4192</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>file-loader</code></li>
</ol>
<p>安装后，再使用上面的代码则可以将大于阈值的图片打包，且生成文件名为32位哈希值存放在<code>/dist/</code>文件夹下。</p>
<p>在开发过程中，<code>html</code>页面可能并未放在dist目录下，所以可能存在引用图片URL路径问题。只需要在<code>webpack</code>配置文件中的<code>output</code>下加入<code>publicPath:&#39;/dist/&#39;</code>即可</p>
<p>如果还需要对打包后的图片存放到<code>dist</code>下的指定目录中，且对文件名有要求，则可以这样做</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jpg|png|jpeg|gif)$/</span>,</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:<span class="string">'url-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:<span class="number">4192</span>,</span><br><span class="line">                <span class="comment">//img/存放到dist下的img目录下</span></span><br><span class="line">                <span class="comment">//[name]原图片名称</span></span><br><span class="line">                <span class="comment">//[hash:8]默认为32位哈希值，过长，设置位8位</span></span><br><span class="line">                <span class="comment">//[ext]原图片文件名后缀</span></span><br><span class="line">                name:<span class="string">'img/[name].[hash:8].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Vue结合WebPack使用方案"><a href="#三、Vue结合WebPack使用方案" class="headerlink" title="三、Vue结合WebPack使用方案"></a>三、Vue结合WebPack使用方案</h2><p>Vue的组件化开发固然很强，但是代码写起来过于繁杂。所以在学习VueCli之前，先了解如何结合WebPack来组件化开发Vue项目</p>
<h3 id="3-1-Vue文件"><a href="#3-1-Vue文件" class="headerlink" title="3.1 Vue文件"></a>3.1 Vue文件</h3><p>建立<code>.vue</code>文件，我们可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;App&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message:&quot;hello adfasfdvue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">	h1&#123;</span><br><span class="line">  	  color: yellow</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-配置对应的Loader"><a href="#3-2-配置对应的Loader" class="headerlink" title="3.2 配置对应的Loader"></a>3.2 配置对应的Loader</h3><ul>
<li><p>安装</p>
<ol>
<li><code>vue-loader</code> 能够导入.vue文件</li>
<li><code>vue-template-compiler</code>能够识别处理<code>template</code>标签</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vue-loader@13.0.0 vue-template-compiler -s-d</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>webpack.config</code>的<code>rule</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use:[<span class="string">'vue-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载一个组件只需要</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'app.vue'</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="四、WebPack高级开发"><a href="#四、WebPack高级开发" class="headerlink" title="四、WebPack高级开发"></a>四、WebPack高级开发</h2><h3 id="4-1-Plugin插件"><a href="#4-1-Plugin插件" class="headerlink" title="4.1 Plugin插件"></a>4.1 Plugin插件</h3><p><code>Plugin</code>是webPack的扩展插件，webPack本身也自带了一些插件。</p>
<p><code>plugin</code>挂载在配置导出对象中的<code>plugins</code>数组内。</p>
<h4 id="4-1-2-版权声明"><a href="#4-1-2-版权声明" class="headerlink" title="4.1.2 版权声明"></a>4.1.2 版权声明</h4><p>在实际开发中需要在源码中写入你的版权和开源协议等等信息，可以使用webPack自带的<code>BannerPlugin</code>插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webPack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:<span class="string">'xxx'</span>,</span><br><span class="line">    ....,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webPack.BannerPlugin(<span class="string">'版权归MJK所有'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-生成打包目录下的-html"><a href="#4-1-2-生成打包目录下的-html" class="headerlink" title="4.1.2 生成打包目录下的.html"></a>4.1.2 生成打包目录下的<code>.html</code></h4><p>实际开发中，需要把在根目录下的<code>index.html</code>放到<code>dist</code>目录下，且自动引用打包后的出口文件。所以有一个可以使用原html模板的自动生成过去的插件<code>html-webpack-plugin</code></p>
<p>安装后的使用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">....</span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       <span class="comment">//可设置参数，我是以项目根目录下的index.html作为生成模板，</span></span><br><span class="line">     template:<span class="string">'index.html'</span>   </span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-压缩打包后的Js文件"><a href="#4-1-3-压缩打包后的Js文件" class="headerlink" title="4.1.3 压缩打包后的Js文件"></a>4.1.3 压缩打包后的Js文件</h4><p>最终发布项目时，需要将Js代码进行压缩。<code>uglifyjs-webpack-plugin</code>插件可以完成该功能</p>
<p>配置方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line">.....</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> UglifyJsWebpackPlugin()</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-webpack-dev-server"><a href="#4-2-webpack-dev-server" class="headerlink" title="4.2 webpack-dev-server"></a>4.2 <code>webpack-dev-server</code></h3><p>和<code>nodemon</code>、<code>live-server</code>这类工具一样，当项目文件发生改动时，就自动刷新。</p>
<p>安装后，在webpack的配置文件中进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry:<span class="string">'xxx'</span>,</span><br><span class="line">    ....,    </span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase:<span class="string">'./dist'</span>,  <span class="comment">//目标目录</span></span><br><span class="line">        inline:<span class="literal">true</span>,    <span class="comment">//实时刷新</span></span><br><span class="line"> 		port:<span class="number">3000</span> <span class="comment">//端口号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在项目文件中的<code>package.json</code>中的<code>scripts</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">...</span><br><span class="line">   <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在命令行中输入如下命令即可运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>



<h3 id="4-3-分离webpack配置文件"><a href="#4-3-分离webpack配置文件" class="headerlink" title="4.3 分离webpack配置文件"></a>4.3 分离webpack配置文件</h3><p>实际开发中，开发时和发布时需要执行不同的操作。此时我们不能一把把所有的配置文件都写在<code>webpack.config.js</code>中，而是需要进行分离。</p>
<p>安装能够合并webpack代码的工具——<code>webpack-meger</code></p>
<p><strong>Example</strong></p>
<p>建立<code>build</code>目录,建立以下文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">base.config.js //所有时候都要用到的配置文件</span><br><span class="line">build.config.js  //发布时需要使用</span><br><span class="line">dev.config.js    //开发时需要使用</span><br></pre></td></tr></table></figure>

<p><code>dev.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./base.config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(baseConfig,&#123;</span><br><span class="line">    <span class="comment">//开发时需要用</span></span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase:<span class="string">'./dist'</span>,</span><br><span class="line">        inline:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>build.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./base.config'</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyJsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(baseConfig,&#123;</span><br><span class="line">    <span class="comment">//发布时需要使用</span></span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> UglifyJsWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最后，修改下<code>package.json</code>中的脚本。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  ....,</span><br><span class="line">  "build": "webpack --config ./build/build.config.js",</span><br><span class="line">  "dev": "webpack-dev-server --open --config ./build/dev.config.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在<code>npm run build</code>和<code>npm run dev</code>命令下就会使用不同的配置文件。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>VueCli</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js框架</title>
    <url>/2019/08/06/Vue-js%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="一、关于Vue-js"><a href="#一、关于Vue-js" class="headerlink" title="一、关于Vue.js"></a>一、关于Vue.js</h2><blockquote>
<p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 –摘自官网</p>
</blockquote>
<p>总体来说作为一门前端框架，Vue.js本身可以<strong>最大程度减少用户操作Dom</strong>的工作</p>
<a id="more"></a>

<h2 id="二-、数据的双向绑定"><a href="#二-、数据的双向绑定" class="headerlink" title="二 、数据的双向绑定"></a>二 、数据的双向绑定</h2><p>Vue.js可以将简洁的模板语法来声明式的将数据渲染到页面中，且声明的数据是双向的。而且对于一些特殊的标签可以通过绑定元素特性。例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    姓氏：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span> = <span class="string">'firstname'</span>&gt;</span> </span><br><span class="line">    名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span> = <span class="string">'lastname'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;firstname+lastname&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,  <span class="comment">//绑定id=app的元素   </span></span></span><br><span class="line"><span class="actionscript">        data: &#123;     <span class="comment">//声明数据</span></span></span><br><span class="line"><span class="actionscript">            firstname:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            lastname:<span class="string">''</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>解释一下上例，功能：输入姓氏和名字来合成名字。</p>
<p>首先为两个Input绑定了v-model，因为数据是双向的，默认值为Vue构造函数中声明的“”，但是当修改文本框中的值时，<code>app.firstname</code>和<code>app.lastname</code>也会对应发生改变。</p>
<h2 id="三、-指令"><a href="#三、-指令" class="headerlink" title="三、 指令"></a>三、 指令</h2><p>在上例中使用的<code>v-model</code>就是一个指令，它可以用于绑定<code>&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;</code>、components标签的数据。指令一般都以<code>v-</code>开头。</p>
<h4 id="3-1-用v-on指令绑定监听"><a href="#3-1-用v-on指令绑定监听" class="headerlink" title="3.1 用v-on指令绑定监听"></a>3.1 用<code>v-on</code>指令绑定监听</h4><p>基本格式：（事件方法内容可以直接为Js语句也可以是方法名）简写格式为<code>@</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">v-on: 监听方式='事件方法'</span><br></pre></td></tr></table></figure>

<p>例如：功能：输入价格，可以利用按钮来增减数量，并显示价格。通过<code>v-on</code>指令来绑定<code>click</code>事件，</p>
<p>方法应当挂载在<code>methods</code>下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">'price'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        数量：<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">'jian'</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; number &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">'jia'</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; price*number &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            price:0,</span><br><span class="line">            number:0</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            jian:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                --<span class="keyword">this</span>.number</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            jia:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                ++<span class="keyword">this</span>.number</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-条件与循环"><a href="#3-2-条件与循环" class="headerlink" title="3.2 条件与循环"></a>3.2 条件与循环</h4><ul>
<li><p><code>v-if</code>作为条件指令，在引号内，值可以为绑定的数据，也可以直接填写<code>true</code> 或 <code>false</code>,</p>
<p>当然还包括<code>v-else</code>和<code>v-else-if</code>进行配套使用</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app3"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">'true'</span>&gt;</span>NiKon<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">'nonSeen'</span>&gt;</span>Canen<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app3"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        nonSeen: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果：NiKon Canen</p>
<ul>
<li>v-for<code>作为循环指令。在要要遍历的标签中绑定该指令，值的格式为</code>‘xx[,index] in xxs’`</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'todo,index in todos'</span>&gt;</span></span><br><span class="line">            &#123;&#123; index+'·'+todo.text &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app4'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        todos:[</span><br><span class="line">            &#123;</span><br><span class="line">                index:<span class="number">1</span>,</span><br><span class="line">                text:<span class="string">'wowo'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                index:<span class="number">2</span>,</span><br><span class="line">                text:<span class="string">'wowo'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                index:<span class="number">3</span>,</span><br><span class="line">                text:<span class="string">'wowo'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>0·wowo </p>
<p>1·wowo </p>
<p>2·wowo</p>
<h4 id="3-3-v-model指令"><a href="#3-3-v-model指令" class="headerlink" title="3.3 v-model指令"></a>3.3 v-model指令</h4><p>用于作为表单控件的双向绑定的指令，格式：<code>v-model=&quot;xxx&quot;</code></p>
<h4 id="3-4-v-bind属性渲染指令"><a href="#3-4-v-bind属性渲染指令" class="headerlink" title="3.4 v-bind属性渲染指令"></a>3.4 v-bind属性渲染指令</h4><p>对于原有的HTML标签属性可以通过<code>v-bind</code>来渲染，为单向数据绑定。简写格式为<code>:</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-bind:</span> <span class="attr">value</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">或者</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:class</span>=<span class="string">"&#123;xxx:true of false&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-v-once只渲染一次指令"><a href="#3-5-v-once只渲染一次指令" class="headerlink" title="3.5 v-once只渲染一次指令"></a>3.5 v-once只渲染一次指令</h4><p>数据不再绑定，仅在在第一次加载页面时进行渲染。</p>
<h4 id="3-6-v-text和v-cloak指令"><a href="#3-6-v-text和v-cloak指令" class="headerlink" title="3.6 v-text和v-cloak指令"></a>3.6 v-text和v-cloak指令</h4><p>在vue管理的模板入口节点作用<code>v-cloak</code></p>
<p>这两条指令是为了解决模板语法在页面加载时会出现页面抖动。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"message"</span> &gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">display</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般<code>v-text</code>使用较少</p>
<h4 id="3-7-v-show显示标签指令"><a href="#3-7-v-show显示标签指令" class="headerlink" title="3.7 v-show显示标签指令"></a>3.7 v-show显示标签指令</h4><p>这条指令是在渲染层上将改标签隐藏。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"false"</span>&gt;</span>hehe<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和<code>v-if</code>不同的是，该指令是将改标签的样式设置为<code>display: none</code>,而<code>v-if</code>是直接将该标签从Dom树中移除。</p>
<h4 id="3-8-v-pre跳过编译指令"><a href="#3-8-v-pre跳过编译指令" class="headerlink" title="3.8 v-pre跳过编译指令"></a>3.8 v-pre跳过编译指令</h4><p>跳过不需要Vue编译的节点和其子节点，显示其原始内容。可以加快编译。😂</p>
<h2 id="四、-自定义指令"><a href="#四、-自定义指令" class="headerlink" title="四、 自定义指令"></a>四、 自定义指令</h2><p>如果到了不得不自己去操作Dom元素时，且没有Vue内置指令来实现需求时。可以使用自定义指令来解决需求。</p>
<h4 id="4-1-定义自定义指令"><a href="#4-1-定义自定义指令" class="headerlink" title="4.1 定义自定义指令"></a>4.1 定义自定义指令</h4><p>自定义指令分为全局和局部，即可以定义为在所有组件下都可以使用的自定义指令，也可以定义为只能在当前组件下使用的自定义指令。</p>
<h5 id="4-1-1-全局自定义指令"><a href="#4-1-1-全局自定义指令" class="headerlink" title="4.1.1 全局自定义指令"></a>4.1.1 全局自定义指令</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'指令名'</span>,&#123;</span><br><span class="line">    钩子函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="4-1-2-局部自定义指令"><a href="#4-1-2-局部自定义指令" class="headerlink" title="4.1.2 局部自定义指令"></a>4.1.2 局部自定义指令</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    directives:&#123;</span><br><span class="line">    	指令名:&#123;</span><br><span class="line">    		钩子函数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-钩子函数"><a href="#4-2-钩子函数" class="headerlink" title="4.2 钩子函数"></a>4.2 钩子函数</h4><p>钩子函数就是当自定义指令在何时出发什么样的动作</p>
<p>形式都为<code>钩子名:function([el[,binding]])</code></p>
<p>其中，<code>el</code>是当前绑定指令的Dom元素，而binding是指令对象其中<code>value</code>属性包含了指令被赋的值。</p>
<p>Vue官方文档中给出的钩子函数有5个：</p>
<ul>
<li><code>bind</code>  -在指令被绑定时执行一次，无法读取被绑定的Dom元素的父节点<code>el.parentNode</code></li>
<li><code>inserted</code>   -和bind一样是在指令被绑定时执行一次，但是在<code>bind</code>后面执行。并且可以读取被绑定的Dom元素的父节点</li>
<li><code>update</code>   -当指令所在的被Vue管理的整个模板更新时执行，binding.value是更新后的值</li>
<li><code>componendUpdated</code>  -和update一样，但是binding.value是更新前的值</li>
<li><code>unbind</code>  -当指令被解绑时执行，例如清除定时器（移除Dom时自动解绑）</li>
</ul>
<h4 id="4-3-复现一个v-show"><a href="#4-3-复现一个v-show" class="headerlink" title="4.3 复现一个v-show"></a>4.3 复现一个<code>v-show</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-focus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px ;background-color:#005151"</span> <span class="attr">v-myshow</span> = <span class="string">"show"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="4-3-1-全局定义方式"><a href="#4-3-1-全局定义方式" class="headerlink" title="4.3.1 全局定义方式"></a>4.3.1 全局定义方式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'myshow'</span>,&#123;</span><br><span class="line">    bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(binding.value)&#123;</span><br><span class="line">            el.style.display = <span class="string">"block"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            el.style = <span class="string">"none"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// inserted:function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log("inserted  is  called")</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    update:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(binding.value)&#123;</span><br><span class="line">            el.style.display = <span class="string">"block"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            el.style.display= <span class="string">"none"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// componentUpdated:function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log("componentUpdated  is  called")</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// unbind:function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log("unbind  is  called")</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>大多数情况都是bind &amp; update钩子函数配合使用的比较多，且大多情况下两者的代码是一样的，所以可以使用简写方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'myshow'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(binding.value)&#123;</span><br><span class="line">            el.style.display = <span class="string">"block"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            el.style.display= <span class="string">"none"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="4-3-2-局部定义"><a href="#4-3-2-局部定义" class="headerlink" title="4.3.2 局部定义"></a>4.3.2 局部定义</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        show: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">        myshow:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(binding.value)&#123;</span><br><span class="line">            el.style.display = <span class="string">"block"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            el.style.display= <span class="string">"none"</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、-计算属性和侦听器"><a href="#五、-计算属性和侦听器" class="headerlink" title="五、 计算属性和侦听器"></a>五、 计算属性和侦听器</h2><h4 id="5-1-计算属性computed"><a href="#5-1-计算属性computed" class="headerlink" title="5.1 计算属性computed"></a>5.1 计算属性<code>computed</code></h4><p>计算属性要在<code>computed</code>对象中定义。</p>
<p>计算属性的本质就是方法，在使用时就像<code>data</code>中定义的属性那样去使用。</p>
<p>每一个计算属性都必须有一个getter，还可以根据需求来加入一个setter。</p>
<ol>
<li>只包含getter的计算属性的一般使用方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	remaingCount:&#123;</span><br><span class="line">		<span class="keyword">get</span>()&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">this</span>.todoList.filter(<span class="function"><span class="params">item</span>=&gt;</span>!item.completed).length || <span class="number">0</span></span><br><span class="line">              &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于只包含getter的计算属性还有一种简写方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	remaingCount()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.todoList.filter(<span class="function"><span class="params">item</span>=&gt;</span>!item.completed).length || <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同时存在getter和setter的标准计算属性定义方式</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	toggleAll:&#123;</span><br><span class="line">		<span class="keyword">get</span>()&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.todoList.every(<span class="function"><span class="params">item</span> =&gt;</span> item.completed)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">set</span>([value])&#123;</span><br><span class="line">			<span class="keyword">let</span> boolean = !<span class="keyword">this</span>.toggleAll</span><br><span class="line">			<span class="keyword">this</span>.todoList.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">				element.completed = boolean</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-侦听器watch"><a href="#5-2-侦听器watch" class="headerlink" title="5.2 侦听器watch"></a>5.2 侦听器<code>watch</code></h4><p>侦听器要在<code>watch</code>对象中定义。</p>
<p>侦听器的作用是每当侦听对象发生改变时就作出反应。</p>
<p>同情况下计算属性要比侦听器合适，但是还有一些自定义业务需求需要使用侦听器。</p>
<ul>
<li><code>hanlder:function(val,oldval)</code> 是在触发监听对象时去执行的那个自己定义的方法</li>
<li><code>deep:boolean</code> 当监听对象为一个引用类型的对象时，只能监听到对象整体，无法监听到对象内的个体。当设置为true时即可同时监听到对象内的个体。</li>
<li><code>immediate:boolean</code> 在监听开始前就会调用该监听器下的<code>hanlder</code>方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">	todoList:&#123;</span><br><span class="line">		handler(val,oldVal)&#123;</span><br><span class="line">			<span class="built_in">window</span>.localStorage.setItem(<span class="string">"todoList"</span>,<span class="built_in">JSON</span>.stringify(val))</span><br><span class="line">		&#125;,</span><br><span class="line">		deep: <span class="literal">true</span>  <span class="comment">//深度监听</span></span><br><span class="line">	&#125;,</span><br><span class="line">          <span class="comment">//只包含handler时的简写方法</span></span><br><span class="line">	toggleAll()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'计算属性也可以被监听哦'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="六、-组件"><a href="#六、-组件" class="headerlink" title="六、 组件"></a>六、 组件</h2><p>Vue中，可以将单独功能的模块可以拆分为一个一个的组件。一个项目的组件构成通常为一个树形结构。一个典型的TodoMVC案例可以拆封为这样一个组件示例图：</p>
<p><img src="http://imglf3.nosdn0.126.net/img/LzV5U2MxM2hkNnpRZjh5QUFncnUxREtqK1ZLR1YwaDNLWDYrQzdqMHFmTDlIZEFJZFhSdHRRPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0" alt=""></p>
<h4 id="6-0-组件的使用方式"><a href="#6-0-组件的使用方式" class="headerlink" title="6.0 组件的使用方式"></a>6.0 组件的使用方式</h4><p>定义好的属性，只需要像使用html标签一样使用，只不过把标签名换为组建名就可以了</p>
<h4 id="6-1-组件定义方式"><a href="#6-1-组件定义方式" class="headerlink" title="6.1 组件定义方式"></a>6.1 组件定义方式</h4><p>组件定义方式和自定义指令一样，有全局和局部之分。</p>
<ul>
<li>全局定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'myComponent'</span>,&#123;</span><br><span class="line">    template:<span class="string">`&lt;p&gt;hello&lt;/p&gt;`</span>,</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ul>
<li>局部定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    template:<span class="string">`&lt;app&gt;&lt;/app&gt;`</span></span><br><span class="line">    components:&#123;</span><br><span class="line">		app:&#123;</span><br><span class="line">    		template = <span class="string">`&lt;header&gt;&lt;/header&gt; .. `</span>,</span><br><span class="line">    		components:&#123;</span><br><span class="line">            header:&#123;</span><br><span class="line">             template:<span class="string">`&lt;p&gt;hello i am header&lt;/p&gt;`</span>,</span><br><span class="line">   			 data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    			    <span class="keyword">return</span> &#123;</span><br><span class="line">      				      ...,</span><br><span class="line">        			    ...</span><br><span class="line">        			&#125;</span><br><span class="line">    			&#125;，</span><br><span class="line">        	    <span class="comment">//当然组件中也可以放子组件</span></span><br><span class="line">        	    components:&#123;</span><br><span class="line">         	       ....</span><br><span class="line">          	  &#125;</span><br><span class="line">        	&#125;,</span><br><span class="line">        	...其他组件</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在Vue根实例中创建的这些组件的父子节点可能不同，但是他们的根组件都是这个Vue实例。因为这个Vue实例本身也是一个组件。</p>
<h4 id="6-2-组件间的通信"><a href="#6-2-组件间的通信" class="headerlink" title="6.2 组件间的通信"></a>6.2 组件间的通信</h4><h5 id="6-2-1-直接父子通信"><a href="#6-2-1-直接父子通信" class="headerlink" title="6.2.1 直接父子通信"></a>6.2.1 直接父子通信</h5><ul>
<li><strong>父传子通信（<code>prop down</code>）：</strong></li>
</ul>
<p>要将父组件中的属性值传送给其子组件</p>
<ol>
<li><p>需要在父组件中的模板中调用子组件的部分加上v-bind属性(如传送name属性给其子组件son)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Father = &#123;</span><br><span class="line">    template: <span class="string">`&lt;son v-bind:name="name"&gt;&lt;/son&gt;`</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name:<span class="string">"jack"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componends:&#123;</span><br><span class="line">    	son</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子组件体中，使用<code>props</code>数组属性将name接收过来，之后就可以像自己的data定义的属性一样去用了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    template:<span class="string">`&lt;p&gt; my father is &#123;&#123; name &#125;&#125;&lt;/p&gt;`</span>,</span><br><span class="line">    props:[<span class="string">"name"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意：Vue不允许在子组件去修改基本类型的*父组件传过来的值。但是很不幸。因为传过来的数据如果是引用l类型的话，你可以修改成功，且不会报错，但是请不要这样去做！，如有子元素要修改穿过来的值的需求，请使用子传夫通信方法</strong></p>
<ul>
<li><strong>子传父通信(<code>Event up</code>)</strong></li>
</ul>
<p>父组件的值就要在父组件中进行，所以子组件可以把修改好的父组件数据整一个副本(不要修改原数据)，然后通过订阅事件的方法来传给父组件。</p>
<ol>
<li><p>再子组件的方法中生成数据副本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    template:<span class="string">`&lt;button @click = "handleUpdateName"&gt; my father is &#123;&#123; name &#125;&#125;&lt;/button&gt;`</span>,</span><br><span class="line">    props:[<span class="string">"name"</span>],</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleUpateName()&#123;</span><br><span class="line">            <span class="keyword">let</span> value = <span class="string">'maojiankai'</span></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'UpdatedName'</span>,value) <span class="comment">// 向父组件提交UpdatedName事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在父组件中订阅对应事件并处理数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Father = &#123;</span><br><span class="line">    template: <span class="string">`&lt;son v-bind:name="name" @UpatedName="handleName"&gt;&lt;/son&gt;`</span>, <span class="comment">//订阅UpdatedName事件</span></span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name:<span class="string">"jack"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    componends:&#123;</span><br><span class="line">    	son</span><br><span class="line">	&#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleName(name)&#123; <span class="comment">//对应的处理</span></span><br><span class="line">            <span class="keyword">this</span>.name = name </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>非父子关系的组件通信</p>
<ul>
<li>简单环境中 <code>Event Bus</code></li>
</ul>
<ol>
<li>设组件a,b非父子关系但他们同属于一个Vue根实例，所以在Vue的根实例之前创建一个名字为<code>bus</code>的空Vue实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在组件A中向bus提交自定义事件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bus.$emit(<span class="string">'Edited'</span>,value)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在组件B的创建钩子函数中，订阅bus中组件A提交的事件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bus.$on(<span class="string">'Edited'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂环境中 <code>VueX</code>（状态管理模式)</li>
</ul>
</li>
</ul>
<h2 id="七、插槽"><a href="#七、插槽" class="headerlink" title="七、插槽"></a>七、插槽</h2><h4 id="7-1-关于插槽solt"><a href="#7-1-关于插槽solt" class="headerlink" title="7.1 关于插槽solt"></a>7.1 关于插槽<code>solt</code></h4><p>在父组件调用子组件时，会使用子组件的模板HTML内容，但是如果父组件想要加入一些自己的内容到使用子组件的的模板HTML内容可能就是个问题了，尤其是当父组件多次引用子组件时，想要加入不同得内容到子组件模板当中去。</p>
<p>为此，Vue提供了一个插槽—<code>slot</code>标签。在子组件得<code>template</code>中加入一个<code>slot</code>标签后，父组件只需在引用子组件的标签内加入自己想加入的内容即可。</p>
<p>需要说明的是，如果想要插槽具有默认的内容，只需要在加入的<code>slot</code>标签内添加你需要的标签即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cnp</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>hehe<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cnp</span>&gt;</span><span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cnp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> &gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        cnp:&#123;</span><br><span class="line">            template:<span class="string">'#cnp'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="7-2-具名插槽"><a href="#7-2-具名插槽" class="headerlink" title="7.2 具名插槽"></a>7.2 具名插槽</h4><p>如果子组件存在多个不同的插槽,当你在调用时只想改动其中的一小部分插槽，其他的插槽都保留其原始值时,就需要用到Vue提供的具名插槽了。</p>
<p>具名插槽的定义是在插槽的<code>name</code>属性上设置插槽的名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>left<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>center<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>right<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>defalut<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具名插槽的使用需要在先使用设置了<code>v-slot:name</code>指令的<code>template</code>标签包裹要改动的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cnp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:center</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> &gt;</span>123<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cnp</span>&gt;</span><span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="7-3-作用域插槽"><a href="#7-3-作用域插槽" class="headerlink" title="7.3 作用域插槽"></a>7.3 作用域插槽</h4><p>首先是Vue的编译作用域。</p>
<p>摘自Vue官网:<strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p>
<p>其实很意思很简单，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cnp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-show</span>=<span class="string">'show'</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">'cnp'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是模板<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-show</span>=<span class="string">'show'</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 入口Vue实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            cnp:&#123;</span><br><span class="line"><span class="actionscript">                template:<span class="string">'#cnp'</span>,</span></span><br><span class="line">                data()&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                        show:<span class="literal">true</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过不断调试Vue实例和组件<code>cnp</code>中的show，可以看出。模板<code>tempate</code>属于组件<code>cnp</code>，所以模板中的show是组件<code>cnp</code>中的show，而在实际调用中的show是属于Vue实例中的show。</p>
<p>这说明Vue的是具有编译作用域的，且父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
<p>虽然Vue的编译作用域是合理且安全的。但是影响到了一种插槽需求，就是当引用该子组件时，需要用到一些将子组件的一些数据以不同的形式在组件的插槽内显示。</p>
<p>所以，Vue提供了作用域插槽。</p>
<p>定义<code>v-bind:属性名=&#39;表达式&#39;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cnp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个随意名称的属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">'pLanguages'</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>v-solt:name或者default=&#39;数据名&#39;</code> (name是具名时用于替换指定插槽，default是默认插槽)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">cnp</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 完整的 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">'slot'</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; slot.data.join(' - ') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果像上例一样使用的是默认插槽，还可以使用简写方式</p>
<p><strong>简写时请勿与具名插槽混用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">cnp</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 简写的 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">'slot'</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; slot.data.join(' - ') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果是多个插槽，则需要使用完整的使用格式。</p>
<p><strong>Example</strong></p>
<p>比如现在要来实现将子组件中提供的编程语言数组在插槽中以两种不同形式显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cnp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">'slot'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; slot.data.join(' - ') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cnp</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">'slot'</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; slot.data.join(' * ') &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cnp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cnp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">'pLanguages'</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        components:&#123;</span><br><span class="line">            cnp:&#123;</span><br><span class="line"><span class="actionscript">                template:<span class="string">'#cnp'</span>,</span></span><br><span class="line">                data()&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                        pLanguages:[<span class="string">'Java'</span>,<span class="string">'C++'</span>,<span class="string">'JavaScript'</span>,<span class="string">'Python'</span>,<span class="string">'Php'</span>]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript异步编程</title>
    <url>/2019/07/20/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、回调函数"><a href="#一、回调函数" class="headerlink" title="一、回调函数"></a>一、回调函数</h2><p>为了实现JS中的异步操作，主要的解决方案就是利用回调函数的方法</p>
<p>回调函数是先调用，后定义的方式使用的。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d1</span>(<span class="params">interval,callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        callback(<span class="string">'hello world'</span>)</span><br><span class="line">    &#125;,interval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d1(<span class="number">1000</span>,data=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h2 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h2><p><code>Promise</code>是ES6封装的对象,<code>Promise</code>对象可以化解回调地狱<code>callback hell</code>的情况。</p>
<p><code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<p>一般用<code>resolve</code>来表示<code>fulfilled</code></p>
<h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    异步方法</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>构造函数中的函数参数会立即开始执行。也就是说，构造Promise时，异步方法就会开始执行。</li>
<li>resolve,reject是两个回调方法</li>
</ul>
<h4 id="2-then"><a href="#2-then" class="headerlink" title="2.then"></a>2.then</h4><p>最重要的API(then)。then是当构造函数中异步方法执行完毕后，才会执行的方法。then中的第一个参数就是构造函数中resolve的回调，第二个参数就是构造函数中的reject的回调：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-then的链式调用"><a href="#3-then的链式调用" class="headerlink" title="3.then的链式调用"></a>3.then的链式调用</h4><p>then可以链式调用，并且可以解决回调地域的问题。如果then中resolve的回调中有retuen Promise1对象，则当前then执行后返回一个Promise1对象。如：</p>
<p>封装一个fs模块下的readFileAPI:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pFileR=<span class="function">(<span class="params">FilePath</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(FilePath,<span class="string">'utf8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pFileR(<span class="string">'./a.txt'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pFileR(<span class="string">'./b.txt'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pFileR(<span class="string">'./c.txt'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景"></a>4.应用场景</h4><p>建立一个表单，给定用户名，得到该用户的年龄，和所有的工作信息，其中默认选择的是该用户选择的工作。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    User:[</span><br><span class="line">      	id:Number,</span><br><span class="line">      	name:String,</span><br><span class="line">        job:Number</span><br><span class="line">    ],</span><br><span class="line">    Jobs:[</span><br><span class="line">        id:Number,</span><br><span class="line">        name:String</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，我们要先根据ID请求对应User的完整数据，然后请求所有的工作信息，根据User下job的id,设置选中的工作。所以我们要先请求User,再请求Jobs。</p>
<p>安装：</p>
<ul>
<li><code>json-server</code></li>
<li><code>http-server</code></li>
<li><code>jquery</code></li>
<li><code>art-template</code></li>
</ul>
<p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"user_form"</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; user.name &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; user.age &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>职业<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    </span><span class="template-variable">&#123;&#123; <span class="builtin-name">each</span> jobs &#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    </span><span class="template-variable">&#123;&#123; <span class="builtin-name">if</span> user.id === $value.id &#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; $value.id &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">selected</span>&gt;</span></span><span class="template-variable">&#123;&#123; $value.name &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    </span><span class="template-variable">&#123;&#123; <span class="builtin-name">else</span> &#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; $value.id &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span><span class="template-variable">&#123;&#123; $value.name &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    </span><span class="template-variable">&#123;&#123; /<span class="builtin-name">if</span> &#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    </span><span class="template-variable">&#123;&#123; /<span class="builtin-name">each</span> &#125;&#125;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/art-template/lib/template-web.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/jquery/dist/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> <span class="keyword">get</span> = (url,callback)=&gt;&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">            oReq.onload = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line">                callback(oReq.responseText)</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            oReq.open(<span class="string">"get"</span>,url,<span class="literal">true</span>)</span></span><br><span class="line">            oReq.send()</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-回调嵌套的方法"><a href="#4-1-回调嵌套的方法" class="headerlink" title="4.1 回调嵌套的方法"></a>4.1 回调嵌套的方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>('http://localhost:3000/user/2',(userData)=&gt;&#123;</span><br><span class="line">    <span class="keyword">get</span>('http://localhost:3000/jobs',(jobsData)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> sH = template(<span class="string">'tpl'</span>,&#123;</span><br><span class="line">            user:<span class="built_in">JSON</span>.parse(userData),</span><br><span class="line">            jobs:<span class="built_in">JSON</span>.parse(jobsData)            </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'user_form'</span>).innerHTML = sH  </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="4-2-封装Promise对象的get"><a href="#4-2-封装Promise对象的get" class="headerlink" title="4.2 封装Promise对象的get"></a>4.2 封装Promise对象的get</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pGet = <span class="function">(<span class="params">url</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">get</span>(url,(data)=&gt;&#123;</span><br><span class="line">                    resolve(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = &#123;&#125;</span><br><span class="line">        pGet(<span class="string">'http://localhost:3000/user/2'</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">userData</span>)=&gt;</span>&#123;</span><br><span class="line">            data.user = <span class="built_in">JSON</span>.parse(userData)</span><br><span class="line">            <span class="keyword">return</span> pGet(<span class="string">'http://localhost:3000/jobs'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">jobsData</span>)=&gt;</span>&#123;</span><br><span class="line">            data.jobs = <span class="built_in">JSON</span>.parse(jobsData)</span><br><span class="line">            <span class="keyword">let</span> sH = template(<span class="string">'tpl'</span>,data)</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'user_form'</span>).innerHTML = sH</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-调用jquery封装好的-get方法"><a href="#4-3-调用jquery封装好的-get方法" class="headerlink" title="4.3 调用jquery封装好的$.get方法"></a>4.3 调用jquery封装好的$.get方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;&#125;</span><br><span class="line">$.<span class="keyword">get</span>('http://localhost:3000/user/3')</span><br><span class="line">        .then((user)=&gt;&#123;</span><br><span class="line">            data.user = user</span><br><span class="line">            <span class="keyword">return</span> $.<span class="keyword">get</span>(`http://localhost:3000/jobs/$`)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then((jobs)=&gt;&#123;</span><br><span class="line">            data.jobs = jobs</span><br><span class="line">            <span class="keyword">let</span> sH = template(<span class="string">'tpl'</span>,data)</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">'user_form'</span>).innerHTML = sH</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="三、async函数"><a href="#三、async函数" class="headerlink" title="三、async函数"></a>三、async函数</h2><h4 id="3-1-async函数使用环境"><a href="#3-1-async函数使用环境" class="headerlink" title="3.1 async函数使用环境"></a>3.1 async函数使用环境</h4><ul>
<li><code>async</code>函数是为了实现对异步操作的控制而产生的。本身和<code>Generator</code>函数没有区别，实际上就是后者的语法糖。<code>async</code>函数配合<code>await</code>来代替<code>Gennerator</code>函数的<code>*</code>和<code>yield</code>。如果不了解<code>Gennerator</code>函数的话没有关系。直接从更好用的<code>async</code>开始学习。</li>
<li>以前对于异步操作的继发执行（比如：异步A执行完之后在执行异步B）都是使用函数嵌套的方式，后来上文中介绍的<code>Promise</code>对象，现在有了ES7中正式提出的<code>async</code>函数来控制异步函数。</li>
</ul>
<h4 id="3-2-async函数使用方式"><a href="#3-2-async函数使用方式" class="headerlink" title="3.2 async函数使用方式"></a>3.2 async函数使用方式</h4><ul>
<li>在<code>function</code>前加入<code>async</code>声明该方法为async函数</li>
<li>在函数体中，在异步操作前加入<code>await</code>用以声明，一般该异步操作应当为<code>Promise</code>对象化的</li>
<li>在一个<code>await</code>声明后的异步操作时，整个<code>async</code>函数将会暂停向下执行，直到当前异步操作执行完毕后才会向下执行，但是当该异步操作出错时，<code>async</code>函数将会结束整个函数，并返回一个<code>reject(err)</code>的<code>Promise</code>对象。如果要实现，当异步出错时，也继续向下执行<code>async</code>函数的话，需要配合<code>try..catch</code>或<code>.catch()</code>使用。</li>
<li><code>async</code>返回一个默认的<code>promise</code>对象，如果return一个<code>promise</code>对象的话则返回该<code>Promise</code>对象，如果return一个其他数据的的话则返回一个<code>Promise</code>对象，且该对象的<code>resolve</code>的参数为当时return的数据</li>
</ul>
<h4 id="3-3-async函数实现异步继发执行"><a href="#3-3-async函数实现异步继发执行" class="headerlink" title="3.3 async函数实现异步继发执行"></a>3.3 async函数实现异步继发执行</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(resolve, interval);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">one2FiveInAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">1000</span>);  <span class="comment">//实际上就是暂停one2FiveInAsync函数1s后再继续执行</span></span><br><span class="line">      	<span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  one2FiveInAsync()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	result:</span></span><br><span class="line"><span class="comment">	after 1s : 1</span></span><br><span class="line"><span class="comment">	....</span></span><br><span class="line"><span class="comment">	after 5s : 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="3-4-实现异步出错处理"><a href="#3-4-实现异步出错处理" class="headerlink" title="3.4 实现异步出错处理"></a>3.4 实现异步出错处理</h4><h5 id="3-4-1-使用try-catch捕获异常"><a href="#3-4-1-使用try-catch捕获异常" class="headerlink" title="3.4.1 使用try-catch捕获异常"></a>3.4.1 使用try-catch捕获异常</h5><p>在下面这个例子中，放在同一个try中的当遇到一个await定义的异步后将被catch捕获异常，然后跳出try,继续向下执行，当遇到没有在try中的await定义的异步出错时，退出了整个async函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//try..catch方式</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错啦1'</span>)</span><br><span class="line">		<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错啦2'</span>)</span><br><span class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错啦3'</span>)</span><br><span class="line">	<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'成功啦'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a().then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(e)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	result:</span></span><br><span class="line"><span class="comment">		出错啦1</span></span><br><span class="line"><span class="comment">		出错啦3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-使用catch方法捕获异常"><a href="#3-4-2-使用catch方法捕获异常" class="headerlink" title="3.4.2 使用catch方法捕获异常"></a>3.4.2 使用catch方法捕获异常</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错啦！1'</span>).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(e)&#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错啦！2'</span>).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(e)&#125;)</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'成功啦'</span>)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line">.then(<span class="function"><span class="params">d</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(d)&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(e)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	result:</span></span><br><span class="line"><span class="comment">		出错啦！1</span></span><br><span class="line"><span class="comment">		出错啦！2</span></span><br><span class="line"><span class="comment">		undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-实现异步的类并发执行"><a href="#3-5-实现异步的类并发执行" class="headerlink" title="3.5 实现异步的类并发执行"></a>3.5 实现异步的类并发执行</h4><p>类并发执行，即非继发执行。在async中实现类并发，可以配合Promise.all方法使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all([Example1(),Example2()])</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2019/07/16/MongoDB/</url>
    <content><![CDATA[<h2 id="一、起步"><a href="#一、起步" class="headerlink" title="一、起步"></a>一、起步</h2><ul>
<li>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li>
<li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li>
</ul>
<a id="more"></a>

<h2 id="二、安装MongoDB"><a href="#二、安装MongoDB" class="headerlink" title="二、安装MongoDB"></a>二、安装MongoDB</h2><ul>
<li>官网下载<a href="https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-4.0.10-signed.msi" target="_blank" rel="noopener">地址</a>并安装</li>
<li>配置安装目录下的bin到环境变量中去</li>
<li>如需进行测试可以使用：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -v</span><br></pre></td></tr></table></figure>



<h2 id="三、打开mongodb数据库"><a href="#三、打开mongodb数据库" class="headerlink" title="三、打开mongodb数据库"></a>三、打开mongodb数据库</h2><ul>
<li>在键入mongod命令前需要改对应盘符的根目录下创建<code>data/db</code>目录</li>
<li>然后键入命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\&gt; mongod</span><br></pre></td></tr></table></figure>

<ul>
<li>保持shell的打开状态</li>
</ul>
<h2 id="四、连接mongodb数据库"><a href="#四、连接mongodb数据库" class="headerlink" title="四、连接mongodb数据库"></a>四、连接mongodb数据库</h2><ul>
<li>保持mongodb数据库打开状态</li>
<li>在命令行中输入</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\&gt; mongo</span><br></pre></td></tr></table></figure>



<h2 id="五、常用的命令"><a href="#五、常用的命令" class="headerlink" title="五、常用的命令"></a>五、常用的命令</h2><ul>
<li>显示mongodb中所有数据库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<ul>
<li>显示当前数据库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure>

<ul>
<li>切换或创建新数据库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure>

<ul>
<li>显示当前数据库的所有集合名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure>

<ul>
<li>显示当前数据库指定集合的所有文档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名.find()</span><br></pre></td></tr></table></figure>



<h2 id="六、Node-js中操作MongoDB"><a href="#六、Node-js中操作MongoDB" class="headerlink" title="六、Node.js中操作MongoDB"></a>六、Node.js中操作MongoDB</h2><h3 id="1、使用MongoDB官方的node-mongodb-native"><a href="#1、使用MongoDB官方的node-mongodb-native" class="headerlink" title="1、使用MongoDB官方的node-mongodb-native"></a>1、使用MongoDB官方的node-mongodb-native</h3><p><a href="https://github.com/mongodb/node-mongodb-native" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="2-使用Mongoose模块"><a href="#2-使用Mongoose模块" class="headerlink" title="2.使用Mongoose模块"></a>2.使用Mongoose模块</h3><p><a href="http://www.mongoosejs.net/" target="_blank" rel="noopener">中文文档</a></p>
<h4 id="2-1-安装Mongoose"><a href="#2-1-安装Mongoose" class="headerlink" title="2.1 安装Mongoose"></a>2.1 安装Mongoose</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure>

<h4 id="2-2-连接MongoDB"><a href="#2-2-连接MongoDB" class="headerlink" title="2.2 连接MongoDB"></a>2.2 连接MongoDB</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/数据库名'</span>,&#123;<span class="attr">useNewUrlParser</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-设计数据库表（集合）"><a href="#2-3-设计数据库表（集合）" class="headerlink" title="2.3 设计数据库表（集合）"></a>2.3 设计数据库表（集合）</h4><p>Schema就是一个模板，起到了预先设计数据表的作用。其中required属性为真代表了改字段不可为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    passworld:&#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    email:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-增加文档"><a href="#2-4-增加文档" class="headerlink" title="2.4 增加文档"></a>2.4 增加文档</h4><p>mongoose.model中的第一个参数为表名，也就是集合名，第二个参数是设计好的表结构。</p>
<p>插入一条name为admin的文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>,UserSchema) <span class="comment">// 相当于User表集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Admin = <span class="keyword">new</span> User(&#123;     <span class="comment">//单文档</span></span><br><span class="line">    name:<span class="string">"admin"</span>,</span><br><span class="line">    passworld:<span class="string">"123123"</span></span><br><span class="line">    email:<span class="string">"123@qq.com"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Admin.save().than(<span class="function"><span class="params">()</span>=&gt;</span>&#123;      <span class="comment">//Promise</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"success!"</span>)</span><br><span class="line">&#125;,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-5-查找文档"><a href="#2-5-查找文档" class="headerlink" title="2.5 查找文档"></a>2.5 查找文档</h4><p>查找文档的所有方法都是在表集合对象上的，例如上例中的User</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>find</td>
<td>[{属性:值[,…]}],(err,data)=&gt;{}</td>
<td>查找满足指定属性=值的文档数组到回调中data，第一个参数省略为无条件查找</td>
</tr>
<tr>
<td>findOne</td>
<td>[{属性:值[,…]}],(err,data)=&gt;{}</td>
<td>查找满足指定属性=值的第一条文档到回调中data，第一个参数省略为无条件查找</td>
</tr>
</tbody></table>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat.find(&#123;</span><br><span class="line">    name: <span class="string">"milse88"</span></span><br><span class="line">&#125;,(err,cats)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(cats)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cat.findOne(<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ &#123; _id: 5d2be43e1fb7af12f0f745a8, name: 'milse88', __v: 0 &#125; ] #数组</span><br><span class="line">&#123; _id: 5d2be315679a272f2459966c, name: 'milse', __v: 0 &#125;       #对象</span><br></pre></td></tr></table></figure>

<h4 id="2-6-删除文档"><a href="#2-6-删除文档" class="headerlink" title="2.6 删除文档"></a>2.6 删除文档</h4><table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>deleteOne</td>
<td>[{属性:值[,…]}],(err,res)=&gt;{}</td>
<td>查找满足指定属性=值的第一个文档进行删除，第一个参数省略为无条件删除</td>
</tr>
<tr>
<td>deleteMany</td>
<td>[{属性:值[,…]}],(err,res)=&gt;{}</td>
<td>查找满足指定属性=值的所有文档进行删除，第一个参数省略为无条件查找</td>
</tr>
<tr>
<td>remove</td>
<td>[{属性:值[,…]}],(err,res)=&gt;{}</td>
<td>查找满足指定属性=值的所有文档进行删除，第一个参数省略为无条件查找 (官方文档中说明改方法以不建议使用)，因此不再举例</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>注意，Moogoose使用正则匹配，所以条件对象中的值可以为正则表达式的形式出现</li>
<li>Model.AIP的回调都是以<code>(error,result)=&gt;{}</code>的方式出现</li>
</ul>
</blockquote>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat.deleteOne(&#123;</span><br><span class="line">    name:<span class="string">"milse8"</span></span><br><span class="line">&#125;,(err,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)<span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删除成功！'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cat.deleteMany(&#123;</span><br><span class="line">    name:<span class="regexp">/milse8/m</span></span><br><span class="line">&#125;,(err,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删除成功！'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">删除成功！</span><br><span class="line">&#123; n: 1, ok: 1, deletedCount: 1 &#125;</span><br><span class="line">删除成功！</span><br><span class="line">&#123; n: 10, ok: 1, deletedCount: 10 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-更新文档"><a href="#2-7-更新文档" class="headerlink" title="2.7 更新文档"></a>2.7 更新文档</h4><table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>updateOne</td>
<td>[{属性:值[,…]}],{属性:值[,…]},(err,res)=&gt;{}</td>
<td>第一个参数为条件对象，第二个参数为更新对象，找到第一个满足条件的文档，按更新对象进行更新</td>
</tr>
<tr>
<td>updateMany</td>
<td>[{属性:值[,…]}],{属性:值[,…]},(err,res)=&gt;{}</td>
<td>找到所有满足条件的文档，按更新对象进行更新，如第一个条件缺省，则更新数据库中的所有文档</td>
</tr>
</tbody></table>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat.updateOne(&#123;</span><br><span class="line">    name: <span class="string">'milse1'</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    name: <span class="string">'maojiankai'</span></span><br><span class="line">&#125;,(err,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cat.updateMany(&#123;</span><br><span class="line">    name: <span class="regexp">/milse1/m</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    name: <span class="string">'maojiankai'</span></span><br><span class="line">&#125;,(err,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">n</span>: <span class="number">1</span>, <span class="attr">nModified</span>: <span class="number">1</span>, <span class="attr">ok</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">n</span>: <span class="number">10</span>, <span class="attr">nModified</span>: <span class="number">10</span>, <span class="attr">ok</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-设置全局属性"><a href="#2-8-设置全局属性" class="headerlink" title="2.8 设置全局属性"></a>2.8 设置全局属性</h4><p>mongoose中提供了设置全局属性的方法，这将运用到含有该属性的方法中去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.set(<span class="string">'属性名'</span>,值)</span><br></pre></td></tr></table></figure>

<p>例如，我们可以将原来的连接数据库方式改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来</span></span><br><span class="line">mongoose.connect(<span class="string">'mongoose://localhost/数据库名'</span>,&#123;<span class="string">'useNewUrlParser'</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//改为 ：</span></span><br><span class="line">mongoose.set(<span class="string">'useNewUrlParser'</span>,<span class="literal">true</span>)</span><br><span class="line">mongoose.connect(<span class="string">'mongoose://localhost/数据库名'</span>）</span><br></pre></td></tr></table></figure>

<ul>
<li>注：MongoDB Node.js驱动程序重写了用于解析<a href="https://docs.mongodb.com/manual/reference/connection-string/" target="_blank" rel="noopener">MongoDB连接字符串</a>的工具。因为这是一个很大的变化，所以他们将新的连接字符串解析器放在一个标志后面。要打开此选项，请将<code>useNewUrlParser</code>选项传递给 <a href="https://mongoosejs.com/docs/api.html#mongoose_Mongoose-connect" target="_blank" rel="noopener"><code>mongoose.connect()</code></a> 或<a href="https://mongoosejs.com/docs/api.html#mongoose_Mongoose-createConnection" target="_blank" rel="noopener"><code>mongoose.createConnection()</code></a>。</li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架</title>
    <url>/2019/07/16/Express%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="一、引入Express框架"><a href="#一、引入Express框架" class="headerlink" title="一、引入Express框架"></a>一、引入Express框架</h2><h4 id="1-安装并加载Express模块"><a href="#1-安装并加载Express模块" class="headerlink" title="1.安装并加载Express模块"></a>1.安装并加载Express模块</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express() <span class="comment">//相当于http.createServer()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="2-编写响应和绑定端口号"><a href="#2-编写响应和绑定端口号" class="headerlink" title="2.编写响应和绑定端口号"></a>2.编写响应和绑定端口号</h4><p>在Express框架下，不再需要更改响应头，其具有自动识别并更改响应头的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url)</span><br><span class="line">    res.send(<span class="string">'i am erxpress'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server is running~'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-设置静态空间"><a href="#3-设置静态空间" class="headerlink" title="3.设置静态空间"></a>3.设置静态空间</h4><p>在被设置为静态空间的文件夹下的文件可以被终端直接访问,例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：为在当前文件夹下的public文件夹设置为静态空间</span></span><br><span class="line"><span class="comment">		可以直接以./public/*的方式打开对应文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">app.use(<span class="string">'/public/'</span>,express.static(<span class="string">'./public'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="4-在express中使用art-template"><a href="#4-在express中使用art-template" class="headerlink" title="4.在express中使用art-template"></a>4.在express中使用art-template</h4><p>使用<code>express-art-tempalte</code>虽然不需要再载入<code>art-template</code>,但是前者是基于后者的，所以使用前者必须安装后者。</p>
<p>安装<code>express-art-template</code>模块后，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'html'</span>,<span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.render(<span class="string">'文件名.html'</span>,模板json)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li><p>render中的文件无需加入路径，默认访问当前文件夹下的<code>views</code>文件夹下的对应文件，如需更改可以使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">'views'</span>,更改的默认目录+<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="5-在express中解析post请求的数据"><a href="#5-在express中解析post请求的数据" class="headerlink" title="5.在express中解析post请求的数据"></a>5.在express中解析post请求的数据</h4><p>需要先安装中间件-<code>body-parser</code>,然后根据以下命令配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br><span class="line">app.use(bodyParser.json)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="6-构建路由"><a href="#6-构建路由" class="headerlink" title="6.构建路由"></a>6.构建路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router = express.Router()</span><br><span class="line">router.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;&#125;)</span><br><span class="line">router.post(<span class="string">'/'</span>,(req,res)=&gt;&#123;&#125;)</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure>



<h4 id="7-构建项目链"><a href="#7-构建项目链" class="headerlink" title="7.构建项目链"></a>7.构建项目链</h4><ol>
<li>构建入口函数</li>
<li>设计路由</li>
<li>设计API</li>
<li>具体实现</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.js &lt;--- router.js &lt;--- APIname.js</span><br></pre></td></tr></table></figure>

<h2 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h2><p><code>express-session中间件</code></p>
<p>配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">'keyboard cat'</span>,  <span class="comment">//配置加密字符串。为了增加安全性，再加密后再加上该字符串进行一次加密</span></span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">true</span>  <span class="comment">//无论是否使用session,默认分配一个sid（钥匙）</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    req.session.xx = xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="三、关于Express中的中间件"><a href="#三、关于Express中的中间件" class="headerlink" title="三、关于Express中的中间件"></a>三、关于Express中的<a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">中间件</a></h2><h4 id="3-1-中间件"><a href="#3-1-中间件" class="headerlink" title="3.1 中间件"></a>3.1 中间件</h4><p>中间件<code>middleware</code>就是一个为你增加功能的方法。配置好对应的中间件之后，我们就能使用对应的功能了。在<code>Node.js</code>中，中间件一般都是处理请求的<code>req,res</code></p>
<h4 id="3-2-Express中间件按关心内容分类"><a href="#3-2-Express中间件按关心内容分类" class="headerlink" title="3.2 Express中间件按关心内容分类"></a>3.2 Express中间件按关心内容分类</h4><table>
<thead>
<tr>
<th>中间件</th>
<th>参数</th>
<th>功能</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>use</td>
<td>(req,res,next)=&gt;{}</td>
<td>不论收到来自客户端的任何请求，都会执行参数里的方法。next()代表自动执行下一个中间件</td>
<td>不关心请求路径和请求方式的中间件</td>
</tr>
<tr>
<td>use</td>
<td>‘/xxx’,(req,res,next)=&gt;{}</td>
<td>当请求路径以第一个参数开头时，则执行第二个参数的方法</td>
<td>关心请求路径但不关心请求方式的中间件</td>
</tr>
<tr>
<td>get、post</td>
<td>‘/xxx’,(req,res,next)=&gt;{}</td>
<td>当对应get、post请求的请求路径为对应的第一个参数时执行</td>
<td>严格按照请求路径并关心请求方式的中间件</td>
</tr>
</tbody></table>
<h4 id="3-3-中间件匹配策略"><a href="#3-3-中间件匹配策略" class="headerlink" title="3.3 中间件匹配策略"></a>3.3 中间件匹配策略</h4><ul>
<li>如果匹配到第一个符合条件的中间件<ul>
<li>如果没有next则结束匹配</li>
<li>如果执行了next（）则继续匹配下一个符合条件的中间件</li>
</ul>
</li>
<li>如果没有匹配到，则继续向下找满足条件的中间件</li>
</ul>
<h4 id="3-4-使用中间件配置404和全局错误处理"><a href="#3-4-使用中间件配置404和全局错误处理" class="headerlink" title="3.4 使用中间件配置404和全局错误处理"></a>3.4 使用中间件配置404和全局错误处理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example...</span></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    fs.read(<span class="string">'ab.txt'</span>,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">return</span> next(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//example...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置404页面</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.render(<span class="string">'404.html'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置全局错误处理</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    res.status(<span class="number">500</span>).json(&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js基本语法</title>
    <url>/2019/07/16/Node-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、创建一个Node-js应用"><a href="#一、创建一个Node-js应用" class="headerlink" title="一、创建一个Node.js应用"></a>一、创建一个Node.js应用</h2><ol>
<li>加载http核心模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>创建一个Web服务器，返回一个server实例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol start="3">
<li>服务端接收到来自客户端的请求时”request”执行回调函数<ul>
<li>参数：<ul>
<li>request  请求对象（客户端向本服务端发送的请求对象）</li>
<li>response 响应对象（本服务端向客户端发送的响应对象）</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">"request"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">console</span>.log(<span class="string">"接受到请求了！url："</span>+request.url)</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">console</span>.log(<span class="string">"请求的Ip"</span>+response.socket.remoteAddress+<span class="string">":"</span>+response.socket.remotePort)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">var</span> str=request.url</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">var</span> mes</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(str === <span class="string">"/"</span>)&#123;</span><br><span class="line"></span><br><span class="line">​        response.end(<span class="string">"Index page"</span>)</span><br><span class="line"></span><br><span class="line">​    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">"/login"</span>)&#123;</span><br><span class="line">​        response.end(<span class="string">"登录"</span>)</span><br><span class="line">​    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">"/haha"</span>)&#123;   </span><br><span class="line">​        response.end(<span class="string">"哈哈"</span>)</span><br><span class="line">​    &#125;</span><br><span class="line">​   <span class="comment">// 响应内容只能是二进制数据或字符串</span></span><br><span class="line">​    <span class="keyword">if</span>(str == <span class="string">"/product"</span>)&#123;</span><br><span class="line">​        <span class="keyword">var</span> product=[</span><br><span class="line">​            &#123;</span><br><span class="line">​                name: <span class="string">"apple"</span>,</span><br><span class="line">​                price: <span class="number">3500</span></span><br><span class="line">​            &#125;,</span><br><span class="line">​            &#123;</span><br><span class="line">​                name: <span class="string">"banana"</span>,</span><br><span class="line">​                price: <span class="number">5330</span></span><br><span class="line">​            &#125;,</span><br><span class="line">​            &#123;</span><br><span class="line">​                name: <span class="string">"banana"</span>,</span><br><span class="line">​                price: <span class="number">5330</span></span><br><span class="line">​            &#125;</span><br><span class="line">​        ]</span><br><span class="line">​        response.end(<span class="built_in">JSON</span>.stringify(product))</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>绑定端口号，开启服务器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(<span class="number">80</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">console</span>.log(<span class="string">"服务器启动成功了，访问http://127.0.0.1:3000/ 进行访问"</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="二、Node-js常用核心模块"><a href="#二、Node-js常用核心模块" class="headerlink" title="二、Node.js常用核心模块"></a>二、Node.js常用核心模块</h2><p>除了我们刚刚用的<code>http</code>模块，Node.js中还有一些比较常用的模块</p>
<h3 id="1-fs模块"><a href="#1-fs模块" class="headerlink" title="1. fs模块"></a>1. fs模块</h3><h4 id="1-1-加载文件系统模块"><a href="#1-1-加载文件系统模块" class="headerlink" title="1.1 加载文件系统模块"></a>1.1 加载文件系统模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)<span class="comment">//加载fs核心模块</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-文件读操作"><a href="#1-2-文件读操作" class="headerlink" title="1.2 文件读操作"></a>1.2 文件读操作</h4><ul>
<li>参数<ul>
<li>读文件的文件名</li>
<li>回调函数<ul>
<li>err : 出错信息，读文件出错时返回错误对象。否则返回Null。</li>
<li>data : 读出的数据，默认为二进制数据。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'readme.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'file read err!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-文件写操作"><a href="#1-3-文件写操作" class="headerlink" title="1.3 文件写操作"></a>1.3 文件写操作</h4><ul>
<li>参数<ul>
<li>将数据写入的目标文件</li>
<li>要写入的数据</li>
<li>回调函数<ul>
<li>err</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'output.txt'</span>,<span class="string">'i am data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'file write err!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-Path模块"><a href="#2-Path模块" class="headerlink" title="2. Path模块"></a>2. Path模块</h3><p>这是Node.js提供的路径模块。主要是为了解析路径</p>
<ul>
<li><code>path.basename(path[,ext])</code>获得当前path中的最终文件名（带后缀），如参数加入ext，则获得不带路径的结果</li>
<li><code>path.dirname(path)</code>获得path中的路径解析结果</li>
<li><code>path.extname(path)</code> 获得path中最终文件的后缀</li>
<li><code>path.join([...paths])</code>将paths合并为一个路径</li>
<li><code>path.parse(path)</code> 将path解析为一个路径信息对象比如</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.parse(<span class="string">'/home/user/dir/file.txt'</span>);</span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// &#123; root: '/',</span></span><br><span class="line"><span class="comment">//   dir: '/home/user/dir',</span></span><br><span class="line"><span class="comment">//   base: 'file.txt',</span></span><br><span class="line"><span class="comment">//   ext: '.txt',</span></span><br><span class="line"><span class="comment">//   name: 'file' &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、Node-js中的其他成员"><a href="#三、Node-js中的其他成员" class="headerlink" title="三、Node.js中的其他成员"></a>三、Node.js中的其他成员</h2><p>再Node.js中的每个模块除了都有<code>require</code>、<code>exports</code>等模块相关的API外，还有两个特殊的成员：</p>
<ul>
<li><code>__dirname</code>可以用来获得当前文件模块的绝对路径</li>
<li><code>__filename</code>可以用来获取当前文件的绝对路径</li>
</ul>
<h2 id="三、Node-js面向模块编程思想"><a href="#三、Node-js面向模块编程思想" class="headerlink" title="三、Node.js面向模块编程思想"></a>三、Node.js面向模块编程思想</h2><h4 id="1-万物基于模块"><a href="#1-万物基于模块" class="headerlink" title="1.万物基于模块"></a>1.万物基于模块</h4><p>在Node.js中每个Js文件都是一个模块，都可以被其他的模块用<code>require(&#39;路径+文件名&#39;)</code> 的方式引用。模块分为Node.js自带的系统模块和第三方模块，以及用户自定义的模块</p>
<h4 id="2-模块的接口"><a href="#2-模块的接口" class="headerlink" title="2.模块的接口"></a>2.模块的接口</h4><p>模块的接口利用每个模块本身所提供的<code>module.exports</code> 或<code>exports</code>对象即可,关于它们之间的区别会在后面说明自己的看法。</p>
<h4 id="3-引用自定义模块举例"><a href="#3-引用自定义模块举例" class="headerlink" title="3.引用自定义模块举例"></a>3.引用自定义模块举例</h4><ol>
<li>引用系统模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>引用第三方模块</p>
<ol>
<li><p>在终端或控制台中输入<code>npm install 包名</code> 命令 的方式来安装第三方模块到当前目录的node_mudoles文件夹中</p>
</li>
<li><p>像引用系统模块那样引用第三方模块即可，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install  art-template</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = <span class="built_in">require</span>(<span class="string">'art-template'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>引用用户自定义模块</p>
<ol>
<li><p>文件a</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./b.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.add(<span class="number">3</span>,<span class="number">10</span>)) <span class="comment">//30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件b</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.add = <span class="function">(<span class="params">x,y</span>)=&gt;</span>a+b</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">mudole.exports.add = <span class="function">(<span class="params">x,y</span>)=&gt;</span>a+b</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>exports</code> 与<code>mudoles.exports</code>之间的关系</p>
<p>首先，每个模块都有一个<code>module</code>对象，他可能是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">'.'</span>,</span><br><span class="line">  exports: &#123; <span class="attr">test</span>: <span class="number">5</span>, <span class="attr">add</span>: [<span class="built_in">Function</span>], <span class="attr">readFile</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'D:\\Fontend\\Node.js学习\\简单的模块化\\c.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'D:\\Fontend\\Node.js学习\\简单的模块化\\node_modules'</span>,</span><br><span class="line">     <span class="string">'D:\\Fontend\\Node.js学习\\node_modules'</span>,</span><br><span class="line">     <span class="string">'D:\\Fontend\\node_modules'</span>,</span><br><span class="line">     <span class="string">'D:\\node_modules'</span> ] &#125;</span><br></pre></td></tr></table></figure>

<p>它包括的一些关于模块本身的信息，其中就包含有<code>exports</code>。所以，<code>exports</code>与<code>module.exports</code>在默认情况下是等价的。为了便于挂载接口，所以每个模块可以直接用<code>exports</code>，但是实际上模块向引用它的上层返回的是<code>module.exports</code>这个对象</p>
</li>
</ol>
</li>
</ol>
<h4 id="4-关于Node-js对于模块的查找"><a href="#4-关于Node-js对于模块的查找" class="headerlink" title="4.关于Node.js对于模块的查找"></a>4.关于Node.js对于模块的查找</h4><p>实际上在运行过程中，如果要加载第三方模块，系统默认会先在当前文件目录下的node_module文件夹下按名寻找对应的第三方模块。如果没有，则在向上一层目录下的node_module文件夹下按名寻找，依此类推，直到计算机盘符下的根目录下的node_module文件夹。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>在有一定JavaScript语言的基础上学习原生Node.js相对容易，但是对于很多操作来说，过程还是过于繁琐，所以，接下来将在此基础上学习更加简洁高效的Express框架。</p>
<p>个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p>
<p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Common.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS函数</title>
    <url>/2019/02/17/JS%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、JavaScript函数"><a href="#一、JavaScript函数" class="headerlink" title="一、JavaScript函数"></a>一、JavaScript函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JavaScript中必须使用function来定义函数</p>
<pre><code>function name([a[,b][,c]...]){
    代码
}</code></pre><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>js函数对参数的值类型没由进行任何检查。函数再定义是列出的参数被称为“显式参数(Parameters)”，而调用时真实传递的值被称为“隐式参数(Arguments)”。</p>
<a id="more"></a>
<h5 id="默认值-ES6"><a href="#默认值-ES6" class="headerlink" title="默认值(ES6)"></a>默认值(ES6)</h5><p>ES6中，支持类似于C++中的为参数赋默认值，例如:</p>
<pre><code>funciton sum(x,y=10){
    return  x+y;
}
sum(0,2); //2
sum(5); //15</code></pre><h5 id="Arguments-对象"><a href="#Arguments-对象" class="headerlink" title="Arguments 对象"></a>Arguments 对象</h5><p>JavaScript函数有个内置的Arguments数组对象，它存储了调用函数时所有的参数值。类似于Java中主函数会再参数中加入”String [] args”的方法。例如：</p>
<pre><code>//在任意多个参数中查到其中的最大值的函数：
function findMax() {
    var i, max = arguments[0];
    if(arguments.length &lt; 2) return max;
    for (i = 0; i &lt; arguments.length; i++){
        if (arguments[i] &gt; max) {
            max = arguments[i];
        }
    }
    return max;
}
x = findMax(1, 123, 500, 115, 44, 88); //x=500</code></pre><h5 id="传值注意事项"><a href="#传值注意事项" class="headerlink" title="传值注意事项"></a>传值注意事项</h5><p>通过一般的值传递，相当于在函数中创建了一个副本，在函数中修改不会改变函数外部的值。而通过对象传值相当于传的是地址，如果在函数体内修改对象的值将会影响到源对象的值！</p>
<h4 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h4><p>funciton 函数支持提升(提升(Hoisting)是Js在预编译时发生的将某些对象放到其作用域内的最前面的行为)，所以支持先调用后声明，例如:</p>
<pre><code>sum(5,2); //10

function sum(x,y){return x+y;}</code></pre><h4 id="匿名自调用函数"><a href="#匿名自调用函数" class="headerlink" title="匿名自调用函数"></a>匿名自调用函数</h4><p>未命名的函数称为匿名函数，而自调用也就是函数自己调用自己，例如:</p>
<pre><code>(function(a){return a * a;})(5) //25</code></pre><h4 id="箭头函数-ES6"><a href="#箭头函数-ES6" class="headerlink" title="箭头函数 (ES6)"></a>箭头函数 (ES6)</h4><p>格式:</p>
<pre><code>(参数1,……) =&gt; {函数声明};

(参数1,……) =&gt; 表达式;//相当于
(参数1,……) =&gt; {return 表达式};</code></pre><p>例如:</p>
<pre><code>var a=(x,y) =&gt; x*y;
consle.log(a(2,5));//10</code></pre><p>箭头函数不支持提升，使用前需要先声明！</p>
<h3 id="二、JavaScript-闭包"><a href="#二、JavaScript-闭包" class="headerlink" title="二、JavaScript 闭包"></a>二、JavaScript 闭包</h3><p>闭包是指一个函数能够引用上级函数的局部变量，因此在上级函数执行完毕后，其局部变量并不会被立即回收。不必要的闭包会浪费内存空间。</p>
<p>例如”计数器问题”的解决方案有这几个:</p>
<p>一、</p>
<pre><code>var conter=0;
function add(){
    return conter+=1;
}
add();
add(); //2</code></pre><p>这样做是最简单的，但也是最不安全的。因为conter是全局变量，因此在外部可以随意改变conter的值，完全可以使用 <code>conter++;</code>来代替<code>add（）</code>。则计数器失去了意义，所以这种方法不采用。</p>
<p>二、 内嵌函数</p>
<pre><code>function add(){
    var conter=0;
    var plus=() =&gt; conter+=1;
    plus();
    plus();
    return conter;
}
add(); //2</code></pre><p>使用内嵌函数的方法固然不能再外部修改conter的值了，平且实际的计数器<code>plus()</code>只能再函数<code>add()</code>中调用，因此这种方法也不能采用。</p>
<p>三、闭包</p>
<pre><code>var add=function(){
    var conter=0;
    return () =&gt; conter+=1;
}();
add();
add(); //2</code></pre><p>闭包实现，其中<code>add()</code>实际就是执行匿名函数后返回的<code>() =&gt; conter+=1;</code>这个箭头函数，而箭头函数引用了<code>conter</code>这个局部变量，所以形成了闭包。这即保证了<code>conter</code>不会被随意修改，还解决了计数器问题。</p>
<blockquote>
<p>需要补充的是闭包实际上使用了JavaSctipt中的一些Bug，虽然很巧妙的解决了计数器问题，但是太过于依赖JavaSctipt内部实现，指不定哪天都被休息啦，所以在实际编写时还是要使用创建对象的方法来完成这个问题。</p>
</blockquote>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ul>
<li>在ES6中，函数支持为参数设置默认值</li>
<li>ES6中，函数支持通过箭头来定义</li>
<li>函数中内置Arguments数组对象，存放了所有在调用函数时的参数值</li>
<li>匿名函数需要在被定义后就被执行，否则就失去了其意义</li>
<li>闭包就是当前函数引用了上级函数的局部变量，使其在执行后无法被释放，形成了闭包</li>
</ul>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JSON</title>
    <url>/2019/01/26/%E5%85%B3%E4%BA%8EJSON/</url>
    <content><![CDATA[<h3 id="一、JavaScript-JSON"><a href="#一、JavaScript-JSON" class="headerlink" title="一、JavaScript JSON"></a>一、JavaScript JSON</h3><ul>
<li>Json全称 JavaScript Object Notation(Js 对象标记)</li>
<li>轻量级数据交换格式</li>
<li>Json是用于存储和传输数据的格式。</li>
<li>Json通常用于服务端向网页传递数据</li>
</ul>
<a id="more"></a>
<h4 id="JSON语法结构"><a href="#JSON语法结构" class="headerlink" title="JSON语法结构"></a>JSON语法结构</h4><h5 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h5><p>JSON语法事JS对象表示语法的子集。书写格式为</p>
<pre><code>&quot;name&quot;=&quot;Jack&quot;;
或
&quot;age&quot;=18;</code></pre><p>JSON的值可以是：</p>
<ul>
<li>数字</li>
<li>字符串(加双引号)</li>
<li>逻辑值(true或false)</li>
<li>数组(再方括号中，用逗号隔开各个数组元素)</li>
<li>对象(再花括号中，逗号隔开各个属性)</li>
<li>null</li>
</ul>
<p>例如JSON数组中包含3个对象:</p>
<pre><code>{
&quot;sites&quot;:[
{&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:15},
{&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;,16},
{&quot;name&quot;:&quot;Unto&quot;,&quot;age&quot;,16}
]
}</code></pre><p>JavaScript中JSON对象内置了两个函数用于将Js于JSON进行转换</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JSON.parse(Json字符串)</td>
<td align="left">将一个JSON字符串转换为JavaScript对象</td>
</tr>
<tr>
<td align="left">JSON.stringify(JavaScript值)</td>
<td align="left">将JavaScript值转换为JSON字符串</td>
</tr>
</tbody></table>
<p>Js中eval函数可以执行某个字符串中的语句。但是字符串内容如果为函数或者是代码块，需要在字符串前后分别连接”(“和”)”.</p>
<pre><code>eval(String);
//JSON对象化处理:
eval(&apos;(&apos;+user+&apos;)&apos;);
//例如
eval(&quot;(&quot;+&quot;function (){return 0;}&quot;+&quot;)&quot;)(); //返回0</code></pre><blockquote>
<p>不建议在JSON中使用函数。</p>
</blockquote>
<h3 id="二、Javascript-void-0-含义"><a href="#二、Javascript-void-0-含义" class="headerlink" title="二、Javascript:void(0)含义"></a>二、Javascript:void(0)含义</h3><p>void关键字表示运行表达式，但是不返回值(undefined)。例如:</p>
<pre><code>&lt;a href=&quot;javascript:void(0)&quot;&gt;单机此处啥也不会发生&lt;/a&gt;
//确实啥也不会发生
&lt;a href=&quot;javascript:void(alert(&apos;warning!&apos;))&quot;&gt;点我&lt;/a&gt;
//浏览器提示warning!</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>JSON是一种js与服务器端的交换格式</li>
<li>JSON在ajax应用中要优于XML</li>
<li>JSON.parse()函数可以将JSON字符串转换为JS对象</li>
<li>JSON.stringify（）函数可以将JS对象转换为JSON字符串格式。</li>
<li>JavaScript代码规范，其中尽量用4个空格键来代替tab键</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS正则表达式</title>
    <url>/2019/01/20/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h3><h4 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h4><p>正则表达式是描述字符模式的对象。<br>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p>
<a id="more"></a>

<pre><code>语法:
var regexp=new RegExp(&quot;模式&quot;,&quot;修饰符&quot;);
或者：
var regexp=/模式/修饰符;
/*其中模式就是要去与目标字符串去进行匹配的字符串*/</code></pre><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">不区分字母大小写</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">全局搜索(查找所有匹配，而非在查找到第一个后停止)</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">执行多行匹配</td>
</tr>
</tbody></table>
<h4 id="模式内方法"><a href="#模式内方法" class="headerlink" title="模式内方法"></a>模式内方法</h4><h5 id="1-方括号"><a href="#1-方括号" class="headerlink" title="1.方括号"></a>1.方括号</h5><p>方括号是用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[abc]</td>
<td align="left">查找方括号之间的任何字符。注:[\u4E00-\u9FA5]是查找中文</td>
</tr>
<tr>
<td align="left">[^abc]</td>
<td align="left">查找任何不再方括号之间的字符</td>
</tr>
<tr>
<td align="left">[0-9]、[a-z]、[A-Z]、[A-z]</td>
<td align="left">查找(0-9)或(a-z)或(A-Z)或(A-Z和a-z)的之间的数字或字符</td>
</tr>
<tr>
<td align="left">(red&#124;blue&#124;green)</td>
<td align="left">查找三者值中任意一项</td>
</tr>
</tbody></table>
<h5 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2.元字符"></a>2.元字符</h5><p>元字符是拥有特殊含义的字符:</p>
<table>
<thead>
<tr>
<th align="left">元字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">查找单个字符，除了换行和行结束附</td>
</tr>
<tr>
<td align="left">\s,\S</td>
<td align="left">查找空白字符和查找非空配字符</td>
</tr>
<tr>
<td align="left">\w,\W</td>
<td align="left">查找单词字符(大小写字母和下划线)和非单词字符</td>
</tr>
<tr>
<td align="left">\d,\D</td>
<td align="left">查找数字和非数字字符</td>
</tr>
<tr>
<td align="left">\b,\B</td>
<td align="left">匹配单词边界和非单词边界</td>
</tr>
<tr>
<td align="left">\0</td>
<td align="left">查找NULL字符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">查找换行符</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">查找换页符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">查找回车符</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">查找制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">查找垂直制表符</td>
</tr>
</tbody></table>
<h5 id="3-量词"><a href="#3-量词" class="headerlink" title="3.量词"></a>3.量词</h5><table>
<thead>
<tr>
<th align="left">量词</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n+</td>
<td align="left">匹配任何包含至少一个n的字符串</td>
</tr>
<tr>
<td align="left">n*</td>
<td align="left">匹配任何包含0个或多个n的字符串</td>
</tr>
<tr>
<td align="left">n?</td>
<td align="left">匹配任何包含0个或1个n的字符串</td>
</tr>
<tr>
<td align="left">n{X}</td>
<td align="left">匹配包含X个n的字符串</td>
</tr>
<tr>
<td align="left">n{X,}</td>
<td align="left">匹配至少包含X个n的字符串</td>
</tr>
<tr>
<td align="left">n{X,Y}</td>
<td align="left">匹配至少X个n，至多Y个n的字符串</td>
</tr>
<tr>
<td align="left">n$</td>
<td align="left">任何结尾为n的字符串</td>
</tr>
<tr>
<td align="left">^n</td>
<td align="left">任何开头为n的字符串</td>
</tr>
<tr>
<td align="left">?=n</td>
<td align="left">匹配任何后面紧接着n的字符串,如/I(?= am)/匹配”I am Maojiankai”中的I</td>
</tr>
<tr>
<td align="left">?!n</td>
<td align="left">匹配任何其后紧接指定字符串n的字符串</td>
</tr>
</tbody></table>
<h5 id="4-RegExp对象方法"><a href="#4-RegExp对象方法" class="headerlink" title="4.RegExp对象方法"></a>4.RegExp对象方法</h5><pre><code>RegExpObject.exec(String) 返回匹配的值，如匹配失败返回Null
RegExpObject.test(String) 返回是否匹配，返回类型为布尔型
RegExpObject.toString() 返回正则表达式的字符串类型</code></pre><h5 id="5-支持正则表达式的String对象方法"><a href="#5-支持正则表达式的String对象方法" class="headerlink" title="5.支持正则表达式的String对象方法"></a>5.支持正则表达式的String对象方法</h5><pre><code>String.search(查找的字符串或者正则表达式) 返回匹配位置。 
String.match(正则表达式) 找到一个或多个正则表达式匹配的值不过这依赖于g修饰符,否则和search()功能一致。
String.replace(要替换字符串或正则表达式，新字符串) 返回被替换操作后的整个字符串。
String.split(字符串或正则表达式) 将字符串按指定参数分割为字符串数组，如果参数为空则不改变原字符，如果参数为&quot;&quot;则每个字符都会被分割。</code></pre><h3 id="二、JavaScript异常处理"><a href="#二、JavaScript异常处理" class="headerlink" title="二、JavaScript异常处理"></a>二、JavaScript异常处理</h3><p>与Java处理异常有相似之处，由try、catch、throw关键字组成。</p>
<pre><code>基本格式：
try{
    代码块
    [throw抛出异常]
}catch(error异常变量){
    异常处理代码.
}finally{
...    //结束处理
}
这里需要注意，try喝catch是成对出现的。finally使得不论是否产生异常都会执行其下代码块。</code></pre><h3 id="三、变量提升和严格模式"><a href="#三、变量提升和严格模式" class="headerlink" title="三、变量提升和严格模式"></a>三、变量提升和严格模式</h3><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript允许先使用变量，后声明。</p>
<pre><code>a=5;
console.log(a) \\5
var a;
console.log(a) \\5</code></pre><p>这被称为变量的提升。需要注意的是初始化不会被提升：</p>
<pre><code>console.log(a);\\undefined
var a=9; //这里a被提升了，但是a=9并未被提升，所以只是声明了a，所以a=undefined</code></pre><h4 id="严格模式（strict-mode）"><a href="#严格模式（strict-mode）" class="headerlink" title="严格模式（strict mode）"></a>严格模式（strict mode）</h4><p> 严格模式下不能使用未声明变量。严格模式的声明只能是在脚本或函数的头部添加:</p>
<pre><code>&quot;use strict&quot;;</code></pre><h5 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h5><ol>
<li>不允许使用未声明变量(对象也是一个变量)</li>
<li>不允许删除变量</li>
<li>不允许删除函数</li>
<li>不允许变量重名<code>funciton a(p1,p1);</code></li>
<li>不允许使用八进制<code>var x=010;</code></li>
<li>不允许使用转义字符<code>var x=\010;</code><br><a href="http://www.runoob.com/js/js-strict.html" target="_blank" rel="noopener" title="更多限制信息">http://www.runoob.com/js/js-strict.html</a></li>
</ol>
<h3 id="四、JavaScript表单验证"><a href="#四、JavaScript表单验证" class="headerlink" title="四、JavaScript表单验证"></a>四、JavaScript表单验证</h3><p> HTML表单自动验证，在HTML中为<code>input</code>添加<code>required=&quot;required&quot;</code>属性后，如果该字段的值为空，浏览器会组织表单提交。</p>
<p>一般为<code>form</code>标签添加<code>onsubmit=&quot;return 验证方法（）&quot;</code>用来实现点击提交后的表单验证。</p>
<h4 id="HTML约束验证"><a href="#HTML约束验证" class="headerlink" title="HTML约束验证"></a>HTML约束验证</h4><p>HTML5中新增的表单验证方式，基于:</p>
<ul>
<li>HTML输入属性</li>
<li><a href="http://www.runoob.com/css/css-pseudo-classes.html" target="_blank" rel="noopener">CSS伪类选择器</a></li>
<li>DOM属性和方法</li>
</ul>
<h5 id="约束验证HTML输入属性"><a href="#约束验证HTML输入属性" class="headerlink" title="约束验证HTML输入属性"></a>约束验证HTML输入属性</h5><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">disabled</td>
<td align="left">规定输入的元素不可用</td>
</tr>
<tr>
<td align="left">max,min</td>
<td align="left">规定输入元素的最大最小值</td>
</tr>
<tr>
<td align="left">required</td>
<td align="left">规定输入元素字段是必需的</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">规定输入元素的类型</td>
</tr>
<tr>
<td align="left"><a href="http://www.runoob.com/html/html5-form-attributes.html" target="_blank" rel="noopener">更多HTML输入属性</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="约束验证DOM"><a href="#约束验证DOM" class="headerlink" title="约束验证DOM"></a>约束验证DOM</h5><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><pre><code>checkValidity(); 返回input元素中数据是否合法
setCustomValidity();设置input元素的vilidationMessage属性值，设置前需要将属性值设
置为空(&quot;&quot;或null或undefined)，经过checkValidity()
判断后再设置其他自定义值，否则checkValidity()的值始终为false。</code></pre><h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><pre><code>validity;返回input元素输入值是否合法
validationMessage;浏览器错误提示
willValidate;指定input是否需要验证(由input是否设置required属性确定)返回布尔值</code></pre><h3 id="五、JavaScript的this关键字"><a href="#五、JavaScript的this关键字" class="headerlink" title="五、JavaScript的this关键字"></a>五、JavaScript的this关键字</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><ul>
<li>在方法中,this指向该方法所属的对象</li>
<li>如果单独使用,this指向全局对象</li>
<li>在函数中，this 表示全局对象</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<blockquote>
<p>与Java中的this基本无差异</p>
</blockquote>
<h4 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h4><p>显式函数绑定。利用apply()和call()这两个函数对象的方法,允许函数切换this绑定的对象</p>
<pre><code>var person1 = {
  fullName: function() {
    return this.firstName + &quot; &quot; + this.lastName;
  }
}
var person2 = {
  firstName:&quot;John&quot;,
  lastName: &quot;Doe&quot;,
}
person1.fullName.call(person2);  // 返回 &quot;John Doe&quot;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>正则表达式是用于检索或替换字符串用的，格式一般为/模式/修饰符。</li>
<li>HTML的表单验证中可以运用到正则表达式也可以用HTML约束验证。</li>
<li>Js异常处理与Java无异，由try-catch关键子构成</li>
<li>this关键字与Java中一致，Js中可以通过apply()和call()这两个函数对象方法来切换函数中this指向。</li>
</ol>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS入门</title>
    <url>/2019/01/19/JS%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、js的输出"><a href="#一、js的输出" class="headerlink" title="一、js的输出"></a>一、js的输出</h2><p>JavaSctipt没有任何打印输出的函数或方法</p>
<ol>
<li>window.alert()浏览器警告框</li>
<li>document.write()方法可以将内容写入到Html中（如果在写入流结束后再使用将会覆盖整个HTML）</li>
<li>innerHTML 写入与读取HTML元素</li>
<li>console.log()在浏览器控制台输出</li>
</ol>
<a id="more"></a>

<h2 id="二、js的基本语法"><a href="#二、js的基本语法" class="headerlink" title="二、js的基本语法"></a>二、js的基本语法</h2><p>###（1）JavaScript的常量称为字面量。所有字面量类型有：###<br>    1.数字(Number)<br>    2.字符串(String)<br>    3.数组(Array)<br>    4.对象(Object)<br>    5.函数(Function)<br>    6.表达式    </p>
<h3 id="2-JavaScript中变量一般由var来进行定义"><a href="#2-JavaScript中变量一般由var来进行定义" class="headerlink" title="(2)JavaScript中变量一般由var来进行定义"></a>(2)JavaScript中变量一般由var来进行定义</h3><pre><code>var a=0,b;
b=0;
/*注释 a=0,b=0 */</code></pre><h3 id="3-JavaScript-中，常见的是小驼峰法的命名规则，如-lastName-而不是lastname"><a href="#3-JavaScript-中，常见的是小驼峰法的命名规则，如-lastName-而不是lastname" class="headerlink" title="(3)JavaScript 中，常见的是小驼峰法的命名规则，如 lastName(而不是lastname)"></a>(3)JavaScript 中，常见的是小驼峰法的命名规则，如 lastName(而不是lastname)</h3><pre><code>变量的三种命名方法：
var firstName=&apos;king&apos;;//小驼峰
var FirstName=&apos;queen&apos;;//大驼峰
var first_name=&apos;maizi&apos;;//下划线法</code></pre><h2 id="三、JavaScript的数据类型"><a href="#三、JavaScript的数据类型" class="headerlink" title="三、JavaScript的数据类型"></a>三、JavaScript的数据类型</h2><pre><code>JavaScript中的基本类型可以分为：
基本数据类型:Number(数字)、String（字符串）、布尔型(Boolean)、对空（Null）、未定义(Undefined)、Symbol
引用类型:对象(Object)、数组(Array)、函数(Function)</code></pre><h3 id="1-创建数组的三种方法"><a href="#1-创建数组的三种方法" class="headerlink" title="(1)创建数组的三种方法"></a>(1)创建数组的三种方法</h3><pre><code>1.var cha=new Array(&quot;123&quot;,&quot;456&quot;);
2.var cha=new Array();
  cha[0]=&quot;123&quot;;
  cha[1]=&quot;456&quot;;
3.var cha=[&quot;123&quot;,&quot;456&quot;];</code></pre><h3 id="2-创建对象的方法"><a href="#2-创建对象的方法" class="headerlink" title="(2)创建对象的方法"></a>(2)创建对象的方法</h3><pre><code>1.    
var person={
    name=&quot;jone&quot;,
    sex=&quot;男&quot;,
    id=&quot;123456&quot;
}
2.键值对的容器，“键”必须为字符串
var person={
    &quot;name&quot;:&quot;小明&quot;,
    &quot;age&quot;:&quot;18&quot;,
    &quot;like&quot;:function(){
            return &quot;喜欢打篮球,弹吉他&quot;;
    }
}
/*对象属性的2种寻址方式:*/
person.name;
person[&quot;name&quot;];</code></pre><h3 id="3-声明变量类型"><a href="#3-声明变量类型" class="headerlink" title="(3)声明变量类型"></a>(3)声明变量类型</h3><pre><code>var carname=new String;
var x=      new Number;
var y=      new Boolean;
var cars=   new Array;
var person= new Object;</code></pre><h3 id="4-函数的一般格式"><a href="#4-函数的一般格式" class="headerlink" title="(4)函数的一般格式"></a>(4)函数的一般格式</h3><pre><code>function 函数名(形参列表){
    ……
}</code></pre><h3 id="5-给未声明的变量赋值"><a href="#5-给未声明的变量赋值" class="headerlink" title="(5)给未声明的变量赋值"></a>(5)给未声明的变量赋值</h3><p> 如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。<br>    carname=”haha”;<br>    console.log(window.carname)//haha</p>
<pre><code>/*给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。*/    
delete carname;//正常删除（只有可配置的属性才能delete）</code></pre><h2 id="四、JavaScript的作用域"><a href="#四、JavaScript的作用域" class="headerlink" title="四、JavaScript的作用域"></a>四、JavaScript的作用域</h2><h3 id="JavaScript中作用域的探讨范围是：可访问变量、对象和函数。"><a href="#JavaScript中作用域的探讨范围是：可访问变量、对象和函数。" class="headerlink" title="JavaScript中作用域的探讨范围是：可访问变量、对象和函数。"></a>JavaScript中作用域的探讨范围是：可访问变量、对象和函数。</h3><pre><code>作用域可以分为全局变量和局部变量。
在函数外定义的变量为全局变量，而在函数内定义的变量为局部变量。
全局作用域: 网页中所有脚本和函数均可使用。
局部变量:仅在声明的函数中可用</code></pre><p>全局变量，或者函数，可以覆盖 window 对象的变量或者函数。局部变量，包括 window 对象可以覆盖全局变量和函数 </p>
<blockquote>
<p>ES6中加入let和const来定义变量。const是用于声明常量，增加了安全性。用var定义的变量只能是全局有效或者整个函数块有效，而let声明的变量、语句或者表达式允许你只在本级代码块中使用。</p>
</blockquote>
<h2 id="五、JavaScript事件"><a href="#五、JavaScript事件" class="headerlink" title="五、JavaScript事件"></a>五、JavaScript事件</h2><h3 id="1-HTML中添加事件属性"><a href="#1-HTML中添加事件属性" class="headerlink" title="(1)HTML中添加事件属性"></a>(1)HTML中添加事件属性</h3><pre><code>&lt;标签名 事件属性名=&quot;……代码&quot;&gt;&lt;/标签名&gt;</code></pre><h3 id="2-在js中为相关元素添加事件属性"><a href="#2-在js中为相关元素添加事件属性" class="headerlink" title="(2)在js中为相关元素添加事件属性"></a>(2)在js中为相关元素添加事件属性</h3><pre><code>在HTML中:
&lt;button id=&quot;test&quot; onclick=&quot;check()&quot;&gt;检查&lt;/button&gt;
在js中:
var test=document.getElementById(&quot;test&quot;);
test.onclick=check();</code></pre><h3 id="3-常用的事件属性名"><a href="#3-常用的事件属性名" class="headerlink" title="(3)常用的事件属性名"></a>(3)常用的事件属性名</h3><table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">浏览器已完成页面的加载</td>
</tr>
<tr>
<td align="left"><a href="http://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener" title="更多事件">http://www.runoob.com/jsref/dom-obj-event.html</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="六、JavaScript数据类型转换"><a href="#六、JavaScript数据类型转换" class="headerlink" title="六、JavaScript数据类型转换"></a>六、JavaScript数据类型转换</h2><pre><code>Number()转换为数字,String()转换为字符串,Boolean()转换为布尔型</code></pre><p>5种数据类型: string,number,boolean,,object,function</p>
<p>3种对象类型：Object，Date,Array</p>
<p>2种不包含任何值的数据类型：null,undefined</p>
<blockquote>
<p>可以利用typeof操作符来查看数据类型。</p>
<p>注：NaN的数据类型是number,Array和Date以及null的数据类型是object,未定义变量的数据类型为undefined</p>
</blockquote>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建手册</title>
    <url>/2018/07/25/Hexo%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<blockquote>
<p>起源：</p>
<p>博客是一项被我误认为已经快消失殆尽的信息表达形式，简直是上一个时代的东西。直到大一，自己对博客才有了一个全新的认识，好记性不如烂键盘，博客可以详细的记载下在学习过程中遇到的那些扎心知识点和自己对其的见解。并且可以展示出来，这样假如有错误也能够最快程度的发现。因此萌生了一个自己建一个博客的想法。</p>
<p>后来接触了CSDN以及博客园，平台里的文章虽然相当不错，但是在页面美化上总是不尽人意。直到遇见了Hexo，嗯？原来还能这样玩！</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hexo是一个十分高效、简洁的博客框架。因为这个框架的诞生，促使了许多有趣又好看的主题的汇入，而Next就是其中之一。由于Hexo是基于Node.JS的，所以在接下来要介绍的安装教程中我们需要安装Node.JS。</p>
<a id="more"></a>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><blockquote>
<p>目前环境：</p>
<ul>
<li>Windows_NT 10.0.17134</li>
<li>Node.JS v9.11.1</li>
<li>Git v2.17.1</li>
</ul>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>预先下载好一下软件：</li>
</ol>
<ul>
<li><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.JS</a></li>
<li><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a></li>
</ul>
<ol start="2">
<li><p>检查：</p>
<ol>
<li><p>桌面空白处右击，选择Git Bash Here。(如果没有，则说明Git安装失败)</p>
</li>
<li><p>打开后，输入<code>node -v</code>回车（如果没有显示版本号，则Node.JS安装失败）</p>
</li>
<li><p>继续输入<code>npm -version</code>回车(如果没有则需要额外添加变量环境)</p>
<p>以上出现的问题都可以在百度中找到解决方案，在此不再赘述。</p>
</li>
</ol>
</li>
</ol>
<h3 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul>
<li><p>新建一个你自己的博客文件夹</p>
</li>
<li><p>在建好的博客文件夹里打开Git Bash Here,输入<code>npm install hexo-cli -g</code>回车。</p>
</li>
<li><p>等待安装完毕后输入<code>hexo -v</code>可以看到hexo的版本信息。</p>
<blockquote>
<p>有些文章说安装时hexo可能会被墙，导致安装失败，可以尝试输入<code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code>命令，不过第一个命令在我这里是有效的。</p>
</blockquote>
</li>
<li><p>输入<code>hexo init</code>进行初始化。初始化成功后会生成下列文件<img src="https://i.imgur.com/pCCVxlP.jpg" alt=""></p>
</li>
<li><p>输入<code>hexo s</code>此时本地博客端口就已经打开了，在浏览器地址栏中输入<code>http://localhost:4000/</code>即可看到Hexo默认博客页面了。</p>
</li>
</ul>
<h2 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h2><ol>
<li>在已有的GitHub中新建一个仓库，仓库的名称格式务必为：<code>username.github.io</code>。之后点击确定即可。<img src="https://i.imgur.com/WxA5Z2H.png" alt=""></li>
<li>为GitHub与Git通过SSH进行绑定<ol>
<li>git中输入<code>ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</code>（你的github账号绑定的邮箱） 连续3次回车。</li>
<li>直到出现下列信息：<img src="https://i.imgur.com/FB8g976.png" alt=""></li>
<li>根据到绿框中的路径，找到并复制<code>id_rsa.pub</code>文件中的内容</li>
<li>进入到GitHub的账户设置中，找到<code>SSH and GPG keys</code>这个选项卡中，选择New SSH key。标题任意，然后将刚刚复制的Key信息粘贴到文本框中。<img src="https://i.imgur.com/gSMqFf9.png" alt=""></li>
<li>git中输入命令<code>npm install --save hexo-deployer-git</code></li>
<li>git中输入命令<code>git config --global user.email &quot;xxxx@xxx.com&quot;</code></li>
</ol>
</li>
<li>更改你博客中的配置文件<code>_config.yml</code>,修改<code>deploy</code>项为<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></li>
<li>依次输入命令<code>hexo g</code>和<code>hexo d</code>完成部署。如出现一下对话框，则输入<code>yes</code>即可。<img src="https://i.imgur.com/cwboOyp.png" alt=""></li>
<li>在你刚刚创建的仓库的设置中，下拉找到<code>Github Pages</code>，Source中选择master并保存<img src="https://i.imgur.com/xuCGN9w.jpg" alt=""></li>
</ol>
<p>这时你就可以通过浏览器输入<code>http://username.github.io</code>来访问属于你的Hexo博客了。并且你可以为你的hexo博客绑定自己的域名（<strong>这部分如不需要绑定则可以忽略</strong>）：</p>
<ol>
<li>在你刚刚创建的仓库的设置中，下拉找到Github Page ,在箭头指向的文本框中输入你的域名，并Save保存。<img src="https://i.imgur.com/IWZ8uY9.png" alt=""></li>
<li>打开hexo站点配置文件<code>_config.yml</code><img src="https://i.imgur.com/1Sk68un.png" alt=""></li>
<li>修改你的url项（注意：冒号后务必空一格再输入你的信息！）。<img src="https://i.imgur.com/y3Or2iC.png" alt=""></li>
<li>在<code>Source</code>文件夹中添加<code>CNAME</code>文件（无后缀），里面内容写入为你自己的域名<code>xxxx.xx</code>（前面没有http://）保存即可。</li>
<li>输入<code>hexo d</code> 完成部署。</li>
</ol>
<h2 id="Hexo发布博客"><a href="#Hexo发布博客" class="headerlink" title="Hexo发布博客"></a>Hexo发布博客</h2><p>hexo博客文章是支持markdown的，所以可以下载一个markdown编辑器。我用的是<a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a>。</p>
<blockquote>
<p>起初我看到它专业版的价格是14块钱左右，当时那个内心简直是版权心爆棚，（我就是饿死，从这跳下去！我也要买正版！），后来一看是美元，免费密匙真香~</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">邮箱：</span><br><span class="line"></span><br><span class="line">Soar360<span class="meta">@live</span>.com</span><br><span class="line"></span><br><span class="line">授权秘钥：</span><br><span class="line"></span><br><span class="line">GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5<span class="regexp">/sQytXJUQl/</span>QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb<span class="regexp">/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/</span>eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</span><br></pre></td></tr></table></figure>
<ol>
<li>改语言（英语大佬请无视）<code>Tools</code>-&gt;<code>Options</code>页面</li>
<li>升级为专业版：<code>帮助</code>-&gt;<code>升级为专业版</code>对应输入邮箱和密匙即可</li>
<li>右侧预览窗口出现“This view has crashed!”错误（如没有请无视）。解决方法：下载<a href="http://117.143.109.141/cache/markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe?ich_args2=134-25164704011207_568bfa3c404598c914c9fbb247dffd70_10001002_9c89672ed2c3f9d5933a518939a83798_04f69856e11e874892cdb4f3c7e1015a" target="_blank" rel="noopener">Awesomium 1.6.6 SDK</a>，安装完成后重启MP即可。</li>
</ol>
<p>准备工作完成后即可开始创建博客文章：</p>
<ol>
<li>在博客根目录下打开git，输入<code>hexo new &#39;博客名称&#39;</code></li>
<li>在source文件夹的_posts文件夹中找到刚刚创建的博客，进行编辑即可</li>
<li>编辑完成保存文件后，可以输入<code>hexo s</code>命令进行预览。</li>
</ol>
<h2 id="Hexo的主题"><a href="#Hexo的主题" class="headerlink" title="Hexo的主题"></a>Hexo的主题</h2><p>Hexo拥有丰富的主题和插件，所以你可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>上预览这些主题并渲染在自己的博客上。<img src="https://i.imgur.com/cmIb6XG.jpg" alt=""><br>通常，主题的github链接在主题的底部，将它从github上clone或下载下来。并存放在你博客的themes文件夹中。最后修改配置文件<code>_config.yml</code>中的<code>theme</code>为<code>theme: 主题名称</code>。</p>
<h2 id="Hexo根目录文件信息解释"><a href="#Hexo根目录文件信息解释" class="headerlink" title="Hexo根目录文件信息解释"></a>Hexo根目录文件信息解释</h2><ol>
<li><p>scaffolds ：三种默认布局的模板文件的存放处，分别是：draft 、page 以及post三种格式。</p>
</li>
<li><p>source ：用于存放博客和其他信息</p>
</li>
<li><p>themes ：主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
</li>
<li><p>_config.yml ：全局的配置文件，每次更改要重启服务。</p>
</li>
</ol>
<h3 id="站点配置文件解释"><a href="#站点配置文件解释" class="headerlink" title="站点配置文件解释"></a>站点配置文件解释</h3><ol>
<li><p>网站（Site）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">参数</span>              <span class="string">描述</span></span><br><span class="line"><span class="attr">title</span>           <span class="string">网站标题</span></span><br><span class="line"><span class="attr">subtitle</span>        <span class="string">网站副标题</span></span><br><span class="line"><span class="attr">description</span>     <span class="string">网站描述</span></span><br><span class="line"><span class="attr">author</span>          <span class="string">您的名字</span></span><br><span class="line"><span class="attr">language</span>        <span class="string">网站使用的语言</span></span><br><span class="line"><span class="attr">timezone</span>        <span class="string">网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br></pre></td></tr></table></figure>
<p>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p>
</li>
<li><p>网址（URL）</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">参数                 描述                       默认值</span><br><span class="line">url                  网址     </span><br><span class="line">root               网站根目录    </span><br><span class="line">permalink         文章的永久链接格式      <span class="symbol">:year/</span><span class="symbol">:month/</span><span class="symbol">:day/</span><span class="symbol">:title/</span></span><br><span class="line">permalink_defaults  永久链接中各部分的默认值</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录（Directory）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">参数</span>                 <span class="string">描述   </span></span><br><span class="line"><span class="attr">source_dir</span>       <span class="string">资源文件夹，这个文件夹用来存放内容。     </span></span><br><span class="line"><span class="attr">public_dir</span>       <span class="string">公共文件夹，这个文件夹用于存放生成的站点文件。 </span></span><br><span class="line"><span class="attr">tag_dir</span>          <span class="string">标签文件夹  </span></span><br><span class="line"><span class="attr">archive_dir</span>      <span class="string">归档文件夹  </span></span><br><span class="line"><span class="attr">category_dir</span>     <span class="string">分类文件夹  </span></span><br><span class="line"><span class="attr">code_dir</span>         <span class="string">Include code 文件夹   </span></span><br><span class="line"><span class="attr">i18n_dir</span>         <span class="string">国际化（i18n）文件夹   </span></span><br><span class="line"><span class="attr">skip_render</span>      <span class="string">跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写作（Writing）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">参数</span>                  <span class="string">描述  </span></span><br><span class="line"><span class="attr">new_post_name</span>       <span class="string">新文章的文件名称    </span></span><br><span class="line"><span class="attr">default_layout</span>      <span class="string">预设布局    </span></span><br><span class="line"><span class="attr">auto_spacing</span>        <span class="string">在中文和英文之间加入空格    </span></span><br><span class="line"><span class="attr">titlecase</span>           <span class="string">把标题转换为 title case   </span></span><br><span class="line"><span class="attr">external_link</span>       <span class="string">在新标签中打开链接 </span></span><br><span class="line"><span class="attr">filename_case</span>       <span class="string">把文件名称转换为 (1) 小写或 (2) 大写     </span></span><br><span class="line"><span class="attr">render_drafts</span>       <span class="string">显示草稿    </span></span><br><span class="line"><span class="attr">post_asset_folder</span>   <span class="string">启动 Asset 文件夹    </span></span><br><span class="line"><span class="attr">relative_link</span>       <span class="string">把链接改为与根目录的相对位址  </span></span><br><span class="line"><span class="attr">future</span>              <span class="string">显示未来的文章     </span></span><br><span class="line"><span class="attr">highlight</span>           <span class="string">代码块的设置</span></span><br></pre></td></tr></table></figure></li>
<li><p>分类&amp;标签(Category &amp; Tag)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">参数</span>                  <span class="string">描述          默认值</span></span><br><span class="line"><span class="attr">default_category</span>    <span class="string">默认分类    uncategorized</span></span><br><span class="line"><span class="attr">category_map</span>        <span class="string">分类别名    </span></span><br><span class="line"><span class="attr">tag_map</span>             <span class="string">标签别名</span></span><br></pre></td></tr></table></figure></li>
<li><p>时间/日期格式(Date / Time format)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">参数              描述      默认值</span><br><span class="line"><span class="selector-tag">date_format</span>     日期格式    <span class="selector-tag">YYYY-MM-DD</span></span><br><span class="line"><span class="selector-tag">time_format</span>     时间格式    <span class="selector-tag">H</span><span class="selector-pseudo">:mm</span><span class="selector-pseudo">:ss</span></span><br></pre></td></tr></table></figure></li>
<li><p>分页（Pagination）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">参数          描述                              默认值</span><br><span class="line">per_page    每页显示的文章量 (<span class="number">0</span> = 关闭分页功能)   <span class="number">10</span></span><br><span class="line">pagination_dir  分页目录                        page</span><br></pre></td></tr></table></figure></li>
<li><p>扩展(Extensions)</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">参数          描述</span><br><span class="line"><span class="built_in">theme</span>       当前主题名称。值为<span class="literal">false</span>时禁用主题</span><br></pre></td></tr></table></figure></li>
<li><p>部署(Deployment)</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">参数          描述</span><br><span class="line"><span class="keyword">deploy</span>      部署部分的设置</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hexo框架十分好用，搭建起来只要细心一下，也并不是太困难，还有一个类似的工具叫Jekyll。再选择一个强大的主题辅佐就更完美了，推荐Next主题。GitHub是一个面向开源及私有软件项目的托管平台,大约有300Mb的免费存储空间,毕竟也与微软喜结良缘了，所以会相对稳定很多，而Github Pages原本是用来展示github上项目用的。</p>
<p>大概是在6月中旬的时候把博客模模糊糊搭好，后续也一直在“解锁”新功能。当时也是按着网上各种教程说的一步一步走，但是遇到了不少坑，不得不自己再重新百度、调试、尝试。所以刚刚搭完那会儿就想写一个教程能让以后搭Hexo的人尽量的少走些弯路，但是由于时间关系一直拖到了现在。不多说了，这也算是找到以后写博客的归宿地了。<em>Hello world!</em></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>图的基本操作</title>
    <url>/2018/07/08/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h2><blockquote>
<p>图在数据结构中也是非常重要的逻辑结构之一，它比树（层次结构）要更为复杂。在图中，所有的链接点被称为“顶点”,图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)。图可以说是树与线性表的进阶版，可以实现多对多逻辑关系。当然，也可以实现一对多关系。在下文中将为详细介绍图的相关概念与应用实现。</p>
</blockquote>
<a id="more"></a>
<h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><p><strong>名词解释</strong></p>
<ol>
<li>邻接点。若无向图中顶点v,w之间存在一条边(v,w),称v,w互为邻接点。</li>
<li>顶点的度。<ul>
<li>无向图：与某一顶点相关联的边的个数，称为该顶点的度。</li>
<li>有向图：以某一顶点为弧头个数（简单来说都是只想该顶点的弧的个数）称之为该顶点的入度；以该顶点为弧尾的个数称之为该顶点的出度。</li>
</ul>
</li>
<li>简单路径。顶点不重复的路径成为简单路径。</li>
<li>回路，首尾顶点相同的路径称为回路。</li>
<li>简单回路，首尾顶点相同，但是其余任何一个顶点都不重复的回路，称之为简单回路。</li>
<li>生成树。在一个连通图中，通过对于边的删除能够将其转变为一棵树，而这棵树被称之为生成树。</li>
</ol>
<p>为了方便描述，现给出以下定义：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">图G由顶点的集合和边的集合构成，记作：G=(V,E)</span></span><br><span class="line"><span class="xml">顶点 V（G）=</span><span class="template-variable">&#123;顶点名1，……&#125;</span></span><br><span class="line"><span class="xml">边是两顶点之间的连线，记作：E(G)=</span><span class="template-variable">&#123;&lt;顶点A，顶点B&gt;，……&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="有向图和无向图"><a href="#有向图和无向图" class="headerlink" title="有向图和无向图"></a>有向图和无向图</h3><p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/IyHsbwm.jpg" alt=""></p>
<p>无向图是指两顶点直线只是单纯的至多由一根连接线相连的，对其方向没有限定，我们称这个连接线为边。一个顶点个数为n的无向图中，至多有（(n-1)*n/2）条边。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/qSDugjY.jpg" alt=""></p>
<p>有向图则对于方向做出了限定，其连接线被称为弧，有弧尾和弧头之分，带箭头一端为弧头。无向图顶点的边数叫做度。有向图顶点分为入度和出度，入度是指该顶点拥有的弧头个数，出度的指该顶点拥有的弧尾个数。一个顶点个数为n的无向图中，至多有((n-1)*n)条弧。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>它是图的二维数组存储方式。对于具有N个顶点的图来说，将会生成一个N行N列的二维数组。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/40QJhqk.jpg" alt=""></p>
<p>无向图的邻接矩阵是关于对角线对称的。列或者行中的1的个数代表该顶点的度。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/7TpzAAS.jpg" alt=""></p>
<p>而无向图的行中的1的个数代表该顶点的出度，而列中的1的个数代表该顶点的入度。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在一个有向图中始终找入度为0的顶点，读出一个将该顶点中去除，依次将所有顶点都读出，最后的结构可能不止一种，当然也有可能没有结果。例如下图中的有向图的拓扑排序结果可以是：</p>
<ol>
<li>ADBCEF</li>
<li>ABDECF</li>
<li>等等……</li>
</ol>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/HrOn9nf.jpg" alt=""></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>所谓图的遍历是指，将图中所有顶点都不重复的访问一遍。</p>
<h3 id="深度优先遍历（DBF）"><a href="#深度优先遍历（DBF）" class="headerlink" title="深度优先遍历（DBF）"></a>深度优先遍历（DBF）</h3><p>深度优先遍历是遍历图的两大法宝之一，其核心思想按照我数据结构老师的话来说就是“<strong>一直往前走，直到走不动</strong>”，也就是说，<em>在没访问过的顶点集合中，遇到能往下遍历的就往下遍历，当无法往下进行遍历时便回溯到上一个顶点，直到所有顶点都访问过为止</em>。因为遍历时由代码实现的，为了更加容易理解实现，所以用邻接矩阵来说明深度优先遍历操作。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/40QJhqk-20211111212631802.jpg" alt=""></p>
<blockquote>
<p>这个邻接矩阵就是上文中所介绍的。</p>
</blockquote>
<p>例如这个邻接矩阵，我们设A为起点，其深度优先遍历的过程为：</p>
<ol>
<li>从A行中，第一个邻接点是B,所以访问B</li>
<li>跳转到B行中，第一个未访问的邻接点是C,访问C</li>
<li>跳转到C行时，第一个未访问的邻接点是F,所有访问F</li>
<li>来到F行时，第一个未访问的邻接点是E,访问E</li>
<li>E行中，第一个未访问的邻接点是D</li>
</ol>
<p>至此，我们的遍历工作就已经完成了。其结果是(A,B,C,F,E,D)</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><blockquote>
<p>需要额外创建一个用于保存对应顶点是否被访问过的数组Visits[]。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="comment">/*返回当前顶点的第一个邻接点的位置*/</span></span><br><span class="line"><span class="built_in">int</span> First(PGraph PG, <span class="built_in">int</span> t) &#123;</span><br><span class="line">	<span class="keyword">if</span> (PG == NULL)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (t &lt; <span class="number">0</span> || t &gt;= PG-&gt;Vexnums)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; PG-&gt;Vexnums; i++)</span><br><span class="line">		<span class="keyword">if</span> (PG-&gt;AjMx[t][i] != INF &amp;&amp; i != t)<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回当前顶点相对于邻接点w之后的第一个邻接点的位置*/</span></span><br><span class="line"><span class="built_in">int</span> next(PGraph PG, <span class="built_in">int</span> w, <span class="built_in">int</span> t) &#123;</span><br><span class="line">	<span class="keyword">if</span> (PG == NULL)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (t &lt; <span class="number">0</span> || t &gt;= PG-&gt;Vexnums)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (w &lt; <span class="number">0</span> || w &gt;= PG-&gt;Vexnums)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = w+<span class="number">1</span>; i &lt; PG-&gt;Vexnums; i++)</span><br><span class="line">		<span class="keyword">if</span> (PG-&gt;AjMx[t][i] != INF &amp;&amp; i != t)<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> DBF(PGraph PG, <span class="built_in">int</span> *Visits, <span class="built_in">int</span> T) &#123;</span><br><span class="line">	Visits[T] = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; PG-&gt;Vexs[T];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> w = First(PG, T); w !=<span class="number">-1</span>; w = next(PG, w, T))&#123;</span><br><span class="line">		<span class="keyword">if</span> (Visits[w] == <span class="number">0</span>) </span><br><span class="line">			DBF(PG,Visits,w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> DBFmain(PGraph PG) &#123;</span><br><span class="line">	<span class="keyword">if</span> (PG == NULL)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> *Visits = new <span class="built_in">int</span>[PG-&gt;Vexnums];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;PG-&gt;Vexnums;i++)  <span class="comment">//为浏览记录器Visits数组初始化为0</span></span><br><span class="line">			Visits[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; PG-&gt;Vexnums; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (Visits[i] == <span class="number">0</span>)</span><br><span class="line">			DBF(PG, Visits, i);</span><br><span class="line">	&#125;<span class="comment">//图还存在”孤岛“或”孤岛群“，所以为了能够完整遍历所有顶点，要嵌套一个循环</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	delete []Visits;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历图"><a href="#广度优先遍历图" class="headerlink" title="广度优先遍历图"></a>广度优先遍历图</h3><p>广度优先遍历，并不再像深度优先遍历那样一直往底走，而是类似于树的层次遍历那样，广度得一层一层往底部走。直到所有得顶点都遍历完毕。例如下图：</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/IyHsbwm-20211111212636938.jpg" alt=""></p>
<p>在该图中，我们默认以A为起点，开展如下步骤：</p>
<ol>
<li>因为A有两个未访问的邻接点，依次输出他们：B、D。</li>
<li>在B中有两个未访问的邻接点，依次输出 C、E.</li>
<li>D中的E已经访问过了，所以无输出。</li>
<li>C中有一个未访问的邻接点，输出F。</li>
<li>E中的F也刚刚被访问过，所以依然无输出。</li>
<li>所有顶点都已访问完毕，遍历结果为 <strong>ABDCEF</strong></li>
</ol>
<p>实际上广度优先遍历比深度优先遍历要更好理解，在代码实现也更加有意思。</p>
<h4 id="BFS代码实现"><a href="#BFS代码实现" class="headerlink" title="BFS代码实现"></a>BFS代码实现</h4><p>第一个要解决的问题就是——<strong>如何做到知道某一顶点的将要访问的邻接点，然后再下去访问同层的下一顶点</strong>（广度优先的规则就是访问完同层顶点后才能按顺序去访问他们各自的下一层邻接顶点）。</p>
<blockquote>
<p>例如在上面举得例子中，访问完B后如何让计算机知道B的两个邻接点C、E的情况下去把D访问掉，并且知道D有一个邻接点E,依次访问下去。</p>
</blockquote>
<p>一种很巧妙的逻辑结构完美的解决了这个问题，它就是队列。由于队列具有先进先出的特性，所以我们只需要每次都把某顶点N的所有未访问邻接点都入队，然后将顶点N出队就可以了。代码如下，需要大家自己耐心琢磨：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*广度优先遍历图*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(PGraph PG)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Front,Rear; </span><br><span class="line">	Front=Rear=<span class="number">0</span>;<span class="comment">//初始化队头和队尾 </span></span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">queue</span>=<span class="keyword">new</span> <span class="keyword">int</span>[PG-&gt;Vexnums]; <span class="comment">//按广度优先顺序保存索引的队列 </span></span><br><span class="line">	<span class="keyword">int</span> *Visits=<span class="keyword">new</span> <span class="keyword">int</span>[PG-&gt;Vexnums];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;PG-&gt;Vexnums;i++)Visits[i]=<span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;PG-&gt;Vexnums;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(Visits[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;PG-&gt;Vexs[i]; <span class="comment">//输出起点或者另外连通子图的起点 </span></span><br><span class="line">			Visits[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> w=First(PG,i);w!=<span class="number">-1</span>;w=next(PG,w,i))&#123;</span><br><span class="line">				<span class="keyword">if</span>(Visits[w]==<span class="number">0</span>)&#123;</span><br><span class="line">					Visits[w]=<span class="number">1</span>;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;PG-&gt;Vexs[w];</span><br><span class="line">					<span class="built_in">queue</span>[++Rear]=w;  <span class="comment">//输出当前顶点的邻接点，并按顺序将这些邻接点的索引入队 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(Front!=Rear)&#123; </span><br><span class="line">			<span class="keyword">int</span> k=<span class="built_in">queue</span>[++Front];<span class="comment">//依次出队，输出该顶点下的所有未访问过的邻接点，并将他们的索引入队 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> w=First(PG,k);w!=<span class="number">-1</span>;w=next(PG,w,k))&#123;</span><br><span class="line">				<span class="keyword">if</span>(Visits[w]==<span class="number">0</span>)&#123;</span><br><span class="line">					Visits[w]=<span class="number">1</span>;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;PG-&gt;Vexs[w];</span><br><span class="line">					<span class="built_in">queue</span>[++Rear]=w;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> []<span class="built_in">queue</span>;</span><br><span class="line">	<span class="keyword">delete</span> []Visits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在一个带权连通图中，生成的路径之和最小的一棵生成树，被称之为最小生成树。实现最小生成树有两种方法，其中一种是易于理解的Prim算法，另外一种是根据贪心算法实现的Kruskal算法。</p>
<h3 id="Prim算法实现最小生成树"><a href="#Prim算法实现最小生成树" class="headerlink" title="Prim算法实现最小生成树"></a>Prim算法实现最小生成树</h3><p>其基本思想是：在一个初始化时只有起点的生成树E中，找这棵生成树中所有顶点连接边权值最小的邻接点，并且不能造成回路，直到这张连通图中的所有顶点都连接到这棵生成树之中为止。ps:让我想到了那句魔性广告词：开局只有一条狗，装备全靠打……</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/k4sw5fw.jpg" alt=""></p>
<p>例如上图中的带权连通图，我们设起点为A，设生成树为E:</p>
<ol>
<li>初始时，E中只有A顶点</li>
<li>最小邻接点有D，将D加入到E中E{&lt;A,D,1&gt;}</li>
<li>最小邻接点有B,E更新为E{&lt;A,D,1&gt;,&lt;A,B,7&gt;}</li>
<li>最小邻接点有C和F,优先选择C。E更新为E{&lt;A,D,1&gt;,&lt;A,B,7&gt;,&lt;D,C,8&gt;}</li>
<li>最小邻接点有E。E加入&lt;C,E,6&gt;</li>
<li>最小邻接点有G。E加入&lt;E,G,1&gt;</li>
<li>最小邻接点有F。E加入&lt;G,F,4&gt;</li>
</ol>
<p>最终得到的最小生成树为</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">E&#123;</span><br><span class="line">&lt;A,D,<span class="number">1</span>&gt;</span><br><span class="line">&lt;A,B,<span class="number">7</span>&gt;</span><br><span class="line">&lt;D,C,<span class="number">8</span>&gt;</span><br><span class="line">&lt;C,E,<span class="number">6</span>&gt;</span><br><span class="line">&lt;E,G,<span class="number">1</span>&gt;</span><br><span class="line">&lt;G,F,<span class="number">4</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而最小生成树的带权路径之和为27。</p>
<p>如果还是感觉上文中的式子不太清晰，那就再上图：</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/rpg3oB5.jpg" alt=""></p>
<h3 id="Kruskal算法实现最小生成树"><a href="#Kruskal算法实现最小生成树" class="headerlink" title="Kruskal算法实现最小生成树"></a>Kruskal算法实现最小生成树</h3><p>Kruskal算法的思想是：在带权连通图中，再没有找过的边中找权值最小的边且不能造成回路，直到生成树连接到所有的顶点为止。<br>上图中的例子来说，依然设生成树为E：</p>
<ol>
<li>权值最小的边有&lt;A,D,1&gt;和&lt;E,G,1&gt;,且两条边不会造成回路。分别加入到E中。</li>
<li>未选出的边中权值最小的边有&lt;F,G,4&gt;。加入到E中。</li>
<li>权值最小的边有&lt;C,E,6&gt;,加入到E中。</li>
<li>权值最小的边有&lt;A,B,7&gt;,加入到E中。</li>
<li>权值最小的边有&lt;D,C,8&gt;和&lt;D,E,8&gt;,可以任选一条，但是注意不能两条都选，会造成回路。我们选择&lt;D,C,8&gt;加入到E中。</li>
</ol>
<p>最终通过Kruskal算法得到的最小生成树为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">E&#123;</span><br><span class="line">&lt;A,D,<span class="number">1</span>&gt;</span><br><span class="line">&lt;E,G,<span class="number">1</span>&gt;</span><br><span class="line">&lt;F,G,<span class="number">4</span>&gt;</span><br><span class="line">&lt;C,E,<span class="number">6</span>&gt;</span><br><span class="line">&lt;A,B,<span class="number">7</span>&gt;</span><br><span class="line">&lt;D,C,<span class="number">8</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的基本操作</title>
    <url>/2018/06/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="二叉树简介"><a href="#二叉树简介" class="headerlink" title="二叉树简介"></a>二叉树简介</h2><blockquote>
<p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>
</blockquote>
<blockquote>
<p>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2(n+1)。深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/GXdDDAm.png" alt=""></p>
<h2 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树节点的数据成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;                   <span class="comment">//字符型节点数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span> *<span class="title">Lchild</span>;</span>  <span class="comment">//指向左孩子的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span> *<span class="title">Rchild</span>;</span>	 <span class="comment">//指向右孩子的指针</span></span><br><span class="line">&#125;BinNode,*BinTree;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的初始化操作"><a href="#二叉树的初始化操作" class="headerlink" title="二叉树的初始化操作"></a>二叉树的初始化操作</h3><p>所谓初始化就是将一颗二叉树由用户输入的数据构造出来。初始化的的方法由很多中，其中将会介绍的是利用先序&amp;中序 或者 中序&amp;后序 以及“扩展的先序遍历序列”共三种方法来构造二叉树。</p>
<h4 id="1-扩展的先序遍历序列构造二叉树。"><a href="#1-扩展的先序遍历序列构造二叉树。" class="headerlink" title="1.扩展的先序遍历序列构造二叉树。"></a>1.扩展的先序遍历序列构造二叉树。</h4><p>对于扩展的先序序列的二叉树是这样一颗二叉树的:所有的节点都有两个孩子(度&lt;2的用“^”补充完整)。如上图的二叉树扩展后为:<br><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/mLonNDC.png" alt=""><br>先序遍历后结果为:ABD^^E^^CF^^^。</p>
<blockquote>
<p>只需要输入整个先序遍历结果就可以构造一颗图中的二叉树。代码如下</p>
</blockquote>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">BinTree Create_Kz<span class="built_in">(string</span> Stemp)&#123;     //利用字符串作为暂时存放序列的介质 </span><br><span class="line">	BinNode <span class="built_in">*root</span>;</span><br><span class="line">	<span class="keyword">if</span>(Stemp[intemp++]==<span class="string">'^'</span><span class="built_in">)root</span>=NULL;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">	root</span>=new BinNode;</span><br><span class="line">	<span class="built_in">	root</span>-&gt;data=Stemp[intemp-<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">	root</span>-&gt;Lchild=Create_Kz(Stemp);</span><br><span class="line">	<span class="built_in">	root</span>-&gt;Rchild=Create_Kz(Stemp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span><span class="built_in"> root</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></br></br></p>
<h4 id="2-根据先序遍历与中序遍历的结果来构造二叉树"><a href="#2-根据先序遍历与中序遍历的结果来构造二叉树" class="headerlink" title="2.根据先序遍历与中序遍历的结果来构造二叉树"></a>2.根据先序遍历与中序遍历的结果来构造二叉树</h4><p>对于每一颗二叉树来说，先序遍历的第一个节点一定是根节点，中序遍历中，根节点的左边一点时左子树的所有节点，根节点的右边一定时右子树的所有节点，依照这个思路就可以通过先序和中序遍历得到一个完整的二叉树。</p>
<blockquote>
<p>先序序列时用来作为找根节点的依据，而找到根节点后就可以利用中序序列来分割出左右子树(如下图)，按相同的方法分别找到左右子树的根节点和其左右子树即可。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/pvahiaO.jpg" alt=""></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">char</span> ch,<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=start;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=<span class="built_in">end</span> &amp;&amp; s[i]!=ch)i++;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;<span class="built_in">end</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinTree <span class="title">Create_PI</span><span class="params">(<span class="built_in">string</span> Pre,<span class="keyword">int</span> Pstart,<span class="keyword">int</span> Pend,<span class="built_in">string</span> In,<span class="keyword">int</span> Istart,<span class="keyword">int</span> Iend)</span></span>&#123;   </span><br><span class="line">	BinTree Tree;<span class="comment">//参数说明-依次为: 先序序列,起点,终点,中序序列,起点,终点 </span></span><br><span class="line">	<span class="keyword">if</span>(Pstart&gt;Pend || Istart&gt;Iend) </span><br><span class="line">		Tree=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="built_in">find</span>(In,Pre[Pstart],Istart,Iend);<span class="comment">//查找该节点元素值在中序中的位置 </span></span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">-1</span>)&#123; </span><br><span class="line">			Tree=<span class="keyword">new</span> BinNode;</span><br><span class="line">			Tree-&gt;data=Pre[Pstart];</span><br><span class="line">			<span class="keyword">if</span>(i!=Istart)Tree-&gt;Lchild=Create_PI(Pre,Pstart+<span class="number">1</span>,Pstart+(i-Istart),In,Istart,i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">else</span> Tree-&gt;Lchild=<span class="literal">NULL</span>;  </span><br><span class="line">			<span class="keyword">if</span>(i!=Iend)Tree-&gt;Rchild=Create_PI(Pre,Pstart+(i-Istart)+<span class="number">1</span>,Pend,In,i+<span class="number">1</span>,Iend);</span><br><span class="line">			<span class="keyword">else</span> Tree-&gt;Rchild=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入数据有误"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//运行异常，结束程序 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-根据中序遍历与后序遍历的结果来构造二叉树"><a href="#3-根据中序遍历与后序遍历的结果来构造二叉树" class="headerlink" title="3.根据中序遍历与后序遍历的结果来构造二叉树"></a>3.根据中序遍历与后序遍历的结果来构造二叉树</h4><p>和第二中基本原理相同，不过有所改变的是二叉树的根节点在后序遍历中位于最后一个。</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/CSJUTtL.jpg" alt=""></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Create_AI</span><span class="params">(<span class="built_in">string</span> Aft,<span class="keyword">int</span> Astart,<span class="keyword">int</span> Aend,<span class="built_in">string</span> In,<span class="keyword">int</span> Istart,<span class="keyword">int</span> Iend)</span></span>&#123;</span><br><span class="line">	BinTree Tree;<span class="comment">//依次为:后序序列，后序起点，后序终点，中序序列，中序起点，中序终点 </span></span><br><span class="line">	<span class="keyword">if</span>(Astart&gt;Aend || Istart&gt;Iend)</span><br><span class="line">		Tree=<span class="literal">NULL</span>;  </span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Tree=<span class="keyword">new</span> BinNode;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="built_in">find</span>(In,Aft[Aend],Istart,Iend);</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">-1</span>)&#123;</span><br><span class="line">			Tree-&gt;data=Aft[Aend];<span class="comment">//或者可以赋值为In[i]; </span></span><br><span class="line">			<span class="keyword">if</span>(i!=Istart) Tree-&gt;Lchild=Create_AI(Aft,Astart,Astart+(i-Istart)<span class="number">-1</span>,In,Istart,i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">else</span> Tree-&gt;Lchild=<span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span>(i!=Iend) Tree-&gt;Rchild=Create_AI(Aft,Astart+i-Istart,Aend<span class="number">-1</span>,In,i+<span class="number">1</span>,Iend);</span><br><span class="line">			<span class="keyword">else</span> Tree-&gt;Rchild=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的数据有误"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><blockquote>
<p>基础的二叉树遍历方法有一下三种：</p>
</blockquote>
<blockquote>
<ol>
<li>先序遍历:访问次序为根节点-左子树-右子树。</li>
<li>中序遍历:访问次序为左子树-根节点-右子树。</li>
<li>后序遍历:访问次序为左子树-右子树-根节点。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/GXdDDAm-20211111212734739.png" alt=""></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>如图中二叉树，其先序遍历的过程如下：</p>
<ol>
<li>首先访问根节点A，然后访问A的左子树。</li>
<li>A的左子树的根节点是B，访问完毕。接下来访问B的左子树，B的左子树的根节点很显然是D</li>
<li>D无孩子，所以B的左子树已访问完毕。按照定义，我们访问B的右子树，其右子树的根节点为E</li>
<li>E无孩子，所以B的右子树也已访问完毕。此时我们已经遍历完根节点A的左子树了，我们只需要按照相同的方法访问A的右子树即可遍历完整颗二叉树。</li>
</ol>
<p>最后的遍历结果为：ABDECF</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>说完先序，其实中序的访问过程也大同小异，只不过调换了左子树和根节点的访问顺序。其遍历的过程如下:</p>
<ol>
<li>第一步是访问根节点A的左子树,对其左子树进行中序排序。<ol>
<li>其左子树是以B为根节点的子树，先访问B的左子树，其左子树无孩子所以直接访问其根节点D。</li>
<li>以B为根节点的子树的左子树已访问完毕，访问根节点B</li>
<li>接下来中序访问以B为根节点的子树的右子树。其右子树无孩子所以直接访问其根节点E</li>
</ol>
</li>
<li>根节点A的左子树中序访问完毕，访问根节点A</li>
<li>按照相同方法，中序访问根节点A的右子树。</li>
</ol>
<p>最后的遍历结果为: DBEAFC</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>最后是后序遍历，其与先序的差别就是先访问左子树和右子树，最后访问根节点，其过程如下:</p>
<ol>
<li>后序遍历根节点A的左子树<ol>
<li>后序遍历根节点B的左子树，因D无孩子，所以访问D后，B的左子树访问完毕。</li>
<li>后序遍历根节点B的右子树，因E无孩子，所以访问E后，B的右子树访问完毕。</li>
<li>最后访问根节点B。</li>
</ol>
</li>
<li>后序遍历根节点A的右子树<ol>
<li>后序遍历根节点C的左子树，因F无孩子，所以访问F后，C的左子树访问完毕。</li>
<li>C无右子树,所以直接跳到最后一步–访问C。</li>
</ol>
</li>
<li>最后访问根节点A</li>
</ol>
<p>后序遍历结果为: DEBFCA</p>
<p>C++递归实现：（先序，中序，后序）</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void Pre(BinTree root)&#123;  <span class="comment">//先序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">		<span class="function"><span class="title">cout</span>&lt;&lt;root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">		P<span class="function"><span class="title">re</span>(root-&gt;</span>Lchild);</span><br><span class="line">		P<span class="function"><span class="title">re</span>(root-&gt;</span>Rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void In(BinTree root)&#123; <span class="comment">//中序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">		I<span class="function"><span class="title">n</span>(root-&gt;</span>Lchild);</span><br><span class="line">		<span class="function"><span class="title">cout</span>&lt;&lt;root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">		I<span class="function"><span class="title">n</span>(root-&gt;</span>Rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Aft(BinTree root)&#123; <span class="comment">//后序遍历 </span></span><br><span class="line">	<span class="keyword">if</span>(root)&#123;</span><br><span class="line">		A<span class="function"><span class="title">ft</span>(root-&gt;</span>Lchild);</span><br><span class="line">		A<span class="function"><span class="title">ft</span>(root-&gt;</span>Rchild);</span><br><span class="line">		<span class="function"><span class="title">cout</span>&lt;&lt;root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的其他相关操作"><a href="#二叉树的其他相关操作" class="headerlink" title="二叉树的其他相关操作"></a>二叉树的其他相关操作</h3><h4 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h4><blockquote>
<p>所谓二叉树的高度是指所有叶子节点到根节点的最短路径的最大值+1。如下图中的二叉树的高度为5</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/9HKFMFN.png" alt=""></p>
<p>用眼睛我们可以直接判断出数的高度，那么，如何用代码实现求二叉树的高度呢？</p>
<p> 对于一棵二叉树来说，我们要做的是判断左右子树的高度，取最大值，然后再加上+1（根节点也是一层）。依次递归，对于节点不存在时我们返回其高度为0。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> DepthTree(BinTree root)&#123; <span class="comment">//如果一颗树存在，返回这棵树的高度</span></span><br><span class="line">	<span class="built_in">int</span> hl,hr;<span class="comment">//分别记录左子树高度和右子树高度 </span></span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Lchild)</span><br><span class="line">		hl=DepthTree(root-&gt;Lchild);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		hl=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Rchild)</span><br><span class="line">		hr=DepthTree(root-&gt;Rchild);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		hr=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>  hl&gt;hr?hl+<span class="number">1</span>:hr+<span class="number">1</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求某个节点的高度"><a href="#求某个节点的高度" class="headerlink" title="求某个节点的高度"></a>求某个节点的高度</h4><blockquote>
<p>节点的高度是指当前节点到根节点的路径值+1，如上图中节点D的高度为2+1=3</p>
</blockquote>
<p>和求树的高度思路大致相同，因为一棵树只有一个所求节点，所以需要先在左子树中寻找，如果未找到，则在右子树中寻找，返回0代表该二叉树中无此节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DepthNode(BinTree root,BinTree ch)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root || !ch)<span class="keyword">return</span> NULL;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">len</span>=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(root==ch)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">len</span>=DepthNode(root-&gt;Lchild,ch);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">len</span>&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">len</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">len</span>=DepthNode(root-&gt;Rchild,ch);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求某个节点的双亲节点"><a href="#求某个节点的双亲节点" class="headerlink" title="求某个节点的双亲节点"></a>求某个节点的双亲节点</h4><blockquote>
<p>因为链二叉树的节点内没有直接前驱域，所以需要该项操作，并且判断时是由以某节点的左右孩子是否为给出的节点来判断该节点是否为给出的节点的双亲节点。</p>
</blockquote>
<p>设给出节点为ch.</p>
<ol>
<li>判断根节点是否为ch的双亲节点</li>
<li>判断根节点的左孩子是否为ch的双亲节点</li>
<li>判断根节点的右孩子是否为ch的双亲节点</li>
</ol>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">BinTree <span class="built_in">Parents</span>(BinTree root,BinTree Object)&#123;<span class="comment">//寻找Object的双亲节点</span></span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="built_in">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Lchild==Object || root-&gt;Rchild==Object)<span class="keyword">return</span> root;</span><br><span class="line">	BinTree p;</span><br><span class="line">	p=<span class="built_in">Parents</span>(root-&gt;Lchild,Object);</span><br><span class="line">	<span class="keyword">if</span>(p)<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Parents</span>(root-&gt;Rchild,Object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求二叉树的节点个数"><a href="#求二叉树的节点个数" class="headerlink" title="求二叉树的节点个数"></a>求二叉树的节点个数</h4><p>求节点个数与求树的高度思路大同小异，我们要求的就是左子树的节点个数加上右子树的节点个数再加1（根节点）。依次递归，如果节点不存在，就返回其节点个数为0。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> BinCount(BinTree root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> cl,cr; <span class="comment">//分别记录左子树节点个数和右子树节点个数 </span></span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Lchild)cl=BinCount(root-&gt;Lchild);</span><br><span class="line">	<span class="keyword">else</span> cl=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Rchild)cr=BinCount(root-&gt;Rchild);</span><br><span class="line">	<span class="keyword">else</span> cr=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> cl+cr+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更优的编码方式：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">Size</span>(BinTree T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T==<span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">Size</span>(T-&gt;Lchild)+<span class="keyword">Size</span>(T-&gt;Rchild)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求树的叶子节点个数"><a href="#求树的叶子节点个数" class="headerlink" title="求树的叶子节点个数"></a>求树的叶子节点个数</h4><p>遍历时加以对于叶子节点的判断即可(无孩子),左子树叶子节点个数加上右子树的个数</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BinLeaf_1(BinTree root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Lchild==<span class="keyword">NULL</span> &amp;&amp; root-&gt;Rchild==<span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> BinLeaf_1(root-&gt;Lchild)+BinLeaf_1(root-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出叶子节点值"><a href="#输出叶子节点值" class="headerlink" title="输出叶子节点值"></a>输出叶子节点值</h4><p>先序或者后序遍历时判断是否为叶子节点再输出即可</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">void BinLeaf_2(BinTree root)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;Lchild==<span class="keyword">NULL</span> &amp;&amp; root-&gt;Rchild==<span class="keyword">NULL</span>)</span><br><span class="line">		cout&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	BinLeaf_2(root-&gt;Lchild);</span><br><span class="line">	BinLeaf_2(root-&gt;Rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于二叉树作为一种基础的层次性逻辑结构，在算法中的应用范围很广，例如哈夫曼树、排序二叉树等等……这部分内容还是需要自己牢牢掌握的。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2018/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h3><blockquote>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<a id="more"></a>

<h3 id="快速排序运算方法"><a href="#快速排序运算方法" class="headerlink" title="快速排序运算方法"></a>快速排序运算方法</h3><p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/oTu9sd2.jpg" alt=""></p>
<p>图中由6个数字构成的数组以及用变量temp存储的”哨兵”。left和right初始指向最左值与最右值。</p>
<h4 id="基本操作步骤"><a href="#基本操作步骤" class="headerlink" title="基本操作步骤:"></a>基本操作步骤:</h4><ol>
<li><p>首先将left和right初始指向最左值与最右值，将最左边的值保存为哨兵(temp)</p>
</li>
<li><p>right指向的值与哨兵值相比较</p>
<ol>
<li><p>(right的值<strong>小于</strong>哨兵值时) 将当前right指向的值赋给当前left的值中</p>
</li>
<li><p>(right的值大于等于哨兵值时)right依次往左边滑动，直到满足right指向的值小于哨兵值<br><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/0zBATc0.jpg" alt=""></p>
<blockquote>
<p>图中right指向的值为1小于哨兵值5,所以将left的值赋为1</p>
</blockquote>
</li>
</ol>
</li>
<li><p>left指向的值与哨兵值相比较</p>
<ol>
<li><p>(left的值<strong>大于</strong>哨兵值时) 将当前left指向的值赋给当前right的值中</p>
</li>
<li><p>(left的值小于等于哨兵值时)left依次往右边移动，直到满足left指向的值大于哨兵值<br><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/OHBCjPX.jpg" alt=""></p>
<blockquote>
<p>图中left指向的值原本是1，因为1&lt;5所以left向右移动。因为移动后left指向的值为8,8&gt;5所以right指向的值被赋值为8</p>
</blockquote>
</li>
</ol>
</li>
<li><p>重复进行第2大步和第3大步的操作，直到left==right时，将left(或者right)指向的值赋为哨兵值。再对left(或者right)的两边分别进行这四大步相同的操作。(当左右只剩下1个或0个值时则不再对左右进行操作)</p>
</li>
</ol>
<h4 id="继续完整演示这个序列的快速排序操作步骤"><a href="#继续完整演示这个序列的快速排序操作步骤" class="headerlink" title="继续完整演示这个序列的快速排序操作步骤"></a>继续完整演示这个序列的快速排序操作步骤</h4><p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/vWQLH9l.jpg" alt=""></p>
<blockquote>
<p>因为right指向的值为10大于哨兵值5,所以right继续左移</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/W9kDigT.jpg" alt=""></p>
<blockquote>
<p> 左移后right指向的值4已小于5，所以将当前left指向的值赋为4</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/gxhPrOK.jpg" alt=""></p>
<blockquote>
<p> 因为left指向的值刚刚被赋为比哨兵值5小的数4，所以left右移。右移后left指向的值6&gt;5所以right指向的值被赋为6</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/5q6OGzj.jpg" alt=""></p>
<blockquote>
<p>right左移，left==right ,将left指向的值赋为哨兵值5。</p>
</blockquote>
<blockquote>
<p>这个时候，有没有发现5的左边都是小于5的数，而5的右边同样都是大于5的数了</p>
</blockquote>
<p>这就算是完成第一步数据筛选了，接着用相同的操作步骤来讨论5的两边，以此类推即可完成整个数组的排序。</p>
<h3 id="最后贴上快速排序的实现代码"><a href="#最后贴上快速排序的实现代码" class="headerlink" title="最后贴上快速排序的实现代码"></a>最后贴上快速排序的实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">int</span> temp=a[left],choise=<span class="number">0</span>,l=left,r=right;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">while</span>(choise%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; l&lt;r)&#123;   </span><br><span class="line">			<span class="keyword">if</span>(a[r]&lt;temp)&#123;a[l]=a[r];<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> r--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(choise%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; l&lt;r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[l]&gt;temp)&#123;a[r]=a[l];<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> l++;</span><br><span class="line">		&#125;</span><br><span class="line">		choise++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(choise&gt;<span class="number">0</span>)&#123; </span><br><span class="line">		QuickSort(a,left,r<span class="number">-1</span>);</span><br><span class="line">		QuickSort(a,r+<span class="number">1</span>,right);</span><br><span class="line">	&#125;</span><br><span class="line">	a[l]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2018/06/13/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>哈夫曼(Huffman)树，又称为最优二叉树，是带权路径长度（wpl）最短的二叉树。</p>
</blockquote>
<blockquote>
<p>一般我们要做的事分为三步:</p>
</blockquote>
<ol>
<li>构建哈夫曼树</li>
<li>求WPL值</li>
<li>求哈夫曼编码</li>
</ol>
<h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><ol>
<li>将所有左，右子树都为空的作为根节点。</li>
<li>在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。</li>
<li>从森林中删除这两棵树，同时把新树加入到森林中。</li>
<li>重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。</li>
</ol>
<a id="more"></a>
<p>下面是构建哈夫曼树的图解过程：<br><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/70-20211111212400041.png" alt=""></p>
<h2 id="WPL值的求法"><a href="#WPL值的求法" class="headerlink" title="WPL值的求法"></a>WPL值的求法</h2><p>事实上wpl有两种求法</p>
<ol>
<li>将哈夫曼树的所有分支节点的权值相加就是我们要求的wpl值</li>
<li>将哈夫曼树中的所有叶子节点的权值于路径长度的乘积相加也是我们要求的wpl值</li>
</ol>
<p>例如上图的wpl值就是48</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到每个叶子节点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为各个叶子节点对应的字符编码，即是哈夫曼编码。</p>
<p>就拿上图例子来说：</p>
<pre><code>A，B，C，D对应的哈夫曼编码分别为：111，10，110，0</code></pre><p>用图说明如下：</p>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/70.png" alt="img"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="keyword">int</span>  data;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">left</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">right</span>;</span>    </span><br><span class="line">&#125;btreenode;    </span><br><span class="line">        </span><br><span class="line"><span class="comment">//建立哈夫曼树    </span></span><br><span class="line"><span class="function">btreenode *<span class="title">CreateHuffman</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    btreenode *s[n+<span class="number">1</span>], *ss;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;    </span><br><span class="line">        s[i] = <span class="keyword">new</span> btreenode;  <span class="comment">//初始化s指针数组，使每个指针元素指向a数组中对应的元素结点    </span></span><br><span class="line">        s[i]-&gt;data = a[i];   <span class="comment">//将树拆成森林，每棵树都只有一个根节点    </span></span><br><span class="line">        s[i]-&gt;left = s[i]-&gt;right = <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>;i&lt;n;i++)&#123;        <span class="comment">//进行 n-1次循环建立哈夫曼树    </span></span><br><span class="line">           <span class="keyword">int</span> k = <span class="number">-1</span>,t;           <span class="comment">//k表示森林中具有最小权值的树根结点的下标，t为次最小的下标    </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;   <span class="comment">//k初始指向森林中第一棵树，t指向第二棵    </span></span><br><span class="line">                <span class="keyword">if</span>(s[j]&amp;&amp;k==<span class="number">-1</span>)&#123;    </span><br><span class="line">                   k = j;    </span><br><span class="line">                   <span class="keyword">continue</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="keyword">if</span>(s[j])&#123;    </span><br><span class="line">                    t =  j;    </span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t;i&lt;n;i++)&#123;   <span class="comment">//从当前森林中求出最小权值树和次最小 ；    </span></span><br><span class="line">            <span class="keyword">if</span> (s[i])&#123;    </span><br><span class="line">                <span class="keyword">if</span>(s[i]-&gt;data&lt;s[k]-&gt;data)&#123;        <span class="comment">//比最小树小   </span></span><br><span class="line">                    t = k;    </span><br><span class="line">                    k = i;    </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i]-&gt;data&lt;s[t]-&gt;data)&#123;  <span class="comment">//比次小树小   </span></span><br><span class="line">                    t = i;    </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="keyword">else</span>&#123;    </span><br><span class="line">                    ;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">           <span class="comment">//由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)    </span></span><br><span class="line">           ss  = <span class="keyword">new</span> btreenode;     <span class="comment">//ss = (btreenode *)malloc(sizeof(btreenode))            </span></span><br><span class="line">           ss-&gt;data =   s[k]-&gt;data+s[t]-&gt;data;    </span><br><span class="line">           ss-&gt;left =   s[k];    </span><br><span class="line">           ss-&gt;right =  s[t];    </span><br><span class="line">           s[k] =  ss;  <span class="comment">//关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,    </span></span><br><span class="line">                       <span class="comment">//在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125;    </span></span><br><span class="line">           s[t] = <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">        <span class="keyword">return</span> ss;   </span><br><span class="line">        <span class="built_in">free</span>(s);   <span class="comment">//释放分配空间    </span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//求哈夫曼树的带权路径长度        </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WeightPathLength</span><span class="params">(btreenode* FBT, <span class="keyword">int</span> len)</span></span>&#123;          <span class="comment">//参数len为树的层数   </span></span><br><span class="line">    <span class="keyword">if</span>(!FBT)&#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(FBT-&gt;left ==<span class="literal">NULL</span>&amp;&amp;FBT-&gt;right ==<span class="literal">NULL</span>)<span class="comment">//访问到叶子结点    </span></span><br><span class="line">            <span class="keyword">return</span> FBT-&gt;data*len;    </span><br><span class="line">        <span class="keyword">else</span>&#123;               <span class="comment">//访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增    </span></span><br><span class="line">            <span class="keyword">return</span>  WeightPathLength(FBT-&gt;left,len+<span class="number">1</span>)+WeightPathLength(FBT-&gt;right,len+<span class="number">1</span>);<span class="comment">//一定要记得加1    </span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line"><span class="comment">//哈夫曼编码    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffManCoding</span><span class="params">(btreenode* FBT, <span class="keyword">int</span> len)</span></span>&#123;   <span class="comment">//参数len为树的层数   </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a[<span class="number">20</span>];                        <span class="comment">//定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1   </span></span><br><span class="line">    <span class="keyword">if</span>(FBT)&#123;                                <span class="comment">//访问到叶子结点时输出其保存在数组a中的0和1序列编码    </span></span><br><span class="line">        <span class="keyword">if</span>(FBT-&gt;left == <span class="literal">NULL</span>&amp;&amp;FBT-&gt;right == <span class="literal">NULL</span>)&#123;    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"结点权值为%d的编码:"</span>,FBT-&gt;data);    </span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;    </span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);    </span><br><span class="line">            &#125;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>) ;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span>&#123;    <span class="comment">//访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组    </span></span><br><span class="line">                <span class="comment">//a的对应元素中，向下深入一层时len值增1    </span></span><br><span class="line">               a[len] = <span class="number">0</span>;    </span><br><span class="line">               HuffManCoding(FBT-&gt;left,len+<span class="number">1</span>);    </span><br><span class="line">               a[len] = <span class="number">1</span>;    </span><br><span class="line">               HuffManCoding(FBT-&gt;right,len+<span class="number">1</span>);    </span><br><span class="line">            &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    btreenode *s;    </span><br><span class="line">    <span class="keyword">int</span> n;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"从键盘输入待构造的哈夫曼树中带权叶子结点数n："</span>);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;    </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);    </span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;    </span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-------输入不合法,请重新输入!!\n"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n *<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"从键盘输入%d个整数作为权值:"</span>,n);    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)    </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);    </span><br><span class="line">    s = CreateHuffman(a,n);    </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"哈夫曼树的带权路径长度："</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, WeightPathLength(s, <span class="number">0</span>));    </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树中每个叶子结点的哈夫曼编码：\n"</span>);    </span><br><span class="line">    HuffManCoding(s,<span class="number">0</span>);    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构迷宫问题C++链栈实现</title>
    <url>/2018/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="更新：使用回溯法求解迷宫问题（获取最优路径）"><a href="#更新：使用回溯法求解迷宫问题（获取最优路径）" class="headerlink" title="更新：使用回溯法求解迷宫问题（获取最优路径）"></a>更新：使用回溯法求解迷宫问题（获取最优路径）</h1><a id="more"></a>

<p><strong>原文章使用方法过于愚蠢，请忽略</strong></p>
<p><strong>说明 N 代表迷宫，A代表方位暂存器，V代表对应的N点是否被访问，AS代表方位存储器，Step代表下一步的操作。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> V[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> AS[<span class="number">10001</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Step[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> MinStep = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = A[s<span class="number">-1</span>][<span class="number">0</span>]+Step[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> y = A[s<span class="number">-1</span>][<span class="number">1</span>]+Step[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; y&lt;=n &amp;&amp; V[x][y] != <span class="number">1</span> &amp;&amp; N[x][y] != <span class="number">1</span> &amp;&amp; s&lt;MinStep)&#123;</span><br><span class="line">			V[x][y] = <span class="number">1</span>;</span><br><span class="line">			A[s][<span class="number">0</span>] = x;</span><br><span class="line">			A[s][<span class="number">1</span>] = y;</span><br><span class="line">			<span class="keyword">if</span>(A[s][<span class="number">0</span>] == n &amp;&amp; A[s][<span class="number">1</span>] == n)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s&lt;MinStep)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">						AS[j][<span class="number">0</span>] = A[j][<span class="number">0</span>];</span><br><span class="line">						AS[j][<span class="number">1</span>] = A[j][<span class="number">1</span>];</span><br><span class="line">					&#125;</span><br><span class="line">					MinStep = s;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				Search(s+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			V[x][y] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A[<span class="number">1</span>][<span class="number">0</span>] = A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;N[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Search(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;MinStep&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=MinStep;j++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;AS[j][<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;AS[j][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原文章："><a href="#原文章：" class="headerlink" title="原文章："></a><strong>原文章：</strong></h1><p><strong>刚刚学完栈时，拿到这个题目的瞬间 感觉自己的栈知识都白学了。不是因为不会使用栈，而是因为自己一点解题思路都没有，后来通过自己的一些推敲和查看一些资料，终于弄明白了如何求解。</strong><br><strong>接下来通过写出一些关键点，大家可以加以参考）</strong></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li><p>首先要建立一个用于存放方位信息的结构体类型Point(包括三个数据成员：行标row,列标col,下一步要走的方向way);</p>
</li>
<li><p>然后建立一个头节点指针类型LStack（包括方位信息Point类型的p 和 后继地址next），而这个链栈就是我们将要存放的路径信息。</p>
</li>
<li><p>分别写出入栈In和出栈Out的函数</p>
</li>
<li><p>遍历函数Display，注意因为栈的特性是先进后出，所有我们在显示的时候需要把链栈逆序输出</p>
</li>
<li><p>接下来就是最重要的Found，该函数要做的就是寻找路径</p>
<ol>
<li>首先定义一个二维数组，这个数组map就是作为地图的存在，其中1代表不能走，0可走。</li>
<li>我们把数组的四边都定义为1，其余内部码入整个地图的数据；</li>
<li>定义Point类型的起点Home和End以及当前格子temp；</li>
<li>进入循环（当temp到达End时终止循环）当temp每到达新的一个格子时，都要对（<em>除了temp原来的格子相对于当前temp的方向（比如原来temp在当前temp的上方，则在本次判定中不再对当前temp的上方进行判断）</em>）的所有方向进行判断：如果为0且路径链栈top的数据元素不含当前temp的值时则成功入栈，否则判断下一个方向。如果上下左右都不满足以上条件时则说明该格子是断头路需要退栈返回到上一个格子中并将该格子标记为-1。</li>
<li>如此循环下来，如果起点被标记成了断头路则说明该迷宫无正确路径，返回false。如果temp为终点End值则说明成功找到路径并以保存再链栈top中，返回true.</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>至此，我们的工作已经基本完成了，只需要再主函数main中建立一个链表再调用相关函数即可。</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/JackyM06/MyPictures/master/F42QPc8.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include&lt;iostream&gt;  </span></span><br><span class="line"><span class="meta">#include&lt;cstdlib&gt;  </span></span><br><span class="line"><span class="keyword">using</span> namespace std;  </span><br><span class="line">typedef struct &#123;    //用于封装方位及方向   </span><br><span class="line">    <span class="type">int</span> col,<span class="keyword">row</span>,way;                 //<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>分别代表上、下、左、右   </span><br><span class="line">&#125;<span class="type">Point</span>;  </span><br><span class="line">  </span><br><span class="line">typedef struct T&#123;  //路径链表节点   </span><br><span class="line">    <span class="type">Point</span> P;  </span><br><span class="line">    struct T *next;  </span><br><span class="line">&#125;LStack;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="keyword">In</span>(LStack *top,<span class="type">Point</span> <span class="keyword">temp</span>)&#123;  //入栈   </span><br><span class="line">    LStack *s=(LStack *)malloc(sizeof(LStack));  </span><br><span class="line">    s-&gt;P=<span class="keyword">temp</span>;  </span><br><span class="line">    s-&gt;next=top-&gt;next;  </span><br><span class="line">    top-&gt;next=s;  </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="keyword">Out</span>(LStack *top)&#123;       //出栈   </span><br><span class="line">    <span class="keyword">if</span>(top-&gt;next==<span class="keyword">NULL</span>)<span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        LStack *p=top-&gt;next;  </span><br><span class="line">        top-&gt;next=p-&gt;next;  </span><br><span class="line">        free(p);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">bool</span> Query(LStack *top,<span class="type">Point</span> <span class="keyword">temp</span>)&#123; //查询栈中是否存在<span class="keyword">temp</span>值   </span><br><span class="line">    LStack *p=top-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;P.<span class="keyword">row</span>==<span class="keyword">temp</span>.<span class="keyword">row</span> &amp;&amp; p-&gt;P.col==<span class="keyword">temp</span>.col)<span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="built_in">Found</span>(LStack *top)&#123;  </span><br><span class="line">    <span class="type">int</span> height,width;  </span><br><span class="line">    height=<span class="number">9</span>;width=<span class="number">8</span>;  </span><br><span class="line">    <span class="type">Point</span> Home,<span class="keyword">End</span>,<span class="keyword">temp</span>;  </span><br><span class="line">    Home.<span class="keyword">row</span>=<span class="number">1</span>;Home.col=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">End</span>.<span class="keyword">row</span>=<span class="number">9</span>;<span class="keyword">End</span>.col=<span class="number">8</span>;  </span><br><span class="line">    <span class="type">int</span> map[][<span class="number">10</span>]=&#123;  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">temp</span>.col=Home.col;<span class="keyword">temp</span>.<span class="keyword">row</span>=Home.<span class="keyword">row</span>;  </span><br><span class="line">    <span class="keyword">do</span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">temp</span>.way=<span class="number">0</span>;<span class="keyword">temp</span>.way&lt;=<span class="number">3</span>;<span class="keyword">temp</span>.way++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(top-&gt;next!=<span class="keyword">NULL</span> &amp;&amp; ((top-&gt;next-&gt;P.way+<span class="number">2</span>)%<span class="number">4</span>==<span class="keyword">temp</span>.way))<span class="keyword">continue</span>;  //解决上下，左右重复死循环问题   </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">temp</span>.way==<span class="number">0</span>)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(map[<span class="comment">--temp.row][temp.col]==0 &amp;&amp; !Query(top,temp))&#123;  </span></span><br><span class="line">                    <span class="keyword">temp</span>.<span class="keyword">row</span>++;  </span><br><span class="line">                    <span class="keyword">In</span>(top,<span class="keyword">temp</span>);  </span><br><span class="line">                    <span class="keyword">temp</span>.<span class="keyword">row</span><span class="comment">--;  </span></span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>&#123;  </span><br><span class="line">                    <span class="keyword">temp</span>.<span class="keyword">row</span>++;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">temp</span>.way==<span class="number">1</span>)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(map[<span class="keyword">temp</span>.<span class="keyword">row</span>][++<span class="keyword">temp</span>.col]==<span class="number">0</span> &amp;&amp; !Query(top,<span class="keyword">temp</span>))&#123;  </span><br><span class="line">                    <span class="keyword">temp</span>.col<span class="comment">--;  </span></span><br><span class="line">                    <span class="keyword">In</span>(top,<span class="keyword">temp</span>);  </span><br><span class="line">                    <span class="keyword">temp</span>.col++;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>&#123;  </span><br><span class="line">                    <span class="keyword">temp</span>.col<span class="comment">--;  </span></span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">temp</span>.way==<span class="number">2</span>)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(map[++<span class="keyword">temp</span>.<span class="keyword">row</span>][<span class="keyword">temp</span>.col]==<span class="number">0</span> &amp;&amp; !Query(top,<span class="keyword">temp</span>))&#123;  </span><br><span class="line">                    <span class="keyword">temp</span>.<span class="keyword">row</span><span class="comment">--;  </span></span><br><span class="line">                    <span class="keyword">In</span>(top,<span class="keyword">temp</span>);  </span><br><span class="line">                    <span class="keyword">temp</span>.<span class="keyword">row</span>++;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>&#123;  </span><br><span class="line">                    <span class="keyword">temp</span>.<span class="keyword">row</span><span class="comment">--;  </span></span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">temp</span>.way==<span class="number">3</span>)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(map[<span class="keyword">temp</span>.<span class="keyword">row</span>][<span class="comment">--temp.col]==0 &amp;&amp; !Query(top,temp))&#123;  </span></span><br><span class="line">                    <span class="keyword">temp</span>.col++;  </span><br><span class="line">                    <span class="keyword">In</span>(top,<span class="keyword">temp</span>);  </span><br><span class="line">                    <span class="keyword">temp</span>.col<span class="comment">--;  </span></span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>&#123;  </span><br><span class="line">                    <span class="keyword">temp</span>.col++;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">temp</span>.way&gt;<span class="number">3</span>)&#123;     //无路可走时将点标<span class="number">-1</span>并退栈   </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">temp</span>.<span class="keyword">row</span>==Home.<span class="keyword">row</span> &amp;&amp; <span class="keyword">temp</span>.col==Home.col)<span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            map[<span class="keyword">temp</span>.<span class="keyword">row</span>][<span class="keyword">temp</span>.col]=<span class="number">-1</span>;  </span><br><span class="line">            <span class="keyword">Out</span>(top);  </span><br><span class="line">            <span class="keyword">temp</span>=top-&gt;next-&gt;P;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;<span class="keyword">while</span>(!(<span class="keyword">temp</span>.<span class="keyword">row</span>==<span class="keyword">End</span>.<span class="keyword">row</span> &amp;&amp; <span class="keyword">temp</span>.col==<span class="keyword">End</span>.col));  </span><br><span class="line">    <span class="keyword">temp</span>.way=<span class="number">4</span>;          </span><br><span class="line">    <span class="keyword">In</span>(top,<span class="keyword">temp</span>);           //到达出口，入栈出口信息   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">void</span> Display(LStack *top)&#123;     //通过头插二次入栈实现逆序链表.   </span><br><span class="line">    LStack *s,*p=top-&gt;next;  </span><br><span class="line">    top-&gt;next=<span class="keyword">NULL</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next!=<span class="keyword">NULL</span> &amp;&amp; p-&gt;P.col==p-&gt;next-&gt;P.col &amp;&amp; p-&gt;P.<span class="keyword">row</span>==p-&gt;next-&gt;P.<span class="keyword">row</span>)p=p-&gt;next; //解决原路径中会存在一些判断退回时产生的数据冗余问题。   </span><br><span class="line">        s=p;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">        s-&gt;next=top-&gt;next;  </span><br><span class="line">        top-&gt;next=s;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">while</span>(s!=<span class="keyword">NULL</span>)&#123;  </span><br><span class="line">        cout&lt;&lt;s-&gt;P.<span class="keyword">row</span>&lt;&lt;" "&lt;&lt;s-&gt;P.col&lt;&lt;" "&lt;&lt;s-&gt;P.way&lt;&lt;endl;   </span><br><span class="line">        s=s-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> main()&#123;  </span><br><span class="line">    LStack *top=(LStack *)malloc(sizeof(LStack));  </span><br><span class="line">    top-&gt;next=<span class="keyword">NULL</span>;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Found</span>(top))&#123;  </span><br><span class="line">        cout&lt;&lt;"存在正确路径，如下(row,col,方向（0上,1右,2下,3左，4出口）)："&lt;&lt;endl;  </span><br><span class="line">        Display(top);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;"无法到达出口"&lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><blockquote>
<p>在图中其实已经看的出来，在寻找路径时有可能会绕远路，虽然能够到达终点，但是这不符合我们寻找最优路径的期望</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客纪念</title>
    <url>/2018/06/11/%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>纪念博客搭建完成</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
